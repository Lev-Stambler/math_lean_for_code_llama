[{"text": "/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\nimport Mathlib.CategoryTheory.EqToHom\n\n#align_import category_theory.sums.basic from \"leanprover-community/mathlib\"@\"dc6c365e751e34d100e80fe6e314c3c3e0fd2988\"\n\n/-!\n# Binary disjoint unions of categories\n\nWe define the category instance on `C \u2295 D` when `C` and `D` are categories.\n\nWe define:\n* `inl_`      : the functor `C \u2964 C \u2295 D`\n* `inr_`      : the functor `D \u2964 C \u2295 D`\n* `swap`      : the functor `C \u2295 D \u2964 D \u2295 C`\n    (and the fact this is an equivalence)\n\nWe further define sums of functors and natural transformations, written `F.sum G` and `\u03b1.sum \u03b2`.\n-/\n\n\nnamespace CategoryTheory\n\nuniverse v\u2081 u\u2081\n\n-- morphism levels before object levels. See note [category_theory universes].\nopen Sum\n\nsection\n\nvariable (C : Type u\u2081) [Category.{v\u2081} C] (D : Type u\u2081) [Category.{v\u2081} D]\n\n/- Porting note: `aesop_cat` not firing on `assoc` where autotac in Lean 3 did-/\n\n/-- `sum C D` gives the direct sum of two categories.\n-/\ninstance sum : Category.{v\u2081} (Sum C D) where\n  Hom X Y :=\n    match X, Y with\n    | inl X, inl Y => X \u27f6 Y\n    | inl _, inr _ => PEmpty\n    | inr _, inl _ => PEmpty\n    | inr X, inr Y => X \u27f6 Y\n  id X :=\n    match X with\n    | inl X => \ud835\udfd9 X\n    | inr X => \ud835\udfd9 X\n  comp := @fun X Y Z f g =>\n    match X, Y, Z, f, g with\n    | inl X, inl Y, inl Z, f, g => f \u226b g\n    | inr X, inr Y, inr Z, f, g => f \u226b g\n  assoc := @fun W X Y Z f g h =>\n    match X, Y, Z, W with\n    | inl X, inl Y, inl Z, inl W => Category.assoc f g h\n    | inr X, inr Y, inr Z, inr W => Category.assoc f g h\n#align category_theory.sum CategoryTheory.sum\n\n/- Porting note: seems similar to Mathlib4#1036 issue so marked as nolint  -/\n@[simp, nolint simpComm]\ntheorem sum_comp_inl {P Q R : C} (f : (inl P : Sum C D) \u27f6 inl Q) (g : (inl Q : Sum C D) \u27f6 inl R) :\n    @CategoryStruct.comp _ _ P Q R (f : P \u27f6 Q) (g : Q \u27f6 R) =\n      @CategoryStruct.comp _ _ (inl P) (inl Q) (inl R) (f : P \u27f6 Q) (g : Q \u27f6 R) :=\n  rfl\n#align category_theory.sum_comp_inl CategoryTheory.sum_comp_inl\n\n/- Porting note: seems similar to Mathlib4#1036 issue so marked as nolint  -/\n@[simp, nolint simpComm]\ntheorem sum_comp_inr {P Q R : D} (f : (inr P : Sum C D) \u27f6 inr Q) (g : (inr Q : Sum C D) \u27f6 inr R) :\n    @CategoryStruct.comp _ _ P Q R (f : P \u27f6 Q) (g : Q \u27f6 R) =\n      @CategoryStruct.comp _ _ (inr P) (inr Q) (inr R) (f : P \u27f6 Q) (g : Q \u27f6 R) :=\n  rfl\n#align category_theory.sum_comp_inr CategoryTheory.sum_comp_inr\n\nend\n\nnamespace Sum\n\nvariable (C : Type u\u2081) [Category.{v\u2081} C] (D : Type u\u2081) [Category.{v\u2081} D]\n\n-- Unfortunate naming here, suggestions welcome.\n/-- `inl_` is the functor `X \u21a6 inl X`. -/\n@[simps]\ndef inl_ : C \u2964 Sum C D where\n  obj X := inl X\n  map := @fun X Y f => f\n#align category_theory.sum.inl_ CategoryTheory.Sum.inl_\n\n/-- `inr_` is the functor `X \u21a6 inr X`. -/\n@[simps]\ndef inr_ : D \u2964 Sum C D where\n  obj X := inr X\n  map := @fun X Y f => f\n#align category_theory.sum.inr_ CategoryTheory.Sum.inr_\n\n/- Porting note: `aesop_cat` not firing on `map_comp` where autotac in Lean 3 did\nbut `map_id` was ok. -/\n\n/-- The functor exchanging two direct summand categories. -/\ndef swap : Sum C D \u2964 Sum D C where\n  obj X :=\n    match X with\n    | inl X => inr X\n    | inr X => inl X\n  map := @fun X Y f =>\n    match X, Y, f with\n    | inl _, inl _, f => f\n    | inr _, inr _, f => f\n  map_comp := fun {X} {Y} {Z} _ _ =>\n    match X, Y, Z with\n    | inl X, inl Y, inl Z => by rfl\n    | inr X, inr Y, inr Z => by rfl\n#align category_theory.sum.swap CategoryTheory.Sum.swap\n\n@[simp]\ntheorem swap_obj_inl (X : C) : (swap C D).obj (inl X) = inr X :=\n  rfl\n#align category_theory.sum.swap_obj_inl CategoryTheory.Sum.swap_obj_inl\n\n@[simp]\ntheorem swap_obj_inr (X : D) : (swap C D).obj (inr X) = inl X :=\n  rfl\n#align category_theory.sum.swap_obj_inr CategoryTheory.Sum.swap_obj_inr\n\n@[simp]\ntheorem swap_map_inl {X Y : C} {f : inl X \u27f6 inl Y} : (swap C D).map f = f :=\n  rfl\n#align category_theory.sum.swap_map_inl CategoryTheory.Sum.swap_map_inl\n\n@[simp]\ntheorem swap_map_inr {X Y : D} {f : inr X \u27f6 inr Y} : (swap C D).map f = f :=\n  rfl\n#align category_theory.sum.swap_map_inr CategoryTheory.Sum.swap_map_inr\n\nnamespace Swap\n\n/- Porting note: had to manually call `cases f` for `f : PEmpty` -/\n\n/-- `swap` gives an equivalence between `C \u2295 D` and `D \u2295 C`. -/\ndef equivalence : Sum C D \u224c Sum D C :=\n  Equivalence.mk (swap C D) (swap D C)\n    (NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl))\n      (by simp only [swap]; aesop_cat_nonterminal; cases f; cases f))\n    (NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl))\n      (by simp only [swap]; aesop_cat_nonterminal; cases f; cases f))\n#align category_theory.sum.swap.equivalence CategoryTheory.Sum.Swap.equivalence\n\ninstance isEquivalence : IsEquivalence (swap C D) :=\n  (by infer_instance : IsEquivalence (equivalence C D).functor)\n#align category_theory.sum.swap.is_equivalence CategoryTheory.Sum.Swap.isEquivalence\n\n/-- The double swap on `C \u2295 D` is naturally isomorphic to the identity functor. -/\ndef symmetry : swap C D \u22d9 swap D C \u2245 \ud835\udfed (Sum C D) :=\n  (equivalence C D).unitIso.symm\n#align category_theory.sum.swap.symmetry CategoryTheory.Sum.Swap.symmetry\n\nend Swap\n\nend Sum\n\nvariable {A : Type u\u2081} [Category.{v\u2081} A] {B : Type u\u2081} [Category.{v\u2081} B] {C : Type u\u2081}\n  [Category.{v\u2081} C] {D : Type u\u2081} [Category.{v\u2081} D]\n\nnamespace Functor\n\n/-- The sum of two functors. -/\ndef sum (F : A \u2964 B) (G : C \u2964 D) : Sum A C \u2964 Sum B D\n    where\n  obj X :=\n    match X with\n    | inl X => inl (F.obj X)\n    | inr X => inr (G.obj X)\n  map := @fun X Y f =>\n    match X, Y, f with\n    | inl X, inl Y, f => F.map f\n    | inr X, inr Y, f => G.map f\n  map_id := @fun X => by cases X <;> aesop_cat_nonterminal; erw [F.map_id]; rfl; erw [G.map_id]; rfl\n  map_comp := @fun X Y Z f g =>\n    match X, Y, Z, f, g with\n    | inl X, inl Y, inl Z, f, g => by\n      aesop_cat_nonterminal <;>\n      erw [F.map_comp] <;>\n      rfl\n    | inr X, inr Y, inr Z, f, g => by\n      aesop_cat_nonterminal <;>\n      erw [G.map_comp] <;>\n      rfl\n#align category_theory.functor.sum CategoryTheory.Functor.sum\n\n@[simp]\ntheorem sum_obj_inl (F : A \u2964 B) (G : C \u2964 D) (a : A) : (F.sum G).obj (inl a) = inl (F.obj a) :=\n  rfl\n#align category_theory.functor.sum_obj_inl CategoryTheory.Functor.sum_obj_inl\n\n@[simp]\ntheorem sum_obj_inr (F : A \u2964 B) (G : C \u2964 D) (c : C) : (F.sum G).obj (inr c) = inr (G.obj c) :=\n  rfl\n#align category_theory.functor.sum_obj_inr CategoryTheory.Functor.sum_obj_inr\n\n@[simp]\ntheorem sum_map_inl (F : A \u2964 B) (G : C \u2964 D) {a a' : A} (f : inl a \u27f6 inl a') :\n    (F.sum G).map f = F.map f :=\n  rfl\n#align category_theory.functor.sum_map_inl CategoryTheory.Functor.sum_map_inl\n\n@[simp]\ntheorem sum_map_inr (F : A \u2964 B) (G : C \u2964 D) {c c' : C} (f : inr c \u27f6 inr c') :\n    (F.sum G).map f = G.map f :=\n  rfl\n#align category_theory.functor.sum_map_inr CategoryTheory.Functor.sum_map_inr\n\nend Functor\n\nnamespace NatTrans\n\n/-- The sum of two natural transformations. -/\ndef sum {F G : A \u2964 B} {H I : C \u2964 D} (\u03b1 : F \u27f6 G) (\u03b2 : H \u27f6 I) : F.sum H \u27f6 G.sum I\n    where\n  app X :=\n    match X with\n    | inl X => \u03b1.app X\n    | inr X => \u03b2.app X\n  naturality X Y f :=\n    match X, Y, f with\n    | inl X, inl Y, f => by aesop_cat_nonterminal <;> erw [\u03b1.naturality] <;> rfl\n    | inr X, inr Y, f => by aesop_cat_nonterminal <;> erw [\u03b2.naturality] <;> rfl\n#align category_theory.nat_trans.sum CategoryTheory.NatTrans.sum\n\n@[simp]\ntheorem sum_app_inl {F G : A \u2964 B} {H I : C \u2964 D} (\u03b1 : F \u27f6 G) (\u03b2 : H \u27f6 I) (a : A) :\n    (sum \u03b1 \u03b2).app (inl a) = \u03b1.app a :=\n  rfl\n#align category_theory.nat_trans.sum_app_inl CategoryTheory.NatTrans.sum_app_inl\n\n@[simp]\ntheorem sum_app_inr {F G : A \u2964 B} {H I : C \u2964 D} (\u03b1 : F \u27f6 G) (\u03b2 : H \u27f6 I) (c : C) :\n    (sum \u03b1 \u03b2).app (inr c) = \u03b2.app c :=\n  rfl\n#align category_theory.nat_trans.sum_app_inr CategoryTheory.NatTrans.sum_app_inr\n\nend NatTrans\n\nend CategoryTheory\n"}, {"text": "/-\nCopyright (c) 2022 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\nimport Mathlib.Data.Fintype.Order\nimport Mathlib.Algebra.DirectLimit\nimport Mathlib.ModelTheory.Quotients\nimport Mathlib.ModelTheory.FinitelyGenerated\n\n#align_import model_theory.direct_limit from \"leanprover-community/mathlib\"@\"f53b23994ac4c13afa38d31195c588a1121d1860\"\n\n/-!\n# Direct Limits of First-Order Structures\nThis file constructs the direct limit of a directed system of first-order embeddings.\n\n## Main Definitions\n* `FirstOrder.Language.DirectLimit G f` is the direct limit of the directed system `f` of\n  first-order embeddings between the structures indexed by `G`.\n-/\n\n\nuniverse v w u\u2081 u\u2082\n\nopen FirstOrder\n\nnamespace FirstOrder\n\nnamespace Language\n\nopen Structure Set\n\nvariable {L : Language} {\u03b9 : Type v} [Preorder \u03b9]\n\nvariable {G : \u03b9 \u2192 Type w} [\u2200 i, L.Structure (G i)]\n\nvariable (f : \u2200 i j, i \u2264 j \u2192 G i \u21aa[L] G j)\n\nnamespace DirectedSystem\n\n/-- A copy of `DirectedSystem.map_self` specialized to `L`-embeddings, as otherwise the\n`\u03bb i j h, f i j h` can confuse the simplifier. -/\nnonrec theorem map_self [DirectedSystem G fun i j h => f i j h] (i x h) : f i i h x = x :=\n  DirectedSystem.map_self (fun i j h => f i j h) i x h\n#align first_order.language.directed_system.map_self FirstOrder.Language.DirectedSystem.map_self\n\n/-- A copy of `DirectedSystem.map_map` specialized to `L`-embeddings, as otherwise the\n`\u03bb i j h, f i j h` can confuse the simplifier. -/\nnonrec theorem map_map [DirectedSystem G fun i j h => f i j h] {i j k} (hij hjk x) :\n    f j k hjk (f i j hij x) = f i k (le_trans hij hjk) x :=\n  DirectedSystem.map_map (fun i j h => f i j h) hij hjk x\n#align first_order.language.directed_system.map_map FirstOrder.Language.DirectedSystem.map_map\n\nvariable {G' : \u2115 \u2192 Type w} [\u2200 i, L.Structure (G' i)] (f' : \u2200 n : \u2115, G' n \u21aa[L] G' (n + 1))\n\n/-- Given a chain of embeddings of structures indexed by `\u2115`, defines a `DirectedSystem` by\ncomposing them. -/\ndef natLERec (m n : \u2115) (h : m \u2264 n) : G' m \u21aa[L] G' n :=\n  Nat.leRecOn h (@fun k g => (f' k).comp g) (Embedding.refl L _)\n#align first_order.language.directed_system.nat_le_rec FirstOrder.Language.DirectedSystem.natLERec\n\n@[simp]\ntheorem coe_natLERec (m n : \u2115) (h : m \u2264 n) :\n    (natLERec f' m n h : G' m \u2192 G' n) = Nat.leRecOn h (@fun k => f' k) := by\n  obtain \u27e8k, rfl\u27e9 := Nat.exists_eq_add_of_le h\n  ext x\n  induction' k with k ih\n  \u00b7 rw [natLERec, Nat.leRecOn_self, Embedding.refl_apply, Nat.leRecOn_self]\n  \u00b7 rw [Nat.leRecOn_succ le_self_add, natLERec, Nat.leRecOn_succ le_self_add, \u2190 natLERec,\n      Embedding.comp_apply, ih]\n#align first_order.language.directed_system.coe_nat_le_rec FirstOrder.Language.DirectedSystem.coe_natLERec\n\ninstance natLERec.directedSystem : DirectedSystem G' fun i j h => natLERec f' i j h :=\n  \u27e8fun i x h => congr (congr rfl (Nat.leRecOn_self _)) rfl,\n   fun hij hjk => by simp [Nat.leRecOn_trans hij hjk]\u27e9\n#align first_order.language.directed_system.nat_le_rec.directed_system FirstOrder.Language.DirectedSystem.natLERec.directedSystem\n\nend DirectedSystem\n\n-- Porting note : Instead of `\u03a3 i, G i`, we use the alias `Language.Structure.Sigma`\n-- which depends on `f`. This way, Lean can infer what `L` and `f` are in the `Setoid` instance.\n-- Otherwise we have a \"cannot find synthesization order\" error. See the discussion at\n-- https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/local.20instance.20cannot.20find.20synthesization.20order.20in.20porting\n\nset_option linter.unusedVariables false in\n/-- Alias for `\u03a3 i, G i`. -/\n@[nolint unusedArguments]\nprotected abbrev Structure.Sigma (f : \u2200 i j, i \u2264 j \u2192 G i \u21aa[L] G j) := \u03a3 i, G i\n\n-- Porting note: Setting up notation for `Language.Structure.Sigma`: add a little asterisk to `\u03a3`\nlocal notation \"\u03a3\u02e3\" => Structure.Sigma\n\n/-- Constructor for `FirstOrder.Language.Structure.Sigma` alias. -/\nabbrev Structure.Sigma.mk (i : \u03b9) (x : G i) : \u03a3\u02e3 f := \u27e8i, x\u27e9\n\nnamespace DirectLimit\n\n/-- Raises a family of elements in the `\u03a3`-type to the same level along the embeddings. -/\ndef unify {\u03b1 : Type*} (x : \u03b1 \u2192 \u03a3\u02e3 f) (i : \u03b9) (h : i \u2208 upperBounds (range (Sigma.fst \u2218 x)))\n    (a : \u03b1) : G i :=\n  f (x a).1 i (h (mem_range_self a)) (x a).2\n#align first_order.language.direct_limit.unify FirstOrder.Language.DirectLimit.unify\n\nvariable [DirectedSystem G fun i j h => f i j h]\n\n@[simp]\ntheorem unify_sigma_mk_self {\u03b1 : Type*} {i : \u03b9} {x : \u03b1 \u2192 G i} :\n    (unify f (fun a => .mk f i (x a)) i fun j \u27e8a, hj\u27e9 =>\n      _root_.trans (le_of_eq hj.symm) (refl _)) = x := by\n  ext a\n  rw [unify]\n  apply DirectedSystem.map_self\n#align first_order.language.direct_limit.unify_sigma_mk_self FirstOrder.Language.DirectLimit.unify_sigma_mk_self\n\ntheorem comp_unify {\u03b1 : Type*} {x : \u03b1 \u2192 \u03a3\u02e3 f} {i j : \u03b9} (ij : i \u2264 j)\n    (h : i \u2208 upperBounds (range (Sigma.fst \u2218 x))) :\n    f i j ij \u2218 unify f x i h = unify f x j\n      fun k hk => _root_.trans (mem_upperBounds.1 h k hk) ij := by\n  ext a\n  simp [unify, DirectedSystem.map_map]\n#align first_order.language.direct_limit.comp_unify FirstOrder.Language.DirectLimit.comp_unify\n\nend DirectLimit\n\nvariable (G)\n\nnamespace DirectLimit\n\n/-- The directed limit glues together the structures along the embeddings. -/\ndef setoid [DirectedSystem G fun i j h => f i j h] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] : Setoid (\u03a3\u02e3 f) where\n  r := fun \u27e8i, x\u27e9 \u27e8j, y\u27e9 => \u2203 (k : \u03b9) (ik : i \u2264 k) (jk : j \u2264 k), f i k ik x = f j k jk y\n  iseqv :=\n    \u27e8fun \u27e8i, x\u27e9 => \u27e8i, refl i, refl i, rfl\u27e9, @fun \u27e8i, x\u27e9 \u27e8j, y\u27e9 \u27e8k, ik, jk, h\u27e9 =>\n      \u27e8k, jk, ik, h.symm\u27e9,\n      @fun \u27e8i, x\u27e9 \u27e8j, y\u27e9 \u27e8k, z\u27e9 \u27e8ij, hiij, hjij, hij\u27e9 \u27e8jk, hjjk, hkjk, hjk\u27e9 => by\n        obtain \u27e8ijk, hijijk, hjkijk\u27e9 := directed_of (\u00b7 \u2264 \u00b7) ij jk\n        refine' \u27e8ijk, le_trans hiij hijijk, le_trans hkjk hjkijk, _\u27e9\n        rw [\u2190 DirectedSystem.map_map, hij, DirectedSystem.map_map]\n        symm\n        rw [\u2190 DirectedSystem.map_map, \u2190 hjk, DirectedSystem.map_map] <;> assumption\u27e9\n#align first_order.language.direct_limit.setoid FirstOrder.Language.DirectLimit.setoid\n\n/-- The structure on the `\u03a3`-type which becomes the structure on the direct limit after quotienting.\n -/\nnoncomputable def sigmaStructure [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] [Nonempty \u03b9] : L.Structure (\u03a3\u02e3 f) where\n  funMap F x :=\n    \u27e8_,\n      funMap F\n        (unify f x (Classical.choose (Fintype.bddAbove_range fun a => (x a).1))\n          (Classical.choose_spec (Fintype.bddAbove_range fun a => (x a).1)))\u27e9\n  RelMap R x :=\n    RelMap R\n      (unify f x (Classical.choose (Fintype.bddAbove_range fun a => (x a).1))\n        (Classical.choose_spec (Fintype.bddAbove_range fun a => (x a).1)))\n#align first_order.language.direct_limit.sigma_structure FirstOrder.Language.DirectLimit.sigmaStructure\n\nend DirectLimit\n\n/-- The direct limit of a directed system is the structures glued together along the embeddings. -/\ndef DirectLimit [DirectedSystem G fun i j h => f i j h] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] :=\n  Quotient (DirectLimit.setoid G f)\n#align first_order.language.direct_limit FirstOrder.Language.DirectLimit\n\nattribute [local instance] DirectLimit.setoid\n\n-- Porting note: Added local instance\nattribute [local instance] DirectLimit.sigmaStructure\n\n\ninstance [DirectedSystem G fun i j h => f i j h] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] [Inhabited \u03b9]\n    [Inhabited (G default)] : Inhabited (DirectLimit G f) :=\n  \u27e8\u27e6\u27e8default, default\u27e9\u27e7\u27e9\n\nnamespace DirectLimit\n\nvariable [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] [DirectedSystem G fun i j h => f i j h]\n\ntheorem equiv_iff {x y : \u03a3\u02e3 f} {i : \u03b9} (hx : x.1 \u2264 i) (hy : y.1 \u2264 i) :\n    x \u2248 y \u2194 (f x.1 i hx) x.2 = (f y.1 i hy) y.2 := by\n  cases x\n  cases y\n  refine' \u27e8fun xy => _, fun xy => \u27e8i, hx, hy, xy\u27e9\u27e9\n  obtain \u27e8j, _, _, h\u27e9 := xy\n  obtain \u27e8k, ik, jk\u27e9 := directed_of (\u00b7 \u2264 \u00b7) i j\n  have h := congr_arg (f j k jk) h\n  apply (f i k ik).injective\n  rw [DirectedSystem.map_map, DirectedSystem.map_map] at *\n  exact h\n#align first_order.language.direct_limit.equiv_iff FirstOrder.Language.DirectLimit.equiv_iff\n\ntheorem funMap_unify_equiv {n : \u2115} (F : L.Functions n) (x : Fin n \u2192 \u03a3\u02e3 f) (i j : \u03b9)\n    (hi : i \u2208 upperBounds (range (Sigma.fst \u2218 x))) (hj : j \u2208 upperBounds (range (Sigma.fst \u2218 x))) :\n    Structure.Sigma.mk f i (funMap F (unify f x i hi)) \u2248 .mk f j (funMap F (unify f x j hj)) := by\n  obtain \u27e8k, ik, jk\u27e9 := directed_of (\u00b7 \u2264 \u00b7) i j\n  refine' \u27e8k, ik, jk, _\u27e9\n  rw [(f i k ik).map_fun, (f j k jk).map_fun, comp_unify, comp_unify]\n#align first_order.language.direct_limit.fun_map_unify_equiv FirstOrder.Language.DirectLimit.funMap_unify_equiv\n\ntheorem relMap_unify_equiv {n : \u2115} (R : L.Relations n) (x : Fin n \u2192 \u03a3\u02e3 f) (i j : \u03b9)\n    (hi : i \u2208 upperBounds (range (Sigma.fst \u2218 x))) (hj : j \u2208 upperBounds (range (Sigma.fst \u2218 x))) :\n    RelMap R (unify f x i hi) = RelMap R (unify f x j hj) := by\n  obtain \u27e8k, ik, jk\u27e9 := directed_of (\u00b7 \u2264 \u00b7) i j\n  rw [\u2190 (f i k ik).map_rel, comp_unify, \u2190 (f j k jk).map_rel, comp_unify]\n#align first_order.language.direct_limit.rel_map_unify_equiv FirstOrder.Language.DirectLimit.relMap_unify_equiv\n\nvariable [Nonempty \u03b9]\n\ntheorem exists_unify_eq {\u03b1 : Type*} [Fintype \u03b1] {x y : \u03b1 \u2192 \u03a3\u02e3 f} (xy : x \u2248 y) :\n    \u2203 (i : \u03b9)(hx : i \u2208 upperBounds (range (Sigma.fst \u2218 x)))(hy :\n      i \u2208 upperBounds (range (Sigma.fst \u2218 y))), unify f x i hx = unify f y i hy := by\n  obtain \u27e8i, hi\u27e9 := Fintype.bddAbove_range (Sum.elim (fun a => (x a).1) fun a => (y a).1)\n  rw [Sum.elim_range, upperBounds_union] at hi\n  simp_rw [\u2190 Function.comp_apply (f := Sigma.fst)] at hi\n  exact \u27e8i, hi.1, hi.2, funext fun a => (equiv_iff G f _ _).1 (xy a)\u27e9\n#align first_order.language.direct_limit.exists_unify_eq FirstOrder.Language.DirectLimit.exists_unify_eq\n\ntheorem funMap_equiv_unify {n : \u2115} (F : L.Functions n) (x : Fin n \u2192 \u03a3\u02e3 f) (i : \u03b9)\n    (hi : i \u2208 upperBounds (range (Sigma.fst \u2218 x))) :\n    funMap F x \u2248 .mk f _ (funMap F (unify f x i hi)) :=\n  funMap_unify_equiv G f F x (Classical.choose (Fintype.bddAbove_range fun a => (x a).1)) i _ hi\n#align first_order.language.direct_limit.fun_map_equiv_unify FirstOrder.Language.DirectLimit.funMap_equiv_unify\n\ntheorem relMap_equiv_unify {n : \u2115} (R : L.Relations n) (x : Fin n \u2192 \u03a3\u02e3 f) (i : \u03b9)\n    (hi : i \u2208 upperBounds (range (Sigma.fst \u2218 x))) :\n    RelMap R x = RelMap R (unify f x i hi) :=\n  relMap_unify_equiv G f R x (Classical.choose (Fintype.bddAbove_range fun a => (x a).1)) i _ hi\n#align first_order.language.direct_limit.rel_map_equiv_unify FirstOrder.Language.DirectLimit.relMap_equiv_unify\n\n/-- The direct limit `setoid` respects the structure `sigmaStructure`, so quotienting by it\n  gives rise to a valid structure. -/\nnoncomputable instance prestructure : L.Prestructure (DirectLimit.setoid G f) where\n  toStructure := sigmaStructure G f\n  fun_equiv {n} {F} x y xy := by\n    obtain \u27e8i, hx, hy, h\u27e9 := exists_unify_eq G f xy\n    refine'\n      Setoid.trans (funMap_equiv_unify G f F x i hx)\n        (Setoid.trans _ (Setoid.symm (funMap_equiv_unify G f F y i hy)))\n    rw [h]\n  rel_equiv {n} {R} x y xy := by\n    obtain \u27e8i, hx, hy, h\u27e9 := exists_unify_eq G f xy\n    refine' _root_.trans (relMap_equiv_unify G f R x i hx)\n      (_root_.trans _ (symm (relMap_equiv_unify G f R y i hy)))\n    rw [h]\n#align first_order.language.direct_limit.prestructure FirstOrder.Language.DirectLimit.prestructure\n\n/-- The `L.Structure` on a direct limit of `L.Structure`s. -/\nnoncomputable instance instStructureDirectLimit : L.Structure (DirectLimit G f) :=\n  Language.quotientStructure\nset_option linter.uppercaseLean3 false in\n#align first_order.language.direct_limit.Structure FirstOrder.Language.DirectLimit.instStructureDirectLimit\n\n@[simp]\ntheorem funMap_quotient_mk'_sigma_mk' {n : \u2115} {F : L.Functions n} {i : \u03b9} {x : Fin n \u2192 G i} :\n    funMap F (fun a => (\u27e6.mk f i (x a)\u27e7 : DirectLimit G f)) = \u27e6.mk f i (funMap F x)\u27e7 := by\n  simp [Function.comp_apply, funMap_quotient_mk', Quotient.eq']\n  obtain \u27e8k, ik, jk\u27e9 :=\n    directed_of (\u00b7 \u2264 \u00b7) i (Classical.choose (Fintype.bddAbove_range fun _ : Fin n => i))\n  refine' \u27e8k, jk, ik, _\u27e9\n  simp only [Embedding.map_fun, comp_unify]\n  rfl\n#align first_order.language.direct_limit.fun_map_quotient_mk_sigma_mk FirstOrder.Language.DirectLimit.funMap_quotient_mk'_sigma_mk'\n\n@[simp]\ntheorem relMap_quotient_mk'_sigma_mk' {n : \u2115} {R : L.Relations n} {i : \u03b9} {x : Fin n \u2192 G i} :\n    RelMap R (fun a => (\u27e6.mk f i (x a)\u27e7 : DirectLimit G f)) = RelMap R x := by\n  rw [relMap_quotient_mk']\n  obtain \u27e8k, _, _\u27e9 :=\n    directed_of (\u00b7 \u2264 \u00b7) i (Classical.choose (Fintype.bddAbove_range fun _ : Fin n => i))\n  rw [relMap_equiv_unify G f R (fun a => .mk f i (x a)) i]\n  rw [unify_sigma_mk_self]\n#align first_order.language.direct_limit.rel_map_quotient_mk_sigma_mk FirstOrder.Language.DirectLimit.relMap_quotient_mk'_sigma_mk'\n\ntheorem exists_quotient_mk'_sigma_mk'_eq {\u03b1 : Type*} [Fintype \u03b1] (x : \u03b1 \u2192 DirectLimit G f) :\n    \u2203 (i : \u03b9) (y : \u03b1 \u2192 G i), x = fun a => \u27e6.mk f i (y a)\u27e7 := by\n  obtain \u27e8i, hi\u27e9 := Fintype.bddAbove_range fun a => (x a).out.1\n  refine' \u27e8i, unify f (Quotient.out \u2218 x) i hi, _\u27e9\n  ext a\n  rw [Quotient.eq_mk_iff_out, unify]\n  generalize_proofs r\n  change _ \u2248 .mk f i (f (Quotient.out (x a)).fst i r (Quotient.out (x a)).snd)\n  have : (.mk f i (f (Quotient.out (x a)).fst i r (Quotient.out (x a)).snd) : \u03a3\u02e3 f).fst \u2264 i :=\n    le_rfl\n  rw [equiv_iff G f (i := i) (hi _) this]\n  \u00b7 simp only [DirectedSystem.map_self]\n  exact \u27e8a, rfl\u27e9\n#align first_order.language.direct_limit.exists_quotient_mk_sigma_mk_eq FirstOrder.Language.DirectLimit.exists_quotient_mk'_sigma_mk'_eq\n\nvariable (L \u03b9)\n\n/-- The canonical map from a component to the direct limit. -/\ndef of (i : \u03b9) : G i \u21aa[L] DirectLimit G f where\n  toFun := fun a => \u27e6.mk f i a\u27e7\n  inj' x y h := by\n    rw [Quotient.eq] at h\n    obtain \u27e8j, h1, _, h3\u27e9 := h\n    exact (f i j h1).injective h3\n  map_fun' F x := by\n    simp\n    rw [\u2190 funMap_quotient_mk'_sigma_mk']\n    rfl\n  map_rel' := by\n    intro n R x\n    change RelMap R (fun a => (\u27e6.mk f i (x a)\u27e7 : DirectLimit G f)) \u2194 _\n    simp only [relMap_quotient_mk'_sigma_mk']\n\n\n#align first_order.language.direct_limit.of FirstOrder.Language.DirectLimit.of\n\nvariable {L \u03b9 G f}\n\n@[simp]\ntheorem of_apply {i : \u03b9} {x : G i} : of L \u03b9 G f i x = \u27e6.mk f i x\u27e7 :=\n  rfl\n#align first_order.language.direct_limit.of_apply FirstOrder.Language.DirectLimit.of_apply\n\n-- Porting note: removed the `@[simp]`, it is not in simp-normal form, but the simp-normal version\n-- of this theorem would not be useful.\ntheorem of_f {i j : \u03b9} {hij : i \u2264 j} {x : G i} : of L \u03b9 G f j (f i j hij x) = of L \u03b9 G f i x := by\n  rw [of_apply, of_apply, Quotient.eq]\n  refine' Setoid.symm \u27e8j, hij, refl j, _\u27e9\n  simp only [DirectedSystem.map_self]\n#align first_order.language.direct_limit.of_f FirstOrder.Language.DirectLimit.of_f\n\n/-- Every element of the direct limit corresponds to some element in\nsome component of the directed system. -/\ntheorem exists_of (z : DirectLimit G f) : \u2203 i x, of L \u03b9 G f i x = z :=\n  \u27e8z.out.1, z.out.2, by simp\u27e9\n#align first_order.language.direct_limit.exists_of FirstOrder.Language.DirectLimit.exists_of\n\n@[elab_as_elim]\nprotected theorem inductionOn {C : DirectLimit G f \u2192 Prop} (z : DirectLimit G f)\n    (ih : \u2200 i x, C (of L \u03b9 G f i x)) : C z :=\n  let \u27e8i, x, h\u27e9 := exists_of z\n  h \u25b8 ih i x\n#align first_order.language.direct_limit.induction_on FirstOrder.Language.DirectLimit.inductionOn\n\nvariable {P : Type u\u2081} [L.Structure P] (g : \u2200 i, G i \u21aa[L] P)\n\nvariable (Hg : \u2200 i j hij x, g j (f i j hij x) = g i x)\n\nvariable (L \u03b9 G f)\n\n/-- The universal property of the direct limit: maps from the components to another module\nthat respect the directed system structure (i.e. make some diagram commute) give rise\nto a unique map out of the direct limit. -/\ndef lift : DirectLimit G f \u21aa[L] P where\n  toFun :=\n    Quotient.lift (fun x : \u03a3\u02e3 f => (g x.1) x.2) fun x y xy => by\n      simp\n      obtain \u27e8i, hx, hy\u27e9 := directed_of (\u00b7 \u2264 \u00b7) x.1 y.1\n      rw [\u2190 Hg x.1 i hx, \u2190 Hg y.1 i hy]\n      exact congr_arg _ ((equiv_iff ..).1 xy)\n  inj' x y xy := by\n    rw [\u2190 Quotient.out_eq x, \u2190 Quotient.out_eq y, Quotient.lift_mk, Quotient.lift_mk] at xy\n    obtain \u27e8i, hx, hy\u27e9 := directed_of (\u00b7 \u2264 \u00b7) x.out.1 y.out.1\n    rw [\u2190 Hg x.out.1 i hx, \u2190 Hg y.out.1 i hy] at xy\n    rw [\u2190 Quotient.out_eq x, \u2190 Quotient.out_eq y, Quotient.eq, equiv_iff G f hx hy]\n    exact (g i).injective xy\n  map_fun' F x := by\n    obtain \u27e8i, y, rfl\u27e9 := exists_quotient_mk'_sigma_mk'_eq G f x\n    change _ = funMap F (Quotient.lift _ _ \u2218 Quotient.mk _ \u2218 Structure.Sigma.mk f i \u2218 y)\n    rw [funMap_quotient_mk'_sigma_mk', \u2190 Function.comp.assoc, Quotient.lift_comp_mk]\n    simp only [Quotient.lift_mk, Embedding.map_fun]\n    rfl\n  map_rel' R x := by\n    obtain \u27e8i, y, rfl\u27e9 := exists_quotient_mk'_sigma_mk'_eq G f x\n    change RelMap R (Quotient.lift _ _ \u2218 Quotient.mk _ \u2218 Structure.Sigma.mk f i \u2218 y) \u2194 _\n    rw [relMap_quotient_mk'_sigma_mk' G f, \u2190 (g i).map_rel R y, \u2190 Function.comp.assoc,\n      Quotient.lift_comp_mk]\n    rfl\n#align first_order.language.direct_limit.lift FirstOrder.Language.DirectLimit.lift\n\nvariable {L \u03b9 G f}\n\n@[simp]\ntheorem lift_quotient_mk'_sigma_mk' {i} (x : G i) : lift L \u03b9 G f g Hg \u27e6.mk f i x\u27e7 = (g i) x := by\n  change (lift L \u03b9 G f g Hg).toFun \u27e6.mk f i x\u27e7 = _\n  simp only [lift, Quotient.lift_mk]\n#align first_order.language.direct_limit.lift_quotient_mk_sigma_mk FirstOrder.Language.DirectLimit.lift_quotient_mk'_sigma_mk'\n\ntheorem lift_of {i} (x : G i) : lift L \u03b9 G f g Hg (of L \u03b9 G f i x) = g i x := by simp\n#align first_order.language.direct_limit.lift_of FirstOrder.Language.DirectLimit.lift_of\n\ntheorem lift_unique (F : DirectLimit G f \u21aa[L] P) (x) :\n    F x =\n      lift L \u03b9 G f (fun i => F.comp <| of L \u03b9 G f i)\n        (fun i j hij x => by rw [F.comp_apply, F.comp_apply, of_f]) x :=\n  DirectLimit.inductionOn x fun i x => by rw [lift_of]; rfl\n#align first_order.language.direct_limit.lift_unique FirstOrder.Language.DirectLimit.lift_unique\n\n/-- The direct limit of countably many countably generated structures is countably generated. -/\ntheorem cg {\u03b9 : Type*} [Encodable \u03b9] [Preorder \u03b9] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] [Nonempty \u03b9]\n    {G : \u03b9 \u2192 Type w} [\u2200 i, L.Structure (G i)] (f : \u2200 i j, i \u2264 j \u2192 G i \u21aa[L] G j)\n    (h : \u2200 i, Structure.CG L (G i)) [DirectedSystem G fun i j h => f i j h] :\n    Structure.CG L (DirectLimit G f) := by\n  refine' \u27e8\u27e8\u22c3 i, DirectLimit.of L \u03b9 G f i '' Classical.choose (h i).out, _, _\u27e9\u27e9\n  \u00b7 exact Set.countable_iUnion fun i => Set.Countable.image (Classical.choose_spec (h i).out).1 _\n  \u00b7 rw [eq_top_iff, Substructure.closure_union\u1d62]\n    simp_rw [\u2190 Embedding.coe_toHom, Substructure.closure_image]\n    rw [le_iSup_iff]\n    intro S hS x _\n    let out := Quotient.out (s := DirectLimit.setoid G f)\n    refine' hS (out x).1 \u27e8(out x).2, _, _\u27e9\n    \u00b7 rw [(Classical.choose_spec (h (out x).1).out).2]\n      trivial\n    \u00b7 simp only [Embedding.coe_toHom, DirectLimit.of_apply, Sigma.eta, Quotient.out_eq]\n#align first_order.language.direct_limit.cg FirstOrder.Language.DirectLimit.cg\n\ninstance cg' {\u03b9 : Type*} [Encodable \u03b9] [Preorder \u03b9] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] [Nonempty \u03b9]\n    {G : \u03b9 \u2192 Type w} [\u2200 i, L.Structure (G i)] (f : \u2200 i j, i \u2264 j \u2192 G i \u21aa[L] G j)\n    [h : \u2200 i, Structure.CG L (G i)] [DirectedSystem G fun i j h => f i j h] :\n    Structure.CG L (DirectLimit G f) :=\n  cg f h\n#align first_order.language.direct_limit.cg' FirstOrder.Language.DirectLimit.cg'\n\nend DirectLimit\n\nend Language\n\nend FirstOrder\n"}, {"text": "/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n/-- `List.countP` as a bundled additive monoid homomorphism. -/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n/-- `List.count` as a bundled additive monoid homomorphism. -/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n/-- `List.countP` as a bundled multiplicative monoid homomorphism. -/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n/-- `List.count` as a bundled additive monoid homomorphism. -/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMonoid.count_of\n\nend FreeMonoid\n"}, {"text": "/-\nCopyright (c) 2022 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Adam Topaz, Junyan Xu, Jack McKoen\n-/\nimport Mathlib.RingTheory.Valuation.ValuationRing\nimport Mathlib.RingTheory.Localization.AsSubring\nimport Mathlib.RingTheory.Subring.Pointwise\nimport Mathlib.AlgebraicGeometry.PrimeSpectrum.Basic\n\n#align_import ring_theory.valuation.valuation_subring from \"leanprover-community/mathlib\"@\"2196ab363eb097c008d4497125e0dde23fb36db2\"\n\n/-!\n\n# Valuation subrings of a field\n\n## Projects\n\nThe order structure on `ValuationSubring K`.\n\n-/\n\n\nuniverse u\n\nopen scoped Classical\n\nnoncomputable section\n\nvariable (K : Type u) [Field K]\n\n/-- A valuation subring of a field `K` is a subring `A` such that for every `x : K`,\neither `x \u2208 A` or `x\u207b\u00b9 \u2208 A`. -/\nstructure ValuationSubring extends Subring K where\n  mem_or_inv_mem' : \u2200 x : K, x \u2208 carrier \u2228 x\u207b\u00b9 \u2208 carrier\n#align valuation_subring ValuationSubring\n\nnamespace ValuationSubring\n\nvariable {K}\nvariable (A : ValuationSubring K)\n\ninstance : SetLike (ValuationSubring K) K where\n  coe A := A.toSubring\n  coe_injective' := by\n    intro \u27e8_, _\u27e9 \u27e8_, _\u27e9 h\n    replace h := SetLike.coe_injective' h\n    congr\n\n@[simp, nolint simpNF] -- Porting note: simp cannot prove that\ntheorem mem_carrier (x : K) : x \u2208 A.carrier \u2194 x \u2208 A := Iff.refl _\n#align valuation_subring.mem_carrier ValuationSubring.mem_carrier\n\n@[simp]\ntheorem mem_toSubring (x : K) : x \u2208 A.toSubring \u2194 x \u2208 A := Iff.refl _\n#align valuation_subring.mem_to_subring ValuationSubring.mem_toSubring\n\n@[ext]\ntheorem ext (A B : ValuationSubring K) (h : \u2200 x, x \u2208 A \u2194 x \u2208 B) : A = B := SetLike.ext h\n#align valuation_subring.ext ValuationSubring.ext\n\ntheorem zero_mem : (0 : K) \u2208 A := A.toSubring.zero_mem\n#align valuation_subring.zero_mem ValuationSubring.zero_mem\n\ntheorem one_mem : (1 : K) \u2208 A := A.toSubring.one_mem\n#align valuation_subring.one_mem ValuationSubring.one_mem\n\ntheorem add_mem (x y : K) : x \u2208 A \u2192 y \u2208 A \u2192 x + y \u2208 A := A.toSubring.add_mem\n#align valuation_subring.add_mem ValuationSubring.add_mem\n\ntheorem mul_mem (x y : K) : x \u2208 A \u2192 y \u2208 A \u2192 x * y \u2208 A := A.toSubring.mul_mem\n#align valuation_subring.mul_mem ValuationSubring.mul_mem\n\ntheorem neg_mem (x : K) : x \u2208 A \u2192 -x \u2208 A := A.toSubring.neg_mem\n#align valuation_subring.neg_mem ValuationSubring.neg_mem\n\ntheorem mem_or_inv_mem (x : K) : x \u2208 A \u2228 x\u207b\u00b9 \u2208 A := A.mem_or_inv_mem' _\n#align valuation_subring.mem_or_inv_mem ValuationSubring.mem_or_inv_mem\n\ninstance : SubringClass (ValuationSubring K) K where\n  zero_mem := zero_mem\n  add_mem {_} a b := add_mem _ a b\n  one_mem := one_mem\n  mul_mem {_} a b := mul_mem _ a b\n  neg_mem {_} x := neg_mem _ x\n\ntheorem toSubring_injective : Function.Injective (toSubring : ValuationSubring K \u2192 Subring K) :=\n  fun x y h => by cases x; cases y; congr\n#align valuation_subring.to_subring_injective ValuationSubring.toSubring_injective\n\ninstance : CommRing A :=\n  show CommRing A.toSubring by infer_instance\n\ninstance : IsDomain A :=\n  show IsDomain A.toSubring by infer_instance\n\ninstance : Top (ValuationSubring K) :=\n  Top.mk <| { (\u22a4 : Subring K) with mem_or_inv_mem' := fun _ => Or.inl trivial }\n\ntheorem mem_top (x : K) : x \u2208 (\u22a4 : ValuationSubring K) :=\n  trivial\n#align valuation_subring.mem_top ValuationSubring.mem_top\n\ntheorem le_top : A \u2264 \u22a4 := fun _a _ha => mem_top _\n#align valuation_subring.le_top ValuationSubring.le_top\n\ninstance : OrderTop (ValuationSubring K) where\n  top := \u22a4\n  le_top := le_top\n\ninstance : Inhabited (ValuationSubring K) :=\n  \u27e8\u22a4\u27e9\n\ninstance : ValuationRing A where\n  cond' a b := by\n    by_cases (b : K) = 0\n    \u00b7 use 0\n      left\n      ext\n      simp [h]\n    by_cases (a : K) = 0\n    \u00b7 use 0; right\n      ext\n      simp [h]\n    cases' A.mem_or_inv_mem (a / b) with hh hh\n    \u00b7 use \u27e8a / b, hh\u27e9\n      right\n      ext\n      field_simp\n      ring\n    \u00b7 rw [show (a / b : K)\u207b\u00b9 = b / a by field_simp] at hh\n      use \u27e8b / a, hh\u27e9;\n      left\n      ext\n      field_simp\n      ring\n\ninstance : Algebra A K :=\n  show Algebra A.toSubring K by infer_instance\n\n-- Porting note: Somehow it cannot find this instance and I'm too lazy to debug. wrong prio?\ninstance localRing : LocalRing A := ValuationRing.localRing A\n\n@[simp]\ntheorem algebraMap_apply (a : A) : algebraMap A K a = a := rfl\n#align valuation_subring.algebra_map_apply ValuationSubring.algebraMap_apply\n\ninstance : IsFractionRing A K where\n  map_units' := fun \u27e8y, hy\u27e9 =>\n    (Units.mk0 (y : K) fun c => nonZeroDivisors.ne_zero hy <| Subtype.ext c).isUnit\n  surj' z := by\n    by_cases z = 0; \u00b7 use (0, 1); simp [h]\n    cases' A.mem_or_inv_mem z with hh hh\n    \u00b7 use (\u27e8z, hh\u27e9, 1); simp\n    \u00b7 refine \u27e8\u27e81, \u27e8\u27e8_, hh\u27e9, ?_\u27e9\u27e9, mul_inv_cancel h\u27e9\n      exact mem_nonZeroDivisors_iff_ne_zero.2 fun c => h (inv_eq_zero.mp (congr_arg Subtype.val c))\n  eq_iff_exists' {a b} :=\n    \u27e8fun h => \u27e81, by ext; simpa using h\u27e9, fun \u27e8c, h\u27e9 =>\n      congr_arg Subtype.val ((mul_eq_mul_left_iff.1 h).resolve_right (nonZeroDivisors.ne_zero c.2))\u27e9\n\n/-- The value group of the valuation associated to `A`. Note: it is actually a group with zero. -/\ndef ValueGroup :=\n  ValuationRing.ValueGroup A K\n-- deriving LinearOrderedCommGroupWithZero\n#align valuation_subring.value_group ValuationSubring.ValueGroup\n\n-- Porting note: see https://github.com/leanprover-community/mathlib4/issues/5020\ninstance : LinearOrderedCommGroupWithZero (ValueGroup A) := by\n  unfold ValueGroup\n  infer_instance\n\n/-- Any valuation subring of `K` induces a natural valuation on `K`. -/\ndef valuation : Valuation K A.ValueGroup :=\n  ValuationRing.valuation A K\n#align valuation_subring.valuation ValuationSubring.valuation\n\ninstance inhabitedValueGroup : Inhabited A.ValueGroup := \u27e8A.valuation 0\u27e9\n#align valuation_subring.inhabited_value_group ValuationSubring.inhabitedValueGroup\n\ntheorem valuation_le_one (a : A) : A.valuation a \u2264 1 :=\n  (ValuationRing.mem_integer_iff A K _).2 \u27e8a, rfl\u27e9\n#align valuation_subring.valuation_le_one ValuationSubring.valuation_le_one\n\ntheorem mem_of_valuation_le_one (x : K) (h : A.valuation x \u2264 1) : x \u2208 A :=\n  let \u27e8a, ha\u27e9 := (ValuationRing.mem_integer_iff A K x).1 h\n  ha \u25b8 a.2\n#align valuation_subring.mem_of_valuation_le_one ValuationSubring.mem_of_valuation_le_one\n\ntheorem valuation_le_one_iff (x : K) : A.valuation x \u2264 1 \u2194 x \u2208 A :=\n  \u27e8mem_of_valuation_le_one _ _, fun ha => A.valuation_le_one \u27e8x, ha\u27e9\u27e9\n#align valuation_subring.valuation_le_one_iff ValuationSubring.valuation_le_one_iff\n\ntheorem valuation_eq_iff (x y : K) : A.valuation x = A.valuation y \u2194 \u2203 a : A\u02e3, (a : K) * y = x :=\n  Quotient.eq''\n#align valuation_subring.valuation_eq_iff ValuationSubring.valuation_eq_iff\n\ntheorem valuation_le_iff (x y : K) : A.valuation x \u2264 A.valuation y \u2194 \u2203 a : A, (a : K) * y = x :=\n  Iff.rfl\n#align valuation_subring.valuation_le_iff ValuationSubring.valuation_le_iff\n\ntheorem valuation_surjective : Function.Surjective A.valuation := surjective_quot_mk _\n#align valuation_subring.valuation_surjective ValuationSubring.valuation_surjective\n\ntheorem valuation_unit (a : A\u02e3) : A.valuation a = 1 := by\n  rw [\u2190 A.valuation.map_one, valuation_eq_iff]; use a; simp\n#align valuation_subring.valuation_unit ValuationSubring.valuation_unit\n\ntheorem valuation_eq_one_iff (a : A) : IsUnit a \u2194 A.valuation a = 1 :=\n  \u27e8fun h => A.valuation_unit h.unit, fun h => by\n    have ha : (a : K) \u2260 0\n    \u00b7 intro c\n      rw [c, A.valuation.map_zero] at h\n      exact zero_ne_one h\n    have ha' : (a : K)\u207b\u00b9 \u2208 A := by rw [\u2190 valuation_le_one_iff, map_inv\u2080, h, inv_one]\n    apply isUnit_of_mul_eq_one a \u27e8a\u207b\u00b9, ha'\u27e9; ext; field_simp\u27e9\n#align valuation_subring.valuation_eq_one_iff ValuationSubring.valuation_eq_one_iff\n\ntheorem valuation_lt_one_or_eq_one (a : A) : A.valuation a < 1 \u2228 A.valuation a = 1 :=\n  lt_or_eq_of_le (A.valuation_le_one a)\n#align valuation_subring.valuation_lt_one_or_eq_one ValuationSubring.valuation_lt_one_or_eq_one\n\ntheorem valuation_lt_one_iff (a : A) : a \u2208 LocalRing.maximalIdeal A \u2194 A.valuation a < 1 := by\n  rw [LocalRing.mem_maximalIdeal]\n  dsimp [nonunits]; rw [valuation_eq_one_iff]\n  exact (A.valuation_le_one a).lt_iff_ne.symm\n#align valuation_subring.valuation_lt_one_iff ValuationSubring.valuation_lt_one_iff\n\n/-- A subring `R` of `K` such that for all `x : K` either `x \u2208 R` or `x\u207b\u00b9 \u2208 R` is\n  a valuation subring of `K`. -/\ndef ofSubring (R : Subring K) (hR : \u2200 x : K, x \u2208 R \u2228 x\u207b\u00b9 \u2208 R) : ValuationSubring K :=\n  { R with mem_or_inv_mem' := hR }\n#align valuation_subring.of_subring ValuationSubring.ofSubring\n\n@[simp]\ntheorem mem_ofSubring (R : Subring K) (hR : \u2200 x : K, x \u2208 R \u2228 x\u207b\u00b9 \u2208 R) (x : K) :\n    x \u2208 ofSubring R hR \u2194 x \u2208 R :=\n  Iff.refl _\n#align valuation_subring.mem_of_subring ValuationSubring.mem_ofSubring\n\n/-- An overring of a valuation ring is a valuation ring. -/\ndef ofLE (R : ValuationSubring K) (S : Subring K) (h : R.toSubring \u2264 S) : ValuationSubring K :=\n  { S with mem_or_inv_mem' := fun x => (R.mem_or_inv_mem x).imp (@h x) (@h _) }\n#align valuation_subring.of_le ValuationSubring.ofLE\n\nsection Order\n\ninstance : SemilatticeSup (ValuationSubring K) :=\n  { (inferInstance : PartialOrder (ValuationSubring K)) with\n    sup := fun R S => ofLE R (R.toSubring \u2294 S.toSubring) <| le_sup_left\n    le_sup_left := fun R S _ hx => (le_sup_left : R.toSubring \u2264 R.toSubring \u2294 S.toSubring) hx\n    le_sup_right := fun R S _ hx => (le_sup_right : S.toSubring \u2264 R.toSubring \u2294 S.toSubring) hx\n    sup_le := fun R S T hR hT _ hx => (sup_le hR hT : R.toSubring \u2294 S.toSubring \u2264 T.toSubring) hx }\n\n/-- The ring homomorphism induced by the partial order. -/\ndef inclusion (R S : ValuationSubring K) (h : R \u2264 S) : R \u2192+* S :=\n  Subring.inclusion h\n#align valuation_subring.inclusion ValuationSubring.inclusion\n\n/-- The canonical ring homomorphism from a valuation ring to its field of fractions. -/\ndef subtype (R : ValuationSubring K) : R \u2192+* K :=\n  Subring.subtype R.toSubring\n#align valuation_subring.subtype ValuationSubring.subtype\n\n/-- The canonical map on value groups induced by a coarsening of valuation rings. -/\ndef mapOfLE (R S : ValuationSubring K) (h : R \u2264 S) : R.ValueGroup \u2192*\u2080 S.ValueGroup where\n  toFun := Quotient.map' id fun x y \u27e8u, hu\u27e9 => \u27e8Units.map (R.inclusion S h).toMonoidHom u, hu\u27e9\n  map_zero' := rfl\n  map_one' := rfl\n  map_mul' := by rintro \u27e8\u27e9 \u27e8\u27e9; rfl\n#align valuation_subring.map_of_le ValuationSubring.mapOfLE\n\n@[mono]\ntheorem monotone_mapOfLE (R S : ValuationSubring K) (h : R \u2264 S) : Monotone (R.mapOfLE S h) := by\n  rintro \u27e8\u27e9 \u27e8\u27e9 \u27e8a, ha\u27e9; exact \u27e8R.inclusion S h a, ha\u27e9\n#align valuation_subring.monotone_map_of_le ValuationSubring.monotone_mapOfLE\n\n@[simp]\ntheorem mapOfLE_comp_valuation (R S : ValuationSubring K) (h : R \u2264 S) :\n    R.mapOfLE S h \u2218 R.valuation = S.valuation := by ext; rfl\n#align valuation_subring.map_of_le_comp_valuation ValuationSubring.mapOfLE_comp_valuation\n\n@[simp]\ntheorem mapOfLE_valuation_apply (R S : ValuationSubring K) (h : R \u2264 S) (x : K) :\n    R.mapOfLE S h (R.valuation x) = S.valuation x := rfl\n#align valuation_subring.map_of_le_valuation_apply ValuationSubring.mapOfLE_valuation_apply\n\n/-- The ideal corresponding to a coarsening of a valuation ring. -/\ndef idealOfLE (R S : ValuationSubring K) (h : R \u2264 S) : Ideal R :=\n  (LocalRing.maximalIdeal S).comap (R.inclusion S h)\n#align valuation_subring.ideal_of_le ValuationSubring.idealOfLE\n\ninstance prime_idealOfLE (R S : ValuationSubring K) (h : R \u2264 S) : (idealOfLE R S h).IsPrime :=\n  (LocalRing.maximalIdeal S).comap_isPrime _\n#align valuation_subring.prime_ideal_of_le ValuationSubring.prime_idealOfLE\n\n/-- The coarsening of a valuation ring associated to a prime ideal. -/\ndef ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] : ValuationSubring K :=\n  ofLE A (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors).toSubring\n    -- Porting note: added `Subalgebra.mem_toSubring.mpr`\n    fun a ha => Subalgebra.mem_toSubring.mpr <|\n      Subalgebra.algebraMap_mem\n        (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors) (\u27e8a, ha\u27e9 : A)\n#align valuation_subring.of_prime ValuationSubring.ofPrime\n\ninstance ofPrimeAlgebra (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    Algebra A (A.ofPrime P) :=\n  -- Porting note: filled in the argument\n  Subalgebra.algebra (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors)\n#align valuation_subring.of_prime_algebra ValuationSubring.ofPrimeAlgebra\n\ninstance ofPrime_scalar_tower (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    -- Porting note: added instance\n    letI : SMul A (A.ofPrime P) := SMulZeroClass.toSMul\n    IsScalarTower A (A.ofPrime P) K :=\n  IsScalarTower.subalgebra' A K K\n    -- Porting note: filled in the argument\n    (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors)\n#align valuation_subring.of_prime_scalar_tower ValuationSubring.ofPrime_scalar_tower\n\ninstance ofPrime_localization (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    IsLocalization.AtPrime (A.ofPrime P) P := by\n  apply\n    Localization.subalgebra.isLocalization_ofField K P.primeCompl\n      P.primeCompl_le_nonZeroDivisors\n#align valuation_subring.of_prime_localization ValuationSubring.ofPrime_localization\n\ntheorem le_ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] : A \u2264 ofPrime A P :=\n  -- Porting note: added `Subalgebra.mem_toSubring.mpr`\n  fun a ha => Subalgebra.mem_toSubring.mpr <| Subalgebra.algebraMap_mem _ (\u27e8a, ha\u27e9 : A)\n#align valuation_subring.le_of_prime ValuationSubring.le_ofPrime\n\ntheorem ofPrime_valuation_eq_one_iff_mem_primeCompl (A : ValuationSubring K) (P : Ideal A)\n    [P.IsPrime] (x : A) : (ofPrime A P).valuation x = 1 \u2194 x \u2208 P.primeCompl := by\n  rw [\u2190 IsLocalization.AtPrime.isUnit_to_map_iff (A.ofPrime P) P x, valuation_eq_one_iff]; rfl\n#align valuation_subring.of_prime_valuation_eq_one_iff_mem_prime_compl ValuationSubring.ofPrime_valuation_eq_one_iff_mem_primeCompl\n\n@[simp]\ntheorem idealOfLE_ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    idealOfLE A (ofPrime A P) (le_ofPrime A P) = P := by\n  refine Ideal.ext (fun x => ?_)\n  apply IsLocalization.AtPrime.to_map_mem_maximal_iff\n  exact localRing (ofPrime A P)\n#align valuation_subring.ideal_of_le_of_prime ValuationSubring.idealOfLE_ofPrime\n\n@[simp]\ntheorem ofPrime_idealOfLE (R S : ValuationSubring K) (h : R \u2264 S) :\n    ofPrime R (idealOfLE R S h) = S := by\n  ext x; constructor\n  \u00b7 rintro \u27e8a, r, hr, rfl\u27e9; apply mul_mem; \u00b7 exact h a.2\n    \u00b7 rw [\u2190 valuation_le_one_iff, map_inv\u2080, \u2190 inv_one, inv_le_inv\u2080]\n      \u00b7 exact not_lt.1 ((not_iff_not.2 <| valuation_lt_one_iff S _).1 hr)\n      \u00b7 intro hh; erw [Valuation.zero_iff, Subring.coe_eq_zero_iff] at hh\n        apply hr; rw [hh]; apply Ideal.zero_mem (R.idealOfLE S h)\n      \u00b7 exact one_ne_zero\n  \u00b7 intro hx; by_cases hr : x \u2208 R; \u00b7 exact R.le_ofPrime _ hr\n    have : x \u2260 0 := fun h => hr (by rw [h]; exact R.zero_mem)\n    replace hr := (R.mem_or_inv_mem x).resolve_left hr\n    \u00b7 -- Porting note: added `\u27e8\u27e9` brackets and reordered goals\n      use 1, \u27e8x\u207b\u00b9, hr\u27e9; constructor\n      \u00b7 field_simp\n      \u00b7 change (\u27e8x\u207b\u00b9, h hr\u27e9 : S) \u2209 nonunits S\n        rw [mem_nonunits_iff, Classical.not_not]\n        apply isUnit_of_mul_eq_one _ (\u27e8x, hx\u27e9 : S)\n        ext; field_simp\n#align valuation_subring.of_prime_ideal_of_le ValuationSubring.ofPrime_idealOfLE\n\ntheorem ofPrime_le_of_le (P Q : Ideal A) [P.IsPrime] [Q.IsPrime] (h : P \u2264 Q) :\n    ofPrime A Q \u2264 ofPrime A P := fun _x \u27e8a, s, hs, he\u27e9 => \u27e8a, s, fun c => hs (h c), he\u27e9\n#align valuation_subring.of_prime_le_of_le ValuationSubring.ofPrime_le_of_le\n\ntheorem idealOfLE_le_of_le (R S : ValuationSubring K) (hR : A \u2264 R) (hS : A \u2264 S) (h : R \u2264 S) :\n    idealOfLE A S hS \u2264 idealOfLE A R hR := fun x hx =>\n  (valuation_lt_one_iff R _).2\n    (by\n      by_contra c; push_neg at c; replace c := monotone_mapOfLE R S h c\n      rw [(mapOfLE _ _ _).map_one, mapOfLE_valuation_apply] at c\n      apply not_le_of_lt ((valuation_lt_one_iff S _).1 hx) c)\n#align valuation_subring.ideal_of_le_le_of_le ValuationSubring.idealOfLE_le_of_le\n\n/-- The equivalence between coarsenings of a valuation ring and its prime ideals.-/\n@[simps]\ndef primeSpectrumEquiv : PrimeSpectrum A \u2243 {S | A \u2264 S} where\n  toFun P := \u27e8ofPrime A P.asIdeal, le_ofPrime _ _\u27e9\n  invFun S := \u27e8idealOfLE _ S S.2, inferInstance\u27e9\n  left_inv P := by ext1; simp\n  right_inv S := by ext1; simp\n#align valuation_subring.prime_spectrum_equiv ValuationSubring.primeSpectrumEquiv\n\n/-- An ordered variant of `primeSpectrumEquiv`. -/\n@[simps]\ndef primeSpectrumOrderEquiv : (PrimeSpectrum A)\u1d52\u1d48 \u2243o {S | A \u2264 S} :=\n  { primeSpectrumEquiv A with\n    map_rel_iff' :=\n      \u27e8fun h => by\n        dsimp at h\n        have := idealOfLE_le_of_le A _ _ ?_ ?_ h\n        iterate 2 erw [idealOfLE_ofPrime] at this\n        exact this\n        all_goals exact le_ofPrime A (PrimeSpectrum.asIdeal _),\n      fun h => by apply ofPrime_le_of_le; exact h\u27e9 }\n#align valuation_subring.prime_spectrum_order_equiv ValuationSubring.primeSpectrumOrderEquiv\n\ninstance linearOrderOverring : LinearOrder {S | A \u2264 S} :=\n  { (inferInstance : PartialOrder _) with\n    le_total :=\n      let i : IsTotal (PrimeSpectrum A) (\u00b7 \u2264 \u00b7) := \u27e8fun \u27e8x, _\u27e9 \u27e8y, _\u27e9 => LE.isTotal.total x y\u27e9\n      (primeSpectrumOrderEquiv A).symm.toRelEmbedding.isTotal.total\n    decidableLE := inferInstance }\n#align valuation_subring.linear_order_overring ValuationSubring.linearOrderOverring\n\nend Order\n\nend ValuationSubring\n\nnamespace Valuation\n\nvariable {K}\nvariable {\u0393 \u0393\u2081 \u0393\u2082 : Type*} [LinearOrderedCommGroupWithZero \u0393]\n  [LinearOrderedCommGroupWithZero \u0393\u2081] [LinearOrderedCommGroupWithZero \u0393\u2082] (v : Valuation K \u0393)\n  (v\u2081 : Valuation K \u0393\u2081) (v\u2082 : Valuation K \u0393\u2082)\n\n/-- The valuation subring associated to a valuation. -/\ndef valuationSubring : ValuationSubring K :=\n  { v.integer with\n    mem_or_inv_mem' := by\n      intro x\n      cases' le_or_lt (v x) 1 with h h\n      \u00b7 left; exact h\n      \u00b7 right; change v x\u207b\u00b9 \u2264 1\n        rw [map_inv\u2080 v, \u2190 inv_one, inv_le_inv\u2080]\n        \u00b7 exact le_of_lt h\n        \u00b7 intro c; simp [c] at h\n        \u00b7 exact one_ne_zero }\n#align valuation.valuation_subring Valuation.valuationSubring\n\n@[simp]\ntheorem mem_valuationSubring_iff (x : K) : x \u2208 v.valuationSubring \u2194 v x \u2264 1 := Iff.refl _\n#align valuation.mem_valuation_subring_iff Valuation.mem_valuationSubring_iff\n\ntheorem isEquiv_iff_valuationSubring :\n    v\u2081.IsEquiv v\u2082 \u2194 v\u2081.valuationSubring = v\u2082.valuationSubring := by\n  constructor\n  \u00b7 intro h; ext x; specialize h x 1; simpa using h\n  \u00b7 intro h; apply isEquiv_of_val_le_one\n    intro x\n    have : x \u2208 v\u2081.valuationSubring \u2194 x \u2208 v\u2082.valuationSubring := by rw [h]\n    simpa using this\n#align valuation.is_equiv_iff_valuation_subring Valuation.isEquiv_iff_valuationSubring\n\ntheorem isEquiv_valuation_valuationSubring : v.IsEquiv v.valuationSubring.valuation := by\n  rw [isEquiv_iff_val_le_one]\n  intro x\n  rw [ValuationSubring.valuation_le_one_iff]\n  rfl\n#align valuation.is_equiv_valuation_valuation_subring Valuation.isEquiv_valuation_valuationSubring\n\nend Valuation\n\nnamespace ValuationSubring\n\nvariable {K}\nvariable (A : ValuationSubring K)\n\n@[simp]\ntheorem valuationSubring_valuation : A.valuation.valuationSubring = A := by\n  ext; rw [\u2190 A.valuation_le_one_iff]; rfl\n#align valuation_subring.valuation_subring_valuation ValuationSubring.valuationSubring_valuation\n\nsection UnitGroup\n\n/-- The unit group of a valuation subring, as a subgroup of `K\u02e3`. -/\ndef unitGroup : Subgroup K\u02e3 :=\n  (A.valuation.toMonoidWithZeroHom.toMonoidHom.comp (Units.coeHom K)).ker\n#align valuation_subring.unit_group ValuationSubring.unitGroup\n\n@[simp]\ntheorem mem_unitGroup_iff (x : K\u02e3) : x \u2208 A.unitGroup \u2194 A.valuation x = 1 := Iff.rfl\n#align valuation_subring.mem_unit_group_iff ValuationSubring.mem_unitGroup_iff\n\n/-- For a valuation subring `A`, `A.unitGroup` agrees with the units of `A`. -/\ndef unitGroupMulEquiv : A.unitGroup \u2243* A\u02e3 where\n  toFun x :=\n    { val := \u27e8(x : K\u02e3), mem_of_valuation_le_one A _ x.prop.le\u27e9\n      inv := \u27e8((x\u207b\u00b9 : A.unitGroup) : K\u02e3), mem_of_valuation_le_one _ _ x\u207b\u00b9.prop.le\u27e9\n      -- Porting note: was `Units.mul_inv x`\n      val_inv := Subtype.ext (by simp)\n      -- Porting note: was `Units.inv_mul x`\n      inv_val := Subtype.ext (by simp) }\n  invFun x := \u27e8Units.map A.subtype.toMonoidHom x, A.valuation_unit x\u27e9\n  left_inv a := by ext; rfl\n  right_inv a := by ext; rfl\n  map_mul' a b := by ext; rfl\n#align valuation_subring.unit_group_mul_equiv ValuationSubring.unitGroupMulEquiv\n\n@[simp]\ntheorem coe_unitGroupMulEquiv_apply (a : A.unitGroup) :\n    ((A.unitGroupMulEquiv a : A) : K) = ((a : K\u02e3) : K) := rfl\n#align valuation_subring.coe_unit_group_mul_equiv_apply ValuationSubring.coe_unitGroupMulEquiv_apply\n\n@[simp]\ntheorem coe_unitGroupMulEquiv_symm_apply (a : A\u02e3) : ((A.unitGroupMulEquiv.symm a : K\u02e3) : K) = a :=\n  rfl\n#align valuation_subring.coe_unit_group_mul_equiv_symm_apply ValuationSubring.coe_unitGroupMulEquiv_symm_apply\n\ntheorem unitGroup_le_unitGroup {A B : ValuationSubring K} : A.unitGroup \u2264 B.unitGroup \u2194 A \u2264 B := by\n  constructor\n  \u00b7 intro h x hx\n    rw [\u2190 A.valuation_le_one_iff x, le_iff_lt_or_eq] at hx\n    by_cases h_1 : x = 0; \u00b7 simp only [h_1, zero_mem]\n    by_cases h_2 : 1 + x = 0\n    \u00b7 simp only [\u2190 add_eq_zero_iff_neg_eq.1 h_2, neg_mem _ _ (one_mem _)]\n    cases' hx with hx hx\n    \u00b7 have := h (show Units.mk0 _ h_2 \u2208 A.unitGroup from A.valuation.map_one_add_of_lt hx)\n      simpa using\n        B.add_mem _ _ (show 1 + x \u2208 B from SetLike.coe_mem (B.unitGroupMulEquiv \u27e8_, this\u27e9 : B))\n          (B.neg_mem _ B.one_mem)\n    \u00b7 have := h (show Units.mk0 x h_1 \u2208 A.unitGroup from hx)\n      refine' SetLike.coe_mem (B.unitGroupMulEquiv \u27e8_, this\u27e9 : B)\n  \u00b7 rintro h x (hx : A.valuation x = 1)\n    apply_fun A.mapOfLE B h at hx\n    simpa using hx\n#align valuation_subring.unit_group_le_unit_group ValuationSubring.unitGroup_le_unitGroup\n\ntheorem unitGroup_injective : Function.Injective (unitGroup : ValuationSubring K \u2192 Subgroup _) :=\n  fun A B h => by simpa only [le_antisymm_iff, unitGroup_le_unitGroup] using h\n#align valuation_subring.unit_group_injective ValuationSubring.unitGroup_injective\n\ntheorem eq_iff_unitGroup {A B : ValuationSubring K} : A = B \u2194 A.unitGroup = B.unitGroup :=\n  unitGroup_injective.eq_iff.symm\n#align valuation_subring.eq_iff_unit_group ValuationSubring.eq_iff_unitGroup\n\n/-- The map on valuation subrings to their unit groups is an order embedding. -/\ndef unitGroupOrderEmbedding : ValuationSubring K \u21aao Subgroup K\u02e3 where\n  toFun A := A.unitGroup\n  inj' := unitGroup_injective\n  map_rel_iff' {_A _B} := unitGroup_le_unitGroup\n#align valuation_subring.unit_group_order_embedding ValuationSubring.unitGroupOrderEmbedding\n\ntheorem unitGroup_strictMono : StrictMono (unitGroup : ValuationSubring K \u2192 Subgroup _) :=\n  unitGroupOrderEmbedding.strictMono\n#align valuation_subring.unit_group_strict_mono ValuationSubring.unitGroup_strictMono\n\nend UnitGroup\n\nsection nonunits\n\n/-- The nonunits of a valuation subring of `K`, as a subsemigroup of `K`-/\ndef nonunits : Subsemigroup K where\n  carrier := {x | A.valuation x < 1}\n  -- Porting note: added `Set.mem_setOf.mp`\n  mul_mem' ha hb := (mul_lt_mul\u2080 (Set.mem_setOf.mp ha) (Set.mem_setOf.mp hb)).trans_eq <| mul_one _\n#align valuation_subring.nonunits ValuationSubring.nonunits\n\ntheorem mem_nonunits_iff {x : K} : x \u2208 A.nonunits \u2194 A.valuation x < 1 :=\n  Iff.rfl\n#align valuation_subring.mem_nonunits_iff ValuationSubring.mem_nonunits_iff\n\ntheorem nonunits_le_nonunits {A B : ValuationSubring K} : B.nonunits \u2264 A.nonunits \u2194 A \u2264 B := by\n  constructor\n  \u00b7 intro h x hx\n    by_cases h_1 : x = 0; \u00b7 simp only [h_1, zero_mem]\n    rw [\u2190 valuation_le_one_iff, \u2190 not_lt, Valuation.one_lt_val_iff _ h_1] at hx \u22a2\n    by_contra h_2; exact hx (h h_2)\n  \u00b7 intro h x hx\n    by_contra h_1; exact not_lt.2 (monotone_mapOfLE _ _ h (not_lt.1 h_1)) hx\n#align valuation_subring.nonunits_le_nonunits ValuationSubring.nonunits_le_nonunits\n\ntheorem nonunits_injective : Function.Injective (nonunits : ValuationSubring K \u2192 Subsemigroup _) :=\n  fun A B h => by simpa only [le_antisymm_iff, nonunits_le_nonunits] using h.symm\n#align valuation_subring.nonunits_injective ValuationSubring.nonunits_injective\n\ntheorem nonunits_inj {A B : ValuationSubring K} : A.nonunits = B.nonunits \u2194 A = B :=\n  nonunits_injective.eq_iff\n#align valuation_subring.nonunits_inj ValuationSubring.nonunits_inj\n\n/-- The map on valuation subrings to their nonunits is a dual order embedding. -/\ndef nonunitsOrderEmbedding : ValuationSubring K \u21aao (Subsemigroup K)\u1d52\u1d48 where\n  toFun A := A.nonunits\n  inj' := nonunits_injective\n  map_rel_iff' {_A _B} := nonunits_le_nonunits\n#align valuation_subring.nonunits_order_embedding ValuationSubring.nonunitsOrderEmbedding\n\nvariable {A}\n\n/-- The elements of `A.nonunits` are those of the maximal ideal of `A` after coercion to `K`.\n\nSee also `mem_nonunits_iff_exists_mem_maximalIdeal`, which gets rid of the coercion to `K`,\nat the expense of a more complicated right hand side.\n -/\ntheorem coe_mem_nonunits_iff {a : A} : (a : K) \u2208 A.nonunits \u2194 a \u2208 LocalRing.maximalIdeal A :=\n  (valuation_lt_one_iff _ _).symm\n#align valuation_subring.coe_mem_nonunits_iff ValuationSubring.coe_mem_nonunits_iff\n\ntheorem nonunits_le : A.nonunits \u2264 A.toSubring.toSubmonoid.toSubsemigroup := fun _a ha =>\n  (A.valuation_le_one_iff _).mp (A.mem_nonunits_iff.mp ha).le\n#align valuation_subring.nonunits_le ValuationSubring.nonunits_le\n\ntheorem nonunits_subset : (A.nonunits : Set K) \u2286 A :=\n  nonunits_le\n#align valuation_subring.nonunits_subset ValuationSubring.nonunits_subset\n\n/-- The elements of `A.nonunits` are those of the maximal ideal of `A`.\n\nSee also `coe_mem_nonunits_iff`, which has a simpler right hand side but requires the element\nto be in `A` already.\n -/\ntheorem mem_nonunits_iff_exists_mem_maximalIdeal {a : K} :\n    a \u2208 A.nonunits \u2194 \u2203 ha, (\u27e8a, ha\u27e9 : A) \u2208 LocalRing.maximalIdeal A :=\n  \u27e8fun h => \u27e8nonunits_subset h, coe_mem_nonunits_iff.mp h\u27e9, fun \u27e8_, h\u27e9 =>\n    coe_mem_nonunits_iff.mpr h\u27e9\n#align valuation_subring.mem_nonunits_iff_exists_mem_maximal_ideal ValuationSubring.mem_nonunits_iff_exists_mem_maximalIdeal\n\n/-- `A.nonunits` agrees with the maximal ideal of `A`, after taking its image in `K`. -/\ntheorem image_maximalIdeal : ((\u2191) : A \u2192 K) '' LocalRing.maximalIdeal A = A.nonunits := by\n  ext a\n  simp only [Set.mem_image, SetLike.mem_coe, mem_nonunits_iff_exists_mem_maximalIdeal]\n  erw [Subtype.exists]\n  simp_rw [exists_and_right, exists_eq_right]\n  -- Porting note: added\n  simp\n#align valuation_subring.image_maximal_ideal ValuationSubring.image_maximalIdeal\n\nend nonunits\n\nsection PrincipalUnitGroup\n\n/-- The principal unit group of a valuation subring, as a subgroup of `K\u02e3`. -/\ndef principalUnitGroup : Subgroup K\u02e3 where\n  carrier := {x | A.valuation (x - 1) < 1}\n  mul_mem' := by\n    intro a b ha hb\n    -- Porting note: added\n    rw [Set.mem_setOf] at ha hb\n    refine' lt_of_le_of_lt _ (max_lt hb ha)\n    -- Porting note: `sub_add_sub_cancel` needed some help\n    rw [\u2190 one_mul (A.valuation (b - 1)), \u2190 A.valuation.map_one_add_of_lt ha, add_sub_cancel'_right,\n      \u2190 Valuation.map_mul, mul_sub_one, \u2190 sub_add_sub_cancel (\u2191(a * b) : K) _ 1]\n    exact A.valuation.map_add _ _\n  one_mem' := by simp\n  inv_mem' := by\n    dsimp\n    intro a ha\n    conv =>\n      lhs\n      rw [\u2190 mul_one (A.valuation _), \u2190 A.valuation.map_one_add_of_lt ha]\n    rwa [add_sub_cancel'_right, \u2190 Valuation.map_mul, sub_mul, Units.inv_mul, \u2190 neg_sub, one_mul,\n      Valuation.map_neg]\n#align valuation_subring.principal_unit_group ValuationSubring.principalUnitGroup\n\ntheorem principal_units_le_units : A.principalUnitGroup \u2264 A.unitGroup := fun a h => by\n  simpa only [add_sub_cancel'_right] using A.valuation.map_one_add_of_lt h\n#align valuation_subring.principal_units_le_units ValuationSubring.principal_units_le_units\n\ntheorem mem_principalUnitGroup_iff (x : K\u02e3) :\n    x \u2208 A.principalUnitGroup \u2194 A.valuation ((x : K) - 1) < 1 :=\n  Iff.rfl\n#align valuation_subring.mem_principal_unit_group_iff ValuationSubring.mem_principalUnitGroup_iff\n\ntheorem principalUnitGroup_le_principalUnitGroup {A B : ValuationSubring K} :\n    B.principalUnitGroup \u2264 A.principalUnitGroup \u2194 A \u2264 B := by\n  constructor\n  \u00b7 intro h x hx\n    by_cases h_1 : x = 0; \u00b7 simp only [h_1, zero_mem]\n    by_cases h_2 : x\u207b\u00b9 + 1 = 0\n    \u00b7 rw [add_eq_zero_iff_eq_neg, inv_eq_iff_eq_inv, inv_neg, inv_one] at h_2\n      simpa only [h_2] using B.neg_mem _ B.one_mem\n    \u00b7 rw [\u2190 valuation_le_one_iff, \u2190 not_lt, Valuation.one_lt_val_iff _ h_1, \u2190 add_sub_cancel x\u207b\u00b9, \u2190\n        Units.val_mk0 h_2, \u2190 mem_principalUnitGroup_iff] at hx \u22a2\n      simpa only [hx] using @h (Units.mk0 (x\u207b\u00b9 + 1) h_2)\n  \u00b7 intro h x hx\n    by_contra h_1; exact not_lt.2 (monotone_mapOfLE _ _ h (not_lt.1 h_1)) hx\n#align valuation_subring.principal_unit_group_le_principal_unit_group ValuationSubring.principalUnitGroup_le_principalUnitGroup\n\ntheorem principalUnitGroup_injective :\n    Function.Injective (principalUnitGroup : ValuationSubring K \u2192 Subgroup _) := fun A B h => by\n  simpa [le_antisymm_iff, principalUnitGroup_le_principalUnitGroup] using h.symm\n#align valuation_subring.principal_unit_group_injective ValuationSubring.principalUnitGroup_injective\n\ntheorem eq_iff_principalUnitGroup {A B : ValuationSubring K} :\n    A = B \u2194 A.principalUnitGroup = B.principalUnitGroup :=\n  principalUnitGroup_injective.eq_iff.symm\n#align valuation_subring.eq_iff_principal_unit_group ValuationSubring.eq_iff_principalUnitGroup\n\n/-- The map on valuation subrings to their principal unit groups is an order embedding. -/\ndef principalUnitGroupOrderEmbedding : ValuationSubring K \u21aao (Subgroup K\u02e3)\u1d52\u1d48 where\n  toFun A := A.principalUnitGroup\n  inj' := principalUnitGroup_injective\n  map_rel_iff' {_A _B} := principalUnitGroup_le_principalUnitGroup\n#align valuation_subring.principal_unit_group_order_embedding ValuationSubring.principalUnitGroupOrderEmbedding\n\ntheorem coe_mem_principalUnitGroup_iff {x : A.unitGroup} :\n    (x : K\u02e3) \u2208 A.principalUnitGroup \u2194\n      A.unitGroupMulEquiv x \u2208 (Units.map (LocalRing.residue A).toMonoidHom).ker := by\n  rw [MonoidHom.mem_ker, Units.ext_iff]\n  let \u03c0 := Ideal.Quotient.mk (LocalRing.maximalIdeal A); convert_to _ \u2194 \u03c0 _ = 1\n  rw [\u2190 \u03c0.map_one, \u2190 sub_eq_zero, \u2190 \u03c0.map_sub, Ideal.Quotient.eq_zero_iff_mem, valuation_lt_one_iff]\n  simp [mem_principalUnitGroup_iff]\n#align valuation_subring.coe_mem_principal_unit_group_iff ValuationSubring.coe_mem_principalUnitGroup_iff\n\n/-- The principal unit group agrees with the kernel of the canonical map from\nthe units of `A` to the units of the residue field of `A`. -/\ndef principalUnitGroupEquiv :\n    A.principalUnitGroup \u2243* (Units.map (LocalRing.residue A).toMonoidHom).ker where\n  toFun x :=\n    \u27e8A.unitGroupMulEquiv \u27e8_, A.principal_units_le_units x.2\u27e9,\n      A.coe_mem_principalUnitGroup_iff.1 x.2\u27e9\n  invFun x :=\n    \u27e8A.unitGroupMulEquiv.symm x, by\n      rw [A.coe_mem_principalUnitGroup_iff]; simpa using SetLike.coe_mem x\u27e9\n  left_inv x := by simp\n  right_inv x := by simp\n  map_mul' x y := rfl\n#align valuation_subring.principal_unit_group_equiv ValuationSubring.principalUnitGroupEquiv\n\n@[simp]\ntheorem principalUnitGroupEquiv_apply (a : A.principalUnitGroup) :\n    (((principalUnitGroupEquiv A a : A\u02e3) : A) : K) = (a : K\u02e3) :=\n  rfl\n#align valuation_subring.principal_unit_group_equiv_apply ValuationSubring.principalUnitGroupEquiv_apply\n\n@[simp]\ntheorem principalUnitGroup_symm_apply (a : (Units.map (LocalRing.residue A).toMonoidHom).ker) :\n    ((A.principalUnitGroupEquiv.symm a : K\u02e3) : K) = ((a : A\u02e3) : A) :=\n  rfl\n#align valuation_subring.principal_unit_group_symm_apply ValuationSubring.principalUnitGroup_symm_apply\n\n/-- The canonical map from the unit group of `A` to the units of the residue field of `A`. -/\ndef unitGroupToResidueFieldUnits : A.unitGroup \u2192* (LocalRing.ResidueField A)\u02e3 :=\n  MonoidHom.comp (Units.map <| (Ideal.Quotient.mk _).toMonoidHom) A.unitGroupMulEquiv.toMonoidHom\n#align valuation_subring.unit_group_to_residue_field_units ValuationSubring.unitGroupToResidueFieldUnits\n\n@[simp]\ntheorem coe_unitGroupToResidueFieldUnits_apply (x : A.unitGroup) :\n    (A.unitGroupToResidueFieldUnits x : LocalRing.ResidueField A) =\n      Ideal.Quotient.mk _ (A.unitGroupMulEquiv x : A) :=\n  rfl\n#align valuation_subring.coe_unit_group_to_residue_field_units_apply ValuationSubring.coe_unitGroupToResidueFieldUnits_apply\n\ntheorem ker_unitGroupToResidueFieldUnits :\n    A.unitGroupToResidueFieldUnits.ker = A.principalUnitGroup.comap A.unitGroup.subtype := by\n  ext\n  -- Porting note: simp fails but rw works\n  -- See https://github.com/leanprover-community/mathlib4/issues/5026\n  -- simp [Subgroup.mem_comap, Subgroup.coeSubtype, coe_mem_principalUnitGroup_iff]\n  rw [Subgroup.mem_comap, Subgroup.coeSubtype, coe_mem_principalUnitGroup_iff]\n  rfl\n  -- simp [Subgroup.mem_comap, Subgroup.coeSubtype, coe_mem_principalUnitGroup_iff]\n#align valuation_subring.ker_unit_group_to_residue_field_units ValuationSubring.ker_unitGroupToResidueFieldUnits\n\ntheorem surjective_unitGroupToResidueFieldUnits :\n    Function.Surjective A.unitGroupToResidueFieldUnits :=\n  (LocalRing.surjective_units_map_of_local_ringHom _ Ideal.Quotient.mk_surjective\n        LocalRing.isLocalRingHom_residue).comp\n    (MulEquiv.surjective _)\n#align valuation_subring.surjective_unit_group_to_residue_field_units ValuationSubring.surjective_unitGroupToResidueFieldUnits\n\n/-- The quotient of the unit group of `A` by the principal unit group of `A` agrees with\nthe units of the residue field of `A`. -/\ndef unitsModPrincipalUnitsEquivResidueFieldUnits :\n    A.unitGroup \u29f8 A.principalUnitGroup.comap A.unitGroup.subtype \u2243* (LocalRing.ResidueField A)\u02e3 :=\n  (QuotientGroup.quotientMulEquivOfEq A.ker_unitGroupToResidueFieldUnits.symm).trans\n    (QuotientGroup.quotientKerEquivOfSurjective _ A.surjective_unitGroupToResidueFieldUnits)\n#align valuation_subring.units_mod_principal_units_equiv_residue_field_units ValuationSubring.unitsModPrincipalUnitsEquivResidueFieldUnits\n\n-- Porting note: Lean needs to be reminded of this instance\nlocal instance : MulOneClass ({ x // x \u2208 unitGroup A } \u29f8\n  Subgroup.comap (Subgroup.subtype (unitGroup A)) (principalUnitGroup A)) := inferInstance\n\n-- @[simp] -- Porting note: not in simpNF\ntheorem unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk :\n    A.unitsModPrincipalUnitsEquivResidueFieldUnits.toMonoidHom.comp (QuotientGroup.mk' _) =\n      A.unitGroupToResidueFieldUnits := rfl\n#align valuation_subring.units_mod_principal_units_equiv_residue_field_units_comp_quotient_group_mk ValuationSubring.unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk\n\n@[simp]\ntheorem unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk_apply\n    (x : A.unitGroup) :\n    A.unitsModPrincipalUnitsEquivResidueFieldUnits.toMonoidHom (QuotientGroup.mk x) =\n      A.unitGroupToResidueFieldUnits x := rfl\n#align valuation_subring.units_mod_principal_units_equiv_residue_field_units_comp_quotient_group_mk_apply ValuationSubring.unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk_apply\n\nend PrincipalUnitGroup\n\n/-! ### Pointwise actions\n\nThis transfers the action from `Subring.pointwiseMulAction`, noting that it only applies when\nthe action is by a group. Notably this provides an instances when `G` is `K \u2243+* K`.\n\nThese instances are in the `Pointwise` locale.\n\nThe lemmas in this section are copied from `RingTheory/Subring/Pointwise.lean`; try to keep these\nin sync.\n-/\n\n\nsection PointwiseActions\n\nopen scoped Pointwise\n\nvariable {G : Type*} [Group G] [MulSemiringAction G K]\n\n/-- The action on a valuation subring corresponding to applying the action to every element.\n\nThis is available as an instance in the `Pointwise` locale. -/\ndef pointwiseHasSMul : SMul G (ValuationSubring K) where\n  smul g S :=-- TODO: if we add `ValuationSubring.map` at a later date, we should use it here\n    { g \u2022 S.toSubring with\n      mem_or_inv_mem' := fun x =>\n        (mem_or_inv_mem S (g\u207b\u00b9 \u2022 x)).imp Subring.mem_pointwise_smul_iff_inv_smul_mem.mpr fun h =>\n          Subring.mem_pointwise_smul_iff_inv_smul_mem.mpr <| by rwa [smul_inv''] }\n#align valuation_subring.pointwise_has_smul ValuationSubring.pointwiseHasSMul\n\nscoped[Pointwise] attribute [instance] ValuationSubring.pointwiseHasSMul\n\nopen scoped Pointwise\n\n@[simp]\ntheorem coe_pointwise_smul (g : G) (S : ValuationSubring K) : \u2191(g \u2022 S) = g \u2022 (S : Set K) := rfl\n#align valuation_subring.coe_pointwise_smul ValuationSubring.coe_pointwise_smul\n\n@[simp]\ntheorem pointwise_smul_toSubring (g : G) (S : ValuationSubring K) :\n    (g \u2022 S).toSubring = g \u2022 S.toSubring := rfl\n#align valuation_subring.pointwise_smul_to_subring ValuationSubring.pointwise_smul_toSubring\n\n/-- The action on a valuation subring corresponding to applying the action to every element.\n\nThis is available as an instance in the `pointwise` locale.\n\nThis is a stronger version of `ValuationSubring.pointwiseSMul`. -/\ndef pointwiseMulAction : MulAction G (ValuationSubring K) :=\n  toSubring_injective.mulAction toSubring pointwise_smul_toSubring\n#align valuation_subring.pointwise_mul_action ValuationSubring.pointwiseMulAction\n\nscoped[Pointwise] attribute [instance] ValuationSubring.pointwiseMulAction\n\nopen scoped Pointwise\n\ntheorem smul_mem_pointwise_smul (g : G) (x : K) (S : ValuationSubring K) : x \u2208 S \u2192 g \u2022 x \u2208 g \u2022 S :=\n  (Set.smul_mem_smul_set : _ \u2192 _ \u2208 g \u2022 (S : Set K))\n#align valuation_subring.smul_mem_pointwise_smul ValuationSubring.smul_mem_pointwise_smul\n\ntheorem mem_smul_pointwise_iff_exists (g : G) (x : K) (S : ValuationSubring K) :\n    x \u2208 g \u2022 S \u2194 \u2203 s : K, s \u2208 S \u2227 g \u2022 s = x :=\n  (Set.mem_smul_set : x \u2208 g \u2022 (S : Set K) \u2194 _)\n#align valuation_subring.mem_smul_pointwise_iff_exists ValuationSubring.mem_smul_pointwise_iff_exists\n\ninstance pointwise_central_scalar [MulSemiringAction G\u1d50\u1d52\u1d56 K] [IsCentralScalar G K] :\n    IsCentralScalar G (ValuationSubring K) :=\n  \u27e8fun g S => toSubring_injective <| op_smul_eq_smul g S.toSubring\u27e9\n#align valuation_subring.pointwise_central_scalar ValuationSubring.pointwise_central_scalar\n\n@[simp]\ntheorem smul_mem_pointwise_smul_iff {g : G} {S : ValuationSubring K} {x : K} :\n    g \u2022 x \u2208 g \u2022 S \u2194 x \u2208 S := Set.smul_mem_smul_set_iff\n#align valuation_subring.smul_mem_pointwise_smul_iff ValuationSubring.smul_mem_pointwise_smul_iff\n\ntheorem mem_pointwise_smul_iff_inv_smul_mem {g : G} {S : ValuationSubring K} {x : K} :\n    x \u2208 g \u2022 S \u2194 g\u207b\u00b9 \u2022 x \u2208 S := Set.mem_smul_set_iff_inv_smul_mem\n#align valuation_subring.mem_pointwise_smul_iff_inv_smul_mem ValuationSubring.mem_pointwise_smul_iff_inv_smul_mem\n\ntheorem mem_inv_pointwise_smul_iff {g : G} {S : ValuationSubring K} {x : K} :\n    x \u2208 g\u207b\u00b9 \u2022 S \u2194 g \u2022 x \u2208 S := Set.mem_inv_smul_set_iff\n#align valuation_subring.mem_inv_pointwise_smul_iff ValuationSubring.mem_inv_pointwise_smul_iff\n\n@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff {g : G} {S T : ValuationSubring K} :\n    g \u2022 S \u2264 g \u2022 T \u2194 S \u2264 T := Set.set_smul_subset_set_smul_iff\n#align valuation_subring.pointwise_smul_le_pointwise_smul_iff ValuationSubring.pointwise_smul_le_pointwise_smul_iff\n\ntheorem pointwise_smul_subset_iff {g : G} {S T : ValuationSubring K} : g \u2022 S \u2264 T \u2194 S \u2264 g\u207b\u00b9 \u2022 T :=\n  Set.set_smul_subset_iff\n#align valuation_subring.pointwise_smul_subset_iff ValuationSubring.pointwise_smul_subset_iff\n\ntheorem subset_pointwise_smul_iff {g : G} {S T : ValuationSubring K} : S \u2264 g \u2022 T \u2194 g\u207b\u00b9 \u2022 S \u2264 T :=\n  Set.subset_set_smul_iff\n#align valuation_subring.subset_pointwise_smul_iff ValuationSubring.subset_pointwise_smul_iff\n\nend PointwiseActions\n\nsection\n\nvariable {L J : Type*} [Field L] [Field J]\n\n/-- The pullback of a valuation subring `A` along a ring homomorphism `K \u2192+* L`. -/\ndef comap (A : ValuationSubring L) (f : K \u2192+* L) : ValuationSubring K :=\n  { A.toSubring.comap f with mem_or_inv_mem' := fun k => by simp [ValuationSubring.mem_or_inv_mem] }\n#align valuation_subring.comap ValuationSubring.comap\n\n@[simp]\ntheorem coe_comap (A : ValuationSubring L) (f : K \u2192+* L) : (A.comap f : Set K) = f \u207b\u00b9' A := rfl\n#align valuation_subring.coe_comap ValuationSubring.coe_comap\n\n@[simp]\ntheorem mem_comap {A : ValuationSubring L} {f : K \u2192+* L} {x : K} : x \u2208 A.comap f \u2194 f x \u2208 A :=\n  Iff.rfl\n#align valuation_subring.mem_comap ValuationSubring.mem_comap\n\ntheorem comap_comap (A : ValuationSubring J) (g : L \u2192+* J) (f : K \u2192+* L) :\n    (A.comap g).comap f = A.comap (g.comp f) := rfl\n#align valuation_subring.comap_comap ValuationSubring.comap_comap\n\nend\n\nend ValuationSubring\n\nnamespace Valuation\n\nvariable {\u0393 : Type*} [LinearOrderedCommGroupWithZero \u0393] (v : Valuation K \u0393) (x : K\u02e3)\n\n-- @[simp] -- Porting note: not in simpNF\ntheorem mem_unitGroup_iff : x \u2208 v.valuationSubring.unitGroup \u2194 v x = 1 :=\n  (Valuation.isEquiv_iff_val_eq_one _ _).mp (Valuation.isEquiv_valuation_valuationSubring _).symm\n#align valuation.mem_unit_group_iff Valuation.mem_unitGroup_iff\n\nend Valuation\n"}, {"text": "/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n/-!\n# Lemmas about quotients in characteristic zero\n-/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p / z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k / z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p / n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p / z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p / n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_nsmul_iff\n\nend QuotientAddGroup\n"}, {"text": "/-\nCopyright (c) 2021 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\nimport Mathlib.Algebra.Homology.HomologicalComplex\n\n#align_import algebra.homology.functor from \"leanprover-community/mathlib\"@\"8e25bb6c1645bb80670e13848b79a54aa45cb84f\"\n\n/-!\n# Complexes in functor categories\n\nWe can view a complex valued in a functor category `T \u2964 V` as\na functor from `T` to complexes valued in `V`.\n\n## Future work\nIn fact this is an equivalence of categories.\n\n-/\n\n\nuniverse v u\n\nopen CategoryTheory\n\nopen CategoryTheory.Limits\n\nnamespace HomologicalComplex\n\nvariable {V : Type u} [Category.{v} V] [HasZeroMorphisms V]\n\nvariable {\u03b9 : Type*} {c : ComplexShape \u03b9}\n\n/-- A complex of functors gives a functor to complexes. -/\n@[simps obj map]\ndef asFunctor {T : Type*} [Category T] (C : HomologicalComplex (T \u2964 V) c) :\n    T \u2964 HomologicalComplex V c where\n  obj t :=\n    { X := fun i => (C.X i).obj t\n      d := fun i j => (C.d i j).app t\n      d_comp_d' := fun i j k _ _ => by\n        have := C.d_comp_d i j k\n        rw [NatTrans.ext_iff, Function.funext_iff] at this\n        exact this t\n      shape := fun i j h => by\n        have := C.shape _ _ h\n        rw [NatTrans.ext_iff, Function.funext_iff] at this\n        exact this t }\n  map h :=\n    { f := fun i => (C.X i).map h\n      comm' := fun i j _ => NatTrans.naturality _ _ }\n  map_id t := by\n    ext i\n    dsimp\n    rw [(C.X i).map_id]\n  map_comp h\u2081 h\u2082 := by\n    ext i\n    dsimp\n    rw [Functor.map_comp]\n#align homological_complex.as_functor HomologicalComplex.asFunctor\n\n-- TODO in fact, this is an equivalence of categories.\n/-- The functorial version of `HomologicalComplex.asFunctor`. -/\n@[simps]\ndef complexOfFunctorsToFunctorToComplex {T : Type*} [Category T] :\n    HomologicalComplex (T \u2964 V) c \u2964 T \u2964 HomologicalComplex V c where\n  obj C := C.asFunctor\n  map f :=\n    { app := fun t =>\n        { f := fun i => (f.f i).app t\n          comm' := fun i j _ => NatTrans.congr_app (f.comm i j) t }\n      naturality := fun t t' g => by\n        ext i\n        exact (f.f i).naturality g }\n#align homological_complex.complex_of_functors_to_functor_to_complex HomologicalComplex.complexOfFunctorsToFunctorToComplex\n\nend HomologicalComplex\n"}, {"text": "/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\nimport Mathlib.CategoryTheory.Limits.Shapes.Reflexive\nimport Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer\nimport Mathlib.CategoryTheory.Monad.Algebra\n\n#align_import category_theory.monad.coequalizer from \"leanprover-community/mathlib\"@\"3a061790136d13594ec10c7c90d202335ac5d854\"\n\n/-!\n# Special coequalizers associated to a monad\n\nAssociated to a monad `T : C \u2964 C` we have important coequalizer constructions:\nAny algebra is a coequalizer (in the category of algebras) of free algebras. Furthermore, this\ncoequalizer is reflexive.\nIn `C`, this cofork diagram is a split coequalizer (in particular, it is still a coequalizer).\nThis split coequalizer is known as the Beck coequalizer (as it features heavily in Beck's\nmonadicity theorem).\n-/\n\n\nuniverse v\u2081 u\u2081\n\nnamespace CategoryTheory\n\nnamespace Monad\n\nopen Limits\n\nvariable {C : Type u\u2081}\n\nvariable [Category.{v\u2081} C]\n\nvariable {T : Monad C} (X : Algebra T)\n\n/-!\nShow that any algebra is a coequalizer of free algebras.\n-/\n\n\n/-- The top map in the coequalizer diagram we will construct. -/\n@[simps!]\ndef FreeCoequalizer.topMap : (Monad.free T).obj (T.obj X.A) \u27f6 (Monad.free T).obj X.A :=\n  (Monad.free T).map X.a\n#align category_theory.monad.free_coequalizer.top_map CategoryTheory.Monad.FreeCoequalizer.topMap\n\n/-- The bottom map in the coequalizer diagram we will construct. -/\n@[simps]\ndef FreeCoequalizer.bottomMap : (Monad.free T).obj (T.obj X.A) \u27f6 (Monad.free T).obj X.A where\n  f := T.\u03bc.app X.A\n  h := T.assoc X.A\n#align category_theory.monad.free_coequalizer.bottom_map CategoryTheory.Monad.FreeCoequalizer.bottomMap\n\n/-- The cofork map in the coequalizer diagram we will construct. -/\n@[simps]\ndef FreeCoequalizer.\u03c0 : (Monad.free T).obj X.A \u27f6 X where\n  f := X.a\n  h := X.assoc.symm\n#align category_theory.monad.free_coequalizer.\u03c0 CategoryTheory.Monad.FreeCoequalizer.\u03c0\n\ntheorem FreeCoequalizer.condition :\n    FreeCoequalizer.topMap X \u226b FreeCoequalizer.\u03c0 X =\n      FreeCoequalizer.bottomMap X \u226b FreeCoequalizer.\u03c0 X :=\n  Algebra.Hom.ext _ _ X.assoc.symm\n#align category_theory.monad.free_coequalizer.condition CategoryTheory.Monad.FreeCoequalizer.condition\n\ninstance : IsReflexivePair (FreeCoequalizer.topMap X) (FreeCoequalizer.bottomMap X) := by\n  apply IsReflexivePair.mk' _ _ _\n  apply (free T).map (T.\u03b7.app X.A)\n  \u00b7 ext\n    dsimp\n    rw [\u2190 Functor.map_comp, X.unit, Functor.map_id]\n  \u00b7 ext\n    apply Monad.right_unit\n\n/-- Construct the Beck cofork in the category of algebras. This cofork is reflexive as well as a\ncoequalizer.\n-/\n@[simps!]\ndef beckAlgebraCofork : Cofork (FreeCoequalizer.topMap X) (FreeCoequalizer.bottomMap X) :=\n  Cofork.of\u03c0 _ (FreeCoequalizer.condition X)\n#align category_theory.monad.beck_algebra_cofork CategoryTheory.Monad.beckAlgebraCofork\n\n/-- The cofork constructed is a colimit. This shows that any algebra is a (reflexive) coequalizer of\nfree algebras.\n-/\ndef beckAlgebraCoequalizer : IsColimit (beckAlgebraCofork X) :=\n  Cofork.IsColimit.mk' _ fun s => by\n    have h\u2081 : (T : C \u2964 C).map X.a \u226b s.\u03c0.f = T.\u03bc.app X.A \u226b s.\u03c0.f :=\n      congr_arg Monad.Algebra.Hom.f s.condition\n    have h\u2082 : (T : C \u2964 C).map s.\u03c0.f \u226b s.pt.a = T.\u03bc.app X.A \u226b s.\u03c0.f := s.\u03c0.h\n    refine' \u27e8\u27e8T.\u03b7.app _ \u226b s.\u03c0.f, _\u27e9, _, _\u27e9\n    \u00b7 dsimp\n      rw [Functor.map_comp, Category.assoc, h\u2082, Monad.right_unit_assoc,\n        show X.a \u226b _ \u226b _ = _ from T.\u03b7.naturality_assoc _ _, h\u2081, Monad.left_unit_assoc]\n    \u00b7 ext\n      simpa [\u2190 T.\u03b7.naturality_assoc, T.left_unit_assoc] using T.\u03b7.app ((T : C \u2964 C).obj X.A) \u226b= h\u2081\n    \u00b7 intro m hm\n      ext\n      dsimp only\n      rw [\u2190 hm]\n      apply (X.unit_assoc _).symm\n#align category_theory.monad.beck_algebra_coequalizer CategoryTheory.Monad.beckAlgebraCoequalizer\n\n/-- The Beck cofork is a split coequalizer. -/\ndef beckSplitCoequalizer : IsSplitCoequalizer (T.map X.a) (T.\u03bc.app _) X.a :=\n  \u27e8T.\u03b7.app _, T.\u03b7.app _, X.assoc.symm, X.unit, T.left_unit _, (T.\u03b7.naturality _).symm\u27e9\n#align category_theory.monad.beck_split_coequalizer CategoryTheory.Monad.beckSplitCoequalizer\n\n/-- This is the Beck cofork. It is a split coequalizer, in particular a coequalizer. -/\n@[simps! pt]\ndef beckCofork : Cofork (T.map X.a) (T.\u03bc.app _) :=\n  (beckSplitCoequalizer X).asCofork\n#align category_theory.monad.beck_cofork CategoryTheory.Monad.beckCofork\n\n@[simp]\ntheorem beckCofork_\u03c0 : (beckCofork X).\u03c0 = X.a :=\n  rfl\n#align category_theory.monad.beck_cofork_\u03c0 CategoryTheory.Monad.beckCofork_\u03c0\n\n/-- The Beck cofork is a coequalizer. -/\ndef beckCoequalizer : IsColimit (beckCofork X) :=\n  (beckSplitCoequalizer X).isCoequalizer\n#align category_theory.monad.beck_coequalizer CategoryTheory.Monad.beckCoequalizer\n\n@[simp]\ntheorem beckCoequalizer_desc (s : Cofork (T.toFunctor.map X.a) (T.\u03bc.app X.A)) :\n    (beckCoequalizer X).desc s = T.\u03b7.app _ \u226b s.\u03c0 :=\n  rfl\n#align category_theory.monad.beck_coequalizer_desc CategoryTheory.Monad.beckCoequalizer_desc\n\nend Monad\n\nend CategoryTheory\n"}, {"text": "/-\nCopyright (c) 2014 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Leonardo de Moura\n-/\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.Algebra.GroupWithZero.Divisibility\nimport Mathlib.Data.Nat.Order.Lemmas\nimport Mathlib.Tactic.NthRewrite\n\n#align_import data.nat.gcd.basic from \"leanprover-community/mathlib\"@\"e8638a0fcaf73e4500469f368ef9494e495099b3\"\n\n/-!\n# Definitions and properties of `Nat.gcd`, `Nat.lcm`, and `Nat.coprime`\n\nGeneralizations of these are provided in a later file as `GCDMonoid.gcd` and\n`GCDMonoid.lcm`.\n\nNote that the global `IsCoprime` is not a straightforward generalization of `Nat.coprime`, see\n`Nat.isCoprime_iff_coprime` for the connection between the two.\n\n-/\n\nnamespace Nat\n\n/-! ### `gcd` -/\n\ntheorem gcd_greatest {a b d : \u2115} (hda : d \u2223 a) (hdb : d \u2223 b) (hd : \u2200 e : \u2115, e \u2223 a \u2192 e \u2223 b \u2192 e \u2223 d) :\n    d = a.gcd b :=\n  (dvd_antisymm (hd _ (gcd_dvd_left a b) (gcd_dvd_right a b)) (dvd_gcd hda hdb)).symm\n#align nat.gcd_greatest Nat.gcd_greatest\n\n-- Lemmas where one argument consists of addition of a multiple of the other\n@[simp]\ntheorem gcd_add_mul_right_right (m n k : \u2115) : gcd m (n + k * m) = gcd m n := by\n  simp [gcd_rec m (n + k * m), gcd_rec m n]\n#align nat.gcd_add_mul_right_right Nat.gcd_add_mul_right_right\n\n@[simp]\ntheorem gcd_add_mul_left_right (m n k : \u2115) : gcd m (n + m * k) = gcd m n := by\n  simp [gcd_rec m (n + m * k), gcd_rec m n]\n#align nat.gcd_add_mul_left_right Nat.gcd_add_mul_left_right\n\n@[simp]\ntheorem gcd_mul_right_add_right (m n k : \u2115) : gcd m (k * m + n) = gcd m n := by simp [add_comm _ n]\n#align nat.gcd_mul_right_add_right Nat.gcd_mul_right_add_right\n\n@[simp]\ntheorem gcd_mul_left_add_right (m n k : \u2115) : gcd m (m * k + n) = gcd m n := by simp [add_comm _ n]\n#align nat.gcd_mul_left_add_right Nat.gcd_mul_left_add_right\n\n@[simp]\ntheorem gcd_add_mul_right_left (m n k : \u2115) : gcd (m + k * n) n = gcd m n := by\n  rw [gcd_comm, gcd_add_mul_right_right, gcd_comm]\n#align nat.gcd_add_mul_right_left Nat.gcd_add_mul_right_left\n\n@[simp]\ntheorem gcd_add_mul_left_left (m n k : \u2115) : gcd (m + n * k) n = gcd m n := by\n  rw [gcd_comm, gcd_add_mul_left_right, gcd_comm]\n#align nat.gcd_add_mul_left_left Nat.gcd_add_mul_left_left\n\n@[simp]\ntheorem gcd_mul_right_add_left (m n k : \u2115) : gcd (k * n + m) n = gcd m n := by\n  rw [gcd_comm, gcd_mul_right_add_right, gcd_comm]\n#align nat.gcd_mul_right_add_left Nat.gcd_mul_right_add_left\n\n@[simp]\ntheorem gcd_mul_left_add_left (m n k : \u2115) : gcd (n * k + m) n = gcd m n := by\n  rw [gcd_comm, gcd_mul_left_add_right, gcd_comm]\n#align nat.gcd_mul_left_add_left Nat.gcd_mul_left_add_left\n\n-- Lemmas where one argument consists of an addition of the other\n@[simp]\ntheorem gcd_add_self_right (m n : \u2115) : gcd m (n + m) = gcd m n :=\n  Eq.trans (by rw [one_mul]) (gcd_add_mul_right_right m n 1)\n#align nat.gcd_add_self_right Nat.gcd_add_self_right\n\n@[simp]\ntheorem gcd_add_self_left (m n : \u2115) : gcd (m + n) n = gcd m n := by\n  rw [gcd_comm, gcd_add_self_right, gcd_comm]\n#align nat.gcd_add_self_left Nat.gcd_add_self_left\n\n@[simp]\ntheorem gcd_self_add_left (m n : \u2115) : gcd (m + n) m = gcd n m := by rw [add_comm, gcd_add_self_left]\n#align nat.gcd_self_add_left Nat.gcd_self_add_left\n\n@[simp]\ntheorem gcd_self_add_right (m n : \u2115) : gcd m (m + n) = gcd m n := by\n  rw [add_comm, gcd_add_self_right]\n#align nat.gcd_self_add_right Nat.gcd_self_add_right\n\n-- Lemmas where one argument consists of a subtraction of the other\n@[simp]\ntheorem gcd_sub_self_left {m n : \u2115} (h : m \u2264 n) : gcd (n - m) m = gcd n m := by\n  calc\n    gcd (n - m) m = gcd (n - m + m) m  := by rw [\u2190 gcd_add_self_left (n - m) m]\n                _ = gcd n m := by rw [Nat.sub_add_cancel h]\n\n@[simp]\ntheorem gcd_sub_self_right {m n : \u2115} (h : m \u2264 n) : gcd m (n - m) = gcd m n := by\n  rw [gcd_comm, gcd_sub_self_left h, gcd_comm]\n\n@[simp]\ntheorem gcd_self_sub_left {m n : \u2115} (h : m \u2264 n) : gcd (n - m) n = gcd m n := by\n  have := Nat.sub_add_cancel h\n  rw [gcd_comm m n, \u2190 this, gcd_add_self_left (n - m) m]\n  have : gcd (n - m) n = gcd (n - m) m := by\n    nth_rw 2 [\u2190 Nat.add_sub_cancel' h]\n    rw [gcd_add_self_right, gcd_comm]\n  convert this\n\n@[simp]\ntheorem gcd_self_sub_right {m n : \u2115} (h : m \u2264 n) : gcd n (n - m) = gcd n m := by\n  rw [gcd_comm, gcd_self_sub_left h, gcd_comm]\n\n/-! ### `lcm` -/\n\ntheorem lcm_dvd_mul (m n : \u2115) : lcm m n \u2223 m * n :=\n  lcm_dvd (dvd_mul_right _ _) (dvd_mul_left _ _)\n#align nat.lcm_dvd_mul Nat.lcm_dvd_mul\n\ntheorem lcm_dvd_iff {m n k : \u2115} : lcm m n \u2223 k \u2194 m \u2223 k \u2227 n \u2223 k :=\n  \u27e8fun h => \u27e8(dvd_lcm_left _ _).trans h, (dvd_lcm_right _ _).trans h\u27e9, and_imp.2 lcm_dvd\u27e9\n#align nat.lcm_dvd_iff Nat.lcm_dvd_iff\n\ntheorem lcm_pos {m n : \u2115} : 0 < m \u2192 0 < n \u2192 0 < m.lcm n := by\n  simp_rw [pos_iff_ne_zero]\n  exact lcm_ne_zero\n#align nat.lcm_pos Nat.lcm_pos\n\n/-!\n### `Coprime`\n\nSee also `Nat.coprime_of_dvd` and `Nat.coprime_of_dvd'` to prove `Nat.Coprime m n`.\n-/\n\ninstance (m n : \u2115) : Decidable (Coprime m n) := inferInstanceAs (Decidable (gcd m n = 1))\n\ntheorem Coprime.lcm_eq_mul {m n : \u2115} (h : Coprime m n) : lcm m n = m * n := by\n  rw [\u2190 one_mul (lcm m n), \u2190 h.gcd_eq_one, gcd_mul_lcm]\n#align nat.coprime.lcm_eq_mul Nat.Coprime.lcm_eq_mul\n\ntheorem Coprime.symmetric : Symmetric Coprime := fun _ _ => Coprime.symm\n#align nat.coprime.symmetric Nat.Coprime.symmetric\n\ntheorem Coprime.dvd_mul_right {m n k : \u2115} (H : Coprime k n) : k \u2223 m * n \u2194 k \u2223 m :=\n  \u27e8H.dvd_of_dvd_mul_right, fun h => dvd_mul_of_dvd_left h n\u27e9\n#align nat.coprime.dvd_mul_right Nat.Coprime.dvd_mul_right\n\ntheorem Coprime.dvd_mul_left {m n k : \u2115} (H : Coprime k m) : k \u2223 m * n \u2194 k \u2223 n :=\n  \u27e8H.dvd_of_dvd_mul_left, fun h => dvd_mul_of_dvd_right h m\u27e9\n#align nat.coprime.dvd_mul_left Nat.Coprime.dvd_mul_left\n\n@[simp]\ntheorem coprime_add_self_right {m n : \u2115} : Coprime m (n + m) \u2194 Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_self_right]\n#align nat.coprime_add_self_right Nat.coprime_add_self_right\n\n@[simp]\ntheorem coprime_self_add_right {m n : \u2115} : Coprime m (m + n) \u2194 Coprime m n := by\n  rw [add_comm, coprime_add_self_right]\n#align nat.coprime_self_add_right Nat.coprime_self_add_right\n\n@[simp]\ntheorem coprime_add_self_left {m n : \u2115} : Coprime (m + n) n \u2194 Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_self_left]\n#align nat.coprime_add_self_left Nat.coprime_add_self_left\n\n@[simp]\ntheorem coprime_self_add_left {m n : \u2115} : Coprime (m + n) m \u2194 Coprime n m := by\n  rw [Coprime, Coprime, gcd_self_add_left]\n#align nat.coprime_self_add_left Nat.coprime_self_add_left\n\n@[simp]\ntheorem coprime_add_mul_right_right (m n k : \u2115) : Coprime m (n + k * m) \u2194 Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_mul_right_right]\n#align nat.coprime_add_mul_right_right Nat.coprime_add_mul_right_right\n\n@[simp]\ntheorem coprime_add_mul_left_right (m n k : \u2115) : Coprime m (n + m * k) \u2194 Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_mul_left_right]\n#align nat.coprime_add_mul_left_right Nat.coprime_add_mul_left_right\n\n@[simp]\ntheorem coprime_mul_right_add_right (m n k : \u2115) : Coprime m (k * m + n) \u2194 Coprime m n := by\n  rw [Coprime, Coprime, gcd_mul_right_add_right]\n#align nat.coprime_mul_right_add_right Nat.coprime_mul_right_add_right\n\n@[simp]\ntheorem coprime_mul_left_add_right (m n k : \u2115) : Coprime m (m * k + n) \u2194 Coprime m n := by\n  rw [Coprime, Coprime, gcd_mul_left_add_right]\n#align nat.coprime_mul_left_add_right Nat.coprime_mul_left_add_right\n\n@[simp]\ntheorem coprime_add_mul_right_left (m n k : \u2115) : Coprime (m + k * n) n \u2194 Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_mul_right_left]\n#align nat.coprime_add_mul_right_left Nat.coprime_add_mul_right_left\n\n@[simp]\ntheorem coprime_add_mul_left_left (m n k : \u2115) : Coprime (m + n * k) n \u2194 Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_mul_left_left]\n#align nat.coprime_add_mul_left_left Nat.coprime_add_mul_left_left\n\n@[simp]\ntheorem coprime_mul_right_add_left (m n k : \u2115) : Coprime (k * n + m) n \u2194 Coprime m n := by\n  rw [Coprime, Coprime, gcd_mul_right_add_left]\n#align nat.coprime_mul_right_add_left Nat.coprime_mul_right_add_left\n\n@[simp]\ntheorem coprime_mul_left_add_left (m n k : \u2115) : Coprime (n * k + m) n \u2194 Coprime m n := by\n  rw [Coprime, Coprime, gcd_mul_left_add_left]\n#align nat.coprime_mul_left_add_left Nat.coprime_mul_left_add_left\n\n@[simp]\ntheorem coprime_sub_self_left {m n : \u2115} (h : m \u2264 n) : Coprime (n - m) m \u2194 Coprime n m := by\n  rw [Coprime, Coprime, gcd_sub_self_left h]\n\n@[simp]\ntheorem coprime_sub_self_right {m n : \u2115} (h : m \u2264 n) : Coprime m (n - m) \u2194 Coprime m n:= by\n  rw [Coprime, Coprime, gcd_sub_self_right h]\n\n@[simp]\ntheorem coprime_self_sub_left {m n : \u2115} (h : m \u2264 n) : Coprime (n - m) n \u2194 Coprime m n := by\n  rw [Coprime, Coprime, gcd_self_sub_left h]\n\n@[simp]\ntheorem coprime_self_sub_right {m n : \u2115} (h : m \u2264 n) : Coprime n (n - m) \u2194 Coprime n m := by\n  rw [Coprime, Coprime, gcd_self_sub_right h]\n\n@[simp]\ntheorem coprime_pow_left_iff {n : \u2115} (hn : 0 < n) (a b : \u2115) :\n    Nat.Coprime (a ^ n) b \u2194 Nat.Coprime a b := by\n  obtain \u27e8n, rfl\u27e9 := exists_eq_succ_of_ne_zero hn.ne'\n  rw [pow_succ, Nat.coprime_mul_iff_left]\n  exact \u27e8And.right, fun hab => \u27e8hab.pow_left _, hab\u27e9\u27e9\n#align nat.coprime_pow_left_iff Nat.coprime_pow_left_iff\n\n@[simp]\ntheorem coprime_pow_right_iff {n : \u2115} (hn : 0 < n) (a b : \u2115) :\n    Nat.Coprime a (b ^ n) \u2194 Nat.Coprime a b := by\n  rw [Nat.coprime_comm, coprime_pow_left_iff hn, Nat.coprime_comm]\n#align nat.coprime_pow_right_iff Nat.coprime_pow_right_iff\n\ntheorem not_coprime_zero_zero : \u00acCoprime 0 0 := by simp\n#align nat.not_coprime_zero_zero Nat.not_coprime_zero_zero\n\ntheorem coprime_one_left_iff (n : \u2115) : Coprime 1 n \u2194 True := by simp [Coprime]\n#align nat.coprime_one_left_iff Nat.coprime_one_left_iff\n\ntheorem coprime_one_right_iff (n : \u2115) : Coprime n 1 \u2194 True := by simp [Coprime]\n#align nat.coprime_one_right_iff Nat.coprime_one_right_iff\n\ntheorem gcd_mul_of_coprime_of_dvd {a b c : \u2115} (hac : Coprime a c) (b_dvd_c : b \u2223 c) :\n    gcd (a * b) c = b := by\n  rcases exists_eq_mul_left_of_dvd b_dvd_c with \u27e8d, rfl\u27e9\n  rw [gcd_mul_right]\n  convert one_mul b\n  exact Coprime.coprime_mul_right_right hac\n#align nat.gcd_mul_of_coprime_of_dvd Nat.gcd_mul_of_coprime_of_dvd\n\ntheorem Coprime.eq_of_mul_eq_zero {m n : \u2115} (h : m.Coprime n) (hmn : m * n = 0) :\n    m = 0 \u2227 n = 1 \u2228 m = 1 \u2227 n = 0 :=\n  (Nat.eq_zero_of_mul_eq_zero hmn).imp (fun hm => \u27e8hm, n.coprime_zero_left.mp <| hm \u25b8 h\u27e9) fun hn =>\n    let eq := hn \u25b8 h.symm\n    \u27e8m.coprime_zero_left.mp <| eq, hn\u27e9\n#align nat.coprime.eq_of_mul_eq_zero Nat.Coprime.eq_of_mul_eq_zero\n\n/-- Represent a divisor of `m * n` as a product of a divisor of `m` and a divisor of `n`.\n\nSee `exists_dvd_and_dvd_of_dvd_mul` for the more general but less constructive version for other\n`GCDMonoid`s. -/\ndef prodDvdAndDvdOfDvdProd {m n k : \u2115} (H : k \u2223 m * n) :\n    { d : { m' // m' \u2223 m } \u00d7 { n' // n' \u2223 n } // k = d.1 * d.2 } := by\n  cases h0 : gcd k m\n  case zero =>\n    obtain rfl : k = 0 := eq_zero_of_gcd_eq_zero_left h0\n    obtain rfl : m = 0 := eq_zero_of_gcd_eq_zero_right h0\n    exact \u27e8\u27e8\u27e80, dvd_refl 0\u27e9, \u27e8n, dvd_refl n\u27e9\u27e9, (zero_mul n).symm\u27e9\n  case succ tmp =>\n    have hpos : 0 < gcd k m := h0.symm \u25b8 Nat.zero_lt_succ _; clear h0 tmp\n    have hd : gcd k m * (k / gcd k m) = k := Nat.mul_div_cancel' (gcd_dvd_left k m)\n    refine' \u27e8\u27e8\u27e8gcd k m, gcd_dvd_right k m\u27e9, \u27e8k / gcd k m, _\u27e9\u27e9, hd.symm\u27e9\n    apply Nat.dvd_of_mul_dvd_mul_left hpos\n    rw [hd, \u2190 gcd_mul_right]\n    exact dvd_gcd (dvd_mul_right _ _) H\n#align nat.prod_dvd_and_dvd_of_dvd_prod Nat.prodDvdAndDvdOfDvdProd\n\ntheorem dvd_mul {x m n : \u2115} : x \u2223 m * n \u2194 \u2203 y z, y \u2223 m \u2227 z \u2223 n \u2227 y * z = x := by\n  constructor\n  \u00b7 intro h\n    obtain \u27e8\u27e8\u27e8y, hy\u27e9, \u27e8z, hz\u27e9\u27e9, rfl\u27e9 := prod_dvd_and_dvd_of_dvd_prod h\n    exact \u27e8y, z, hy, hz, rfl\u27e9\n  \u00b7 rintro \u27e8y, z, hy, hz, rfl\u27e9\n    exact mul_dvd_mul hy hz\n#align nat.dvd_mul Nat.dvd_mul\n\ntheorem pow_dvd_pow_iff {a b n : \u2115} (n0 : 0 < n) : a ^ n \u2223 b ^ n \u2194 a \u2223 b := by\n  refine' \u27e8fun h => _, fun h => pow_dvd_pow_of_dvd h _\u27e9\n  cases' Nat.eq_zero_or_pos (gcd a b) with g0 g0\n  \u00b7 simp [eq_zero_of_gcd_eq_zero_right g0]\n  rcases exists_coprime' g0 with \u27e8g, a', b', g0', co, rfl, rfl\u27e9\n  rw [mul_pow, mul_pow] at h\n  replace h := Nat.dvd_of_mul_dvd_mul_right (pow_pos g0' _) h\n  have := pow_dvd_pow a' n0\n  rw [pow_one, (co.pow n n).eq_one_of_dvd h] at this\n  simp [eq_one_of_dvd_one this]\n#align nat.pow_dvd_pow_iff Nat.pow_dvd_pow_iff\n\n/-- If `k:\u2115` divides coprime `a` and `b` then `k = 1` -/\ntheorem eq_one_of_dvd_coprimes {a b k : \u2115} (h_ab_coprime : Coprime a b) (hka : k \u2223 a)\n    (hkb : k \u2223 b) : k = 1 := by\n  rw [coprime_iff_gcd_eq_one] at h_ab_coprime\n  have h1 := dvd_gcd hka hkb\n  rw [h_ab_coprime] at h1\n  exact Nat.dvd_one.mp h1\n#align nat.eq_one_of_dvd_coprimes Nat.eq_one_of_dvd_coprimes\n\ntheorem Coprime.mul_add_mul_ne_mul {m n a b : \u2115} (cop : Coprime m n) (ha : a \u2260 0) (hb : b \u2260 0) :\n    a * m + b * n \u2260 m * n := by\n  intro h\n  obtain \u27e8x, rfl\u27e9 : n \u2223 a :=\n    cop.symm.dvd_of_dvd_mul_right\n      ((Nat.dvd_add_iff_left (Nat.dvd_mul_left n b)).mpr\n        ((congr_arg _ h).mpr (Nat.dvd_mul_left n m)))\n  obtain \u27e8y, rfl\u27e9 : m \u2223 b :=\n    cop.dvd_of_dvd_mul_right\n      ((Nat.dvd_add_iff_right (Nat.dvd_mul_left m (n * x))).mpr\n        ((congr_arg _ h).mpr (Nat.dvd_mul_right m n)))\n  rw [mul_comm, mul_ne_zero_iff, \u2190 one_le_iff_ne_zero] at ha hb\n  refine' mul_ne_zero hb.2 ha.2 (eq_zero_of_mul_eq_self_left (ne_of_gt (add_le_add ha.1 hb.1)) _)\n  rw [\u2190 mul_assoc, \u2190 h, add_mul, add_mul, mul_comm _ n, \u2190 mul_assoc, mul_comm y]\n#align nat.coprime.mul_add_mul_ne_mul Nat.Coprime.mul_add_mul_ne_mul\n\nend Nat\n"}, {"text": "/-\nCopyright (c) 2018 Johannes H\u00f6lzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes H\u00f6lzl, Mitchell Rowett, Scott Morrison, Johan Commelin, Mario Carneiro,\n  Michael Howes\n-/\nimport Mathlib.GroupTheory.Subgroup.Basic\nimport Mathlib.Deprecated.Submonoid\n\n#align_import deprecated.subgroup from \"leanprover-community/mathlib\"@\"f93c11933efbc3c2f0299e47b8ff83e9b539cbf6\"\n\n/-!\n# Unbundled subgroups (deprecated)\n\nThis file is deprecated, and is no longer imported by anything in mathlib other than other\ndeprecated files, and test files. You should not need to import it.\n\nThis file defines unbundled multiplicative and additive subgroups. Instead of using this file,\nplease use `Subgroup G` and `AddSubgroup A`, defined in `GroupTheory.Subgroup.Basic`.\n\n## Main definitions\n\n`IsAddSubgroup (S : Set A)` : the predicate that `S` is the underlying subset of an additive\nsubgroup of `A`. The bundled variant `AddSubgroup A` should be used in preference to this.\n\n`IsSubgroup (S : Set G)` : the predicate that `S` is the underlying subset of a subgroup\nof `G`. The bundled variant `Subgroup G` should be used in preference to this.\n\n## Tags\n\nsubgroup, subgroups, IsSubgroup\n-/\n\n\nopen Set Function\n\nvariable {G : Type*} {H : Type*} {A : Type*} {a a\u2081 a\u2082 b c : G}\n\nsection Group\n\nvariable [Group G] [AddGroup A]\n\n/-- `s` is an additive subgroup: a set containing 0 and closed under addition and negation. -/\nstructure IsAddSubgroup (s : Set A) extends IsAddSubmonoid s : Prop where\n  /-- The proposition that `s` is closed under negation. -/\n  neg_mem {a} : a \u2208 s \u2192 -a \u2208 s\n#align is_add_subgroup IsAddSubgroup\n\n/-- `s` is a subgroup: a set containing 1 and closed under multiplication and inverse. -/\n@[to_additive]\nstructure IsSubgroup (s : Set G) extends IsSubmonoid s : Prop where\n  /-- The proposition that `s` is closed under inverse. -/\n  inv_mem {a} : a \u2208 s \u2192 a\u207b\u00b9 \u2208 s\n#align is_subgroup IsSubgroup\n\n@[to_additive]\ntheorem IsSubgroup.div_mem {s : Set G} (hs : IsSubgroup s) {x y : G} (hx : x \u2208 s) (hy : y \u2208 s) :\n    x / y \u2208 s := by simpa only [div_eq_mul_inv] using hs.mul_mem hx (hs.inv_mem hy)\n#align is_subgroup.div_mem IsSubgroup.div_mem\n#align is_add_subgroup.sub_mem IsAddSubgroup.sub_mem\n\ntheorem Additive.isAddSubgroup {s : Set G} (hs : IsSubgroup s) : @IsAddSubgroup (Additive G) _ s :=\n  @IsAddSubgroup.mk (Additive G) _ _ (Additive.isAddSubmonoid hs.toIsSubmonoid) hs.inv_mem\n#align additive.is_add_subgroup Additive.isAddSubgroup\n\ntheorem Additive.isAddSubgroup_iff {s : Set G} : @IsAddSubgroup (Additive G) _ s \u2194 IsSubgroup s :=\n  \u27e8by rintro \u27e8\u27e8h\u2081, h\u2082\u27e9, h\u2083\u27e9; exact @IsSubgroup.mk G _ _ \u27e8h\u2081, @h\u2082\u27e9 @h\u2083, fun h =>\n    Additive.isAddSubgroup h\u27e9\n#align additive.is_add_subgroup_iff Additive.isAddSubgroup_iff\n\ntheorem Multiplicative.isSubgroup {s : Set A} (hs : IsAddSubgroup s) :\n    @IsSubgroup (Multiplicative A) _ s :=\n  @IsSubgroup.mk (Multiplicative A) _ _ (Multiplicative.isSubmonoid hs.toIsAddSubmonoid) hs.neg_mem\n#align multiplicative.is_subgroup Multiplicative.isSubgroup\n\ntheorem Multiplicative.isSubgroup_iff {s : Set A} :\n    @IsSubgroup (Multiplicative A) _ s \u2194 IsAddSubgroup s :=\n  \u27e8by rintro \u27e8\u27e8h\u2081, h\u2082\u27e9, h\u2083\u27e9; exact @IsAddSubgroup.mk A _ _ \u27e8h\u2081, @h\u2082\u27e9 @h\u2083, fun h =>\n    Multiplicative.isSubgroup h\u27e9\n#align multiplicative.is_subgroup_iff Multiplicative.isSubgroup_iff\n\n@[to_additive of_add_neg]\ntheorem IsSubgroup.of_div (s : Set G) (one_mem : (1 : G) \u2208 s)\n    (div_mem : \u2200 {a b : G}, a \u2208 s \u2192 b \u2208 s \u2192 a * b\u207b\u00b9 \u2208 s) : IsSubgroup s :=\n  have inv_mem : \u2200 a, a \u2208 s \u2192 a\u207b\u00b9 \u2208 s := fun a ha => by\n    have : 1 * a\u207b\u00b9 \u2208 s := div_mem one_mem ha\n    convert this using 1\n    rw [one_mul]\n  { inv_mem := inv_mem _\n    mul_mem := fun {a b} ha hb => by\n      have : a * b\u207b\u00b9\u207b\u00b9 \u2208 s := div_mem ha (inv_mem b hb)\n      convert this\n      rw [inv_inv]\n    one_mem }\n#align is_subgroup.of_div IsSubgroup.of_div\n#align is_add_subgroup.of_add_neg IsAddSubgroup.of_add_neg\n\ntheorem IsAddSubgroup.of_sub (s : Set A) (zero_mem : (0 : A) \u2208 s)\n    (sub_mem : \u2200 {a b : A}, a \u2208 s \u2192 b \u2208 s \u2192 a - b \u2208 s) : IsAddSubgroup s :=\n  IsAddSubgroup.of_add_neg s zero_mem fun {x y} hx hy => by\n    simpa only [sub_eq_add_neg] using sub_mem hx hy\n#align is_add_subgroup.of_sub IsAddSubgroup.of_sub\n\n@[to_additive]\ntheorem IsSubgroup.inter {s\u2081 s\u2082 : Set G} (hs\u2081 : IsSubgroup s\u2081) (hs\u2082 : IsSubgroup s\u2082) :\n    IsSubgroup (s\u2081 \u2229 s\u2082) :=\n  { IsSubmonoid.inter hs\u2081.toIsSubmonoid hs\u2082.toIsSubmonoid with\n    inv_mem := fun hx => \u27e8hs\u2081.inv_mem hx.1, hs\u2082.inv_mem hx.2\u27e9 }\n#align is_subgroup.inter IsSubgroup.inter\n#align is_add_subgroup.inter IsAddSubgroup.inter\n\n@[to_additive]\ntheorem IsSubgroup.iInter {\u03b9 : Sort*} {s : \u03b9 \u2192 Set G} (hs : \u2200 y : \u03b9, IsSubgroup (s y)) :\n    IsSubgroup (Set.iInter s) :=\n  { IsSubmonoid.iInter fun y => (hs y).toIsSubmonoid with\n    inv_mem := fun h =>\n      Set.mem_iInter.2 fun y => IsSubgroup.inv_mem (hs _) (Set.mem_iInter.1 h y) }\n#align is_subgroup.Inter IsSubgroup.iInter\n#align is_add_subgroup.Inter IsAddSubgroup.iInter\n\n@[to_additive]\ntheorem isSubgroup_iUnion_of_directed {\u03b9 : Type*} [Nonempty \u03b9] {s : \u03b9 \u2192 Set G}\n    (hs : \u2200 i, IsSubgroup (s i)) (directed : \u2200 i j, \u2203 k, s i \u2286 s k \u2227 s j \u2286 s k) :\n    IsSubgroup (\u22c3 i, s i) :=\n  { inv_mem := fun ha =>\n      let \u27e8i, hi\u27e9 := Set.mem_iUnion.1 ha\n      Set.mem_iUnion.2 \u27e8i, (hs i).inv_mem hi\u27e9\n    toIsSubmonoid := isSubmonoid_iUnion_of_directed (fun i => (hs i).toIsSubmonoid) directed }\n#align is_subgroup_Union_of_directed isSubgroup_iUnion_of_directed\n#align is_add_subgroup_Union_of_directed isAddSubgroup_iUnion_of_directed\n\nend Group\n\nnamespace IsSubgroup\n\nopen IsSubmonoid\n\nvariable [Group G] {s : Set G} (hs : IsSubgroup s)\n\n@[to_additive]\ntheorem inv_mem_iff : a\u207b\u00b9 \u2208 s \u2194 a \u2208 s :=\n  \u27e8fun h => by simpa using hs.inv_mem h, inv_mem hs\u27e9\n#align is_subgroup.inv_mem_iff IsSubgroup.inv_mem_iff\n#align is_add_subgroup.neg_mem_iff IsAddSubgroup.neg_mem_iff\n\n@[to_additive]\ntheorem mul_mem_cancel_right (h : a \u2208 s) : b * a \u2208 s \u2194 b \u2208 s :=\n  \u27e8fun hba => by simpa using hs.mul_mem hba (hs.inv_mem h), fun hb => hs.mul_mem hb h\u27e9\n#align is_subgroup.mul_mem_cancel_right IsSubgroup.mul_mem_cancel_right\n#align is_add_subgroup.add_mem_cancel_right IsAddSubgroup.add_mem_cancel_right\n\n@[to_additive]\ntheorem mul_mem_cancel_left (h : a \u2208 s) : a * b \u2208 s \u2194 b \u2208 s :=\n  \u27e8fun hab => by simpa using hs.mul_mem (hs.inv_mem h) hab, hs.mul_mem h\u27e9\n#align is_subgroup.mul_mem_cancel_left IsSubgroup.mul_mem_cancel_left\n#align is_add_subgroup.add_mem_cancel_left IsAddSubgroup.add_mem_cancel_left\n\nend IsSubgroup\n\n/-- `IsNormalAddSubgroup (s : Set A)` expresses the fact that `s` is a normal additive subgroup\nof the additive group `A`. Important: the preferred way to say this in Lean is via bundled\nsubgroups `S : AddSubgroup A` and `hs : S.normal`, and not via this structure. -/\nstructure IsNormalAddSubgroup [AddGroup A] (s : Set A) extends IsAddSubgroup s : Prop where\n  /-- The proposition that `s` is closed under (additive) conjugation. -/\n  normal : \u2200 n \u2208 s, \u2200 g : A, g + n + -g \u2208 s\n#align is_normal_add_subgroup IsNormalAddSubgroup\n\n/-- `IsNormalSubgroup (s : Set G)` expresses the fact that `s` is a normal subgroup\nof the group `G`. Important: the preferred way to say this in Lean is via bundled\nsubgroups `S : Subgroup G` and not via this structure. -/\n@[to_additive]\nstructure IsNormalSubgroup [Group G] (s : Set G) extends IsSubgroup s : Prop where\n  /-- The proposition that `s` is closed under conjugation. -/\n  normal : \u2200 n \u2208 s, \u2200 g : G, g * n * g\u207b\u00b9 \u2208 s\n#align is_normal_subgroup IsNormalSubgroup\n\n@[to_additive]\ntheorem isNormalSubgroup_of_commGroup [CommGroup G] {s : Set G} (hs : IsSubgroup s) :\n    IsNormalSubgroup s :=\n  { hs with normal := fun n hn g => by rwa [mul_right_comm, mul_right_inv, one_mul] }\n#align is_normal_subgroup_of_comm_group isNormalSubgroup_of_commGroup\n#align is_normal_add_subgroup_of_add_comm_group isNormalAddSubgroup_of_addCommGroup\n\ntheorem Additive.isNormalAddSubgroup [Group G] {s : Set G} (hs : IsNormalSubgroup s) :\n    @IsNormalAddSubgroup (Additive G) _ s :=\n  @IsNormalAddSubgroup.mk (Additive G) _ _ (Additive.isAddSubgroup hs.toIsSubgroup)\n    (@IsNormalSubgroup.normal _ \u2039Group (Additive G)\u203a _ hs)\n    -- porting note: Lean needs help synthesising\n#align additive.is_normal_add_subgroup Additive.isNormalAddSubgroup\n\ntheorem Additive.isNormalAddSubgroup_iff [Group G] {s : Set G} :\n    @IsNormalAddSubgroup (Additive G) _ s \u2194 IsNormalSubgroup s :=\n  \u27e8by rintro \u27e8h\u2081, h\u2082\u27e9; exact @IsNormalSubgroup.mk G _ _ (Additive.isAddSubgroup_iff.1 h\u2081) @h\u2082,\n    fun h => Additive.isNormalAddSubgroup h\u27e9\n#align additive.is_normal_add_subgroup_iff Additive.isNormalAddSubgroup_iff\n\ntheorem Multiplicative.isNormalSubgroup [AddGroup A] {s : Set A} (hs : IsNormalAddSubgroup s) :\n    @IsNormalSubgroup (Multiplicative A) _ s :=\n  @IsNormalSubgroup.mk (Multiplicative A) _ _ (Multiplicative.isSubgroup hs.toIsAddSubgroup)\n    (@IsNormalAddSubgroup.normal _ \u2039AddGroup (Multiplicative A)\u203a _ hs)\n#align multiplicative.is_normal_subgroup Multiplicative.isNormalSubgroup\n\ntheorem Multiplicative.isNormalSubgroup_iff [AddGroup A] {s : Set A} :\n    @IsNormalSubgroup (Multiplicative A) _ s \u2194 IsNormalAddSubgroup s :=\n  \u27e8by\n    rintro \u27e8h\u2081, h\u2082\u27e9;\n      exact @IsNormalAddSubgroup.mk A _ _ (Multiplicative.isSubgroup_iff.1 h\u2081) @h\u2082,\n    fun h => Multiplicative.isNormalSubgroup h\u27e9\n#align multiplicative.is_normal_subgroup_iff Multiplicative.isNormalSubgroup_iff\n\nnamespace IsSubgroup\n\nvariable [Group G]\n\n-- Normal subgroup properties\n@[to_additive]\ntheorem mem_norm_comm {s : Set G} (hs : IsNormalSubgroup s) {a b : G} (hab : a * b \u2208 s) :\n    b * a \u2208 s := by\n  have h : a\u207b\u00b9 * (a * b) * a\u207b\u00b9\u207b\u00b9 \u2208 s := hs.normal (a * b) hab a\u207b\u00b9\n  simp at h; exact h\n#align is_subgroup.mem_norm_comm IsSubgroup.mem_norm_comm\n#align is_add_subgroup.mem_norm_comm IsAddSubgroup.mem_norm_comm\n\n@[to_additive]\ntheorem mem_norm_comm_iff {s : Set G} (hs : IsNormalSubgroup s) {a b : G} : a * b \u2208 s \u2194 b * a \u2208 s :=\n  \u27e8mem_norm_comm hs, mem_norm_comm hs\u27e9\n#align is_subgroup.mem_norm_comm_iff IsSubgroup.mem_norm_comm_iff\n#align is_add_subgroup.mem_norm_comm_iff IsAddSubgroup.mem_norm_comm_iff\n\n/-- The trivial subgroup -/\n@[to_additive \"the trivial additive subgroup\"]\ndef trivial (G : Type*) [Group G] : Set G :=\n  {1}\n#align is_subgroup.trivial IsSubgroup.trivial\n#align is_add_subgroup.trivial IsAddSubgroup.trivial\n\n@[to_additive (attr := simp)]\ntheorem mem_trivial {g : G} : g \u2208 trivial G \u2194 g = 1 :=\n  mem_singleton_iff\n#align is_subgroup.mem_trivial IsSubgroup.mem_trivial\n#align is_add_subgroup.mem_trivial IsAddSubgroup.mem_trivial\n\n@[to_additive]\ntheorem trivial_normal : IsNormalSubgroup (trivial G) := by\n  refine' { .. } <;> simp (config := { contextual := true }) [trivial]\n#align is_subgroup.trivial_normal IsSubgroup.trivial_normal\n#align is_add_subgroup.trivial_normal IsAddSubgroup.trivial_normal\n\n@[to_additive]\ntheorem eq_trivial_iff {s : Set G} (hs : IsSubgroup s) : s = trivial G \u2194 \u2200 x \u2208 s, x = (1 : G) := by\n  simp only [Set.ext_iff, IsSubgroup.mem_trivial];\n    exact \u27e8fun h x => (h x).1, fun h x => \u27e8h x, fun hx => hx.symm \u25b8 hs.toIsSubmonoid.one_mem\u27e9\u27e9\n#align is_subgroup.eq_trivial_iff IsSubgroup.eq_trivial_iff\n#align is_add_subgroup.eq_trivial_iff IsAddSubgroup.eq_trivial_iff\n\n@[to_additive]\ntheorem univ_subgroup : IsNormalSubgroup (@univ G) := by refine' { .. } <;> simp\n#align is_subgroup.univ_subgroup IsSubgroup.univ_subgroup\n#align is_add_subgroup.univ_add_subgroup IsAddSubgroup.univ_addSubgroup\n\n/-- The underlying set of the center of a group. -/\n@[to_additive addCenter \"The underlying set of the center of an additive group.\"]\ndef center (G : Type*) [Group G] : Set G :=\n  { z | \u2200 g, g * z = z * g }\n#align is_subgroup.center IsSubgroup.center\n#align is_add_subgroup.add_center IsAddSubgroup.addCenter\n\n@[to_additive mem_add_center]\ntheorem mem_center {a : G} : a \u2208 center G \u2194 \u2200 g, g * a = a * g :=\n  Iff.rfl\n#align is_subgroup.mem_center IsSubgroup.mem_center\n#align is_add_subgroup.mem_add_center IsAddSubgroup.mem_add_center\n\n@[to_additive add_center_normal]\ntheorem center_normal : IsNormalSubgroup (center G) :=\n  { one_mem := by simp [center]\n    mul_mem := fun ha hb g => by\n      rw [\u2190 mul_assoc, mem_center.2 ha g, mul_assoc, mem_center.2 hb g, \u2190 mul_assoc]\n    inv_mem := fun {a} ha g =>\n      calc\n        g * a\u207b\u00b9 = a\u207b\u00b9 * (g * a) * a\u207b\u00b9 := by simp [ha g]\n        _ = a\u207b\u00b9 * g := by rw [\u2190 mul_assoc, mul_assoc]; simp\n    normal := fun n ha g h =>\n      calc\n        h * (g * n * g\u207b\u00b9) = h * n := by simp [ha g, mul_assoc]\n        _ = g * g\u207b\u00b9 * n * h := by rw [ha h]; simp\n        _ = g * n * g\u207b\u00b9 * h := by rw [mul_assoc g, ha g\u207b\u00b9, \u2190 mul_assoc]\n         }\n#align is_subgroup.center_normal IsSubgroup.center_normal\n#align is_add_subgroup.add_center_normal IsAddSubgroup.add_center_normal\n\n/-- The underlying set of the normalizer of a subset `S : Set G` of a group `G`. That is,\n  the elements `g : G` such that `g * S * g\u207b\u00b9 = S`. -/\n@[to_additive addNormalizer\n      \"The underlying set of the normalizer of a subset `S : Set A` of an\n      additive group `A`. That is, the elements `a : A` such that `a + S - a = S`.\"]\ndef normalizer (s : Set G) : Set G :=\n  { g : G | \u2200 n, n \u2208 s \u2194 g * n * g\u207b\u00b9 \u2208 s }\n#align is_subgroup.normalizer IsSubgroup.normalizer\n#align is_add_subgroup.add_normalizer IsAddSubgroup.addNormalizer\n\n@[to_additive]\ntheorem normalizer_isSubgroup (s : Set G) : IsSubgroup (normalizer s) :=\n  { one_mem := by simp [normalizer]\n    mul_mem := fun {a b}\n      (ha : \u2200 n, n \u2208 s \u2194 a * n * a\u207b\u00b9 \u2208 s) (hb : \u2200 n, n \u2208 s \u2194 b * n * b\u207b\u00b9 \u2208 s) n =>\n      by rw [mul_inv_rev, \u2190 mul_assoc, mul_assoc a, mul_assoc a, \u2190 ha, \u2190 hb]\n    inv_mem := fun {a} (ha : \u2200 n, n \u2208 s \u2194 a * n * a\u207b\u00b9 \u2208 s) n => by\n      rw [ha (a\u207b\u00b9 * n * a\u207b\u00b9\u207b\u00b9)]; simp [mul_assoc] }\n#align is_subgroup.normalizer_is_subgroup IsSubgroup.normalizer_isSubgroup\n#align is_add_subgroup.normalizer_is_add_subgroup IsAddSubgroup.normalizer_isAddSubgroup\n\n@[to_additive subset_add_normalizer]\ntheorem subset_normalizer {s : Set G} (hs : IsSubgroup s) : s \u2286 normalizer s := fun g hg n => by\n  rw [IsSubgroup.mul_mem_cancel_right hs ((IsSubgroup.inv_mem_iff hs).2 hg),\n    IsSubgroup.mul_mem_cancel_left hs hg]\n#align is_subgroup.subset_normalizer IsSubgroup.subset_normalizer\n#align is_add_subgroup.subset_add_normalizer IsAddSubgroup.subset_add_normalizer\n\nend IsSubgroup\n\n-- Homomorphism subgroups\nnamespace IsGroupHom\n\nopen IsSubmonoid IsSubgroup\n\n/-- `ker f : Set G` is the underlying subset of the kernel of a map `G \u2192 H`. -/\n@[to_additive \"`ker f : Set A` is the underlying subset of the kernel of a map `A \u2192 B`\"]\ndef ker [Group H] (f : G \u2192 H) : Set G :=\n  preimage f (trivial H)\n#align is_group_hom.ker IsGroupHom.ker\n#align is_add_group_hom.ker IsAddGroupHom.ker\n\n@[to_additive]\ntheorem mem_ker [Group H] (f : G \u2192 H) {x : G} : x \u2208 ker f \u2194 f x = 1 :=\n  mem_trivial\n#align is_group_hom.mem_ker IsGroupHom.mem_ker\n#align is_add_group_hom.mem_ker IsAddGroupHom.mem_ker\n\nvariable [Group G] [Group H]\n\n@[to_additive]\ntheorem one_ker_inv {f : G \u2192 H} (hf : IsGroupHom f) {a b : G} (h : f (a * b\u207b\u00b9) = 1) :\n    f a = f b := by\n  rw [hf.map_mul, hf.map_inv] at h\n  rw [\u2190 inv_inv (f b), eq_inv_of_mul_eq_one_left h]\n#align is_group_hom.one_ker_inv IsGroupHom.one_ker_inv\n#align is_add_group_hom.zero_ker_neg IsAddGroupHom.zero_ker_neg\n\n@[to_additive]\ntheorem one_ker_inv' {f : G \u2192 H} (hf : IsGroupHom f) {a b : G} (h : f (a\u207b\u00b9 * b) = 1) :\n    f a = f b := by\n  rw [hf.map_mul, hf.map_inv] at h\n  apply inv_injective\n  rw [eq_inv_of_mul_eq_one_left h]\n#align is_group_hom.one_ker_inv' IsGroupHom.one_ker_inv'\n#align is_add_group_hom.zero_ker_neg' IsAddGroupHom.zero_ker_neg'\n\n@[to_additive]\ntheorem inv_ker_one {f : G \u2192 H} (hf : IsGroupHom f) {a b : G} (h : f a = f b) :\n    f (a * b\u207b\u00b9) = 1 := by\n  have : f a * (f b)\u207b\u00b9 = 1 := by rw [h, mul_right_inv]\n  rwa [\u2190 hf.map_inv, \u2190 hf.map_mul] at this\n#align is_group_hom.inv_ker_one IsGroupHom.inv_ker_one\n#align is_add_group_hom.neg_ker_zero IsAddGroupHom.neg_ker_zero\n\n@[to_additive]\ntheorem inv_ker_one' {f : G \u2192 H} (hf : IsGroupHom f) {a b : G} (h : f a = f b) :\n    f (a\u207b\u00b9 * b) = 1 := by\n  have : (f a)\u207b\u00b9 * f b = 1 := by rw [h, mul_left_inv]\n  rwa [\u2190 hf.map_inv, \u2190 hf.map_mul] at this\n#align is_group_hom.inv_ker_one' IsGroupHom.inv_ker_one'\n#align is_add_group_hom.neg_ker_zero' IsAddGroupHom.neg_ker_zero'\n\n@[to_additive]\ntheorem one_iff_ker_inv {f : G \u2192 H} (hf : IsGroupHom f) (a b : G) : f a = f b \u2194 f (a * b\u207b\u00b9) = 1 :=\n  \u27e8hf.inv_ker_one, hf.one_ker_inv\u27e9\n#align is_group_hom.one_iff_ker_inv IsGroupHom.one_iff_ker_inv\n#align is_add_group_hom.zero_iff_ker_neg IsAddGroupHom.zero_iff_ker_neg\n\n@[to_additive]\ntheorem one_iff_ker_inv' {f : G \u2192 H} (hf : IsGroupHom f) (a b : G) : f a = f b \u2194 f (a\u207b\u00b9 * b) = 1 :=\n  \u27e8hf.inv_ker_one', hf.one_ker_inv'\u27e9\n#align is_group_hom.one_iff_ker_inv' IsGroupHom.one_iff_ker_inv'\n#align is_add_group_hom.zero_iff_ker_neg' IsAddGroupHom.zero_iff_ker_neg'\n\n@[to_additive]\ntheorem inv_iff_ker {f : G \u2192 H} (hf : IsGroupHom f) (a b : G) : f a = f b \u2194 a * b\u207b\u00b9 \u2208 ker f := by\n  rw [mem_ker]; exact one_iff_ker_inv hf _ _\n#align is_group_hom.inv_iff_ker IsGroupHom.inv_iff_ker\n#align is_add_group_hom.neg_iff_ker IsAddGroupHom.neg_iff_ker\n\n@[to_additive]\ntheorem inv_iff_ker' {f : G \u2192 H} (hf : IsGroupHom f) (a b : G) : f a = f b \u2194 a\u207b\u00b9 * b \u2208 ker f := by\n  rw [mem_ker]; exact one_iff_ker_inv' hf _ _\n#align is_group_hom.inv_iff_ker' IsGroupHom.inv_iff_ker'\n#align is_add_group_hom.neg_iff_ker' IsAddGroupHom.neg_iff_ker'\n\n@[to_additive]\ntheorem image_subgroup {f : G \u2192 H} (hf : IsGroupHom f) {s : Set G} (hs : IsSubgroup s) :\n    IsSubgroup (f '' s) :=\n  { mul_mem := fun {a\u2081 a\u2082} \u27e8b\u2081, hb\u2081, eq\u2081\u27e9 \u27e8b\u2082, hb\u2082, eq\u2082\u27e9 =>\n      \u27e8b\u2081 * b\u2082, hs.mul_mem hb\u2081 hb\u2082, by simp [eq\u2081, eq\u2082, hf.map_mul]\u27e9\n    one_mem := \u27e81, hs.toIsSubmonoid.one_mem, hf.map_one\u27e9\n    inv_mem := fun {a} \u27e8b, hb, Eq\u27e9 =>\n      \u27e8b\u207b\u00b9, hs.inv_mem hb, by\n        rw [hf.map_inv]\n        simp [*]\u27e9 }\n#align is_group_hom.image_subgroup IsGroupHom.image_subgroup\n#align is_add_group_hom.image_add_subgroup IsAddGroupHom.image_addSubgroup\n\n@[to_additive]\ntheorem range_subgroup {f : G \u2192 H} (hf : IsGroupHom f) : IsSubgroup (Set.range f) :=\n  @Set.image_univ _ _ f \u25b8 hf.image_subgroup univ_subgroup.toIsSubgroup\n#align is_group_hom.range_subgroup IsGroupHom.range_subgroup\n#align is_add_group_hom.range_add_subgroup IsAddGroupHom.range_addSubgroup\n\nattribute [local simp] IsSubmonoid.one_mem IsSubgroup.inv_mem\n  IsSubmonoid.mul_mem IsNormalSubgroup.normal\n\n@[to_additive]\ntheorem preimage {f : G \u2192 H} (hf : IsGroupHom f) {s : Set H} (hs : IsSubgroup s) :\n    IsSubgroup (f \u207b\u00b9' s) := by\n  refine' { .. } <;>\n    simp (config := { contextual := true }) [hs.one_mem, hs.mul_mem, hs.inv_mem, hf.map_mul,\n      hf.map_one, hf.map_inv, InvMemClass.inv_mem]\n#align is_group_hom.preimage IsGroupHom.preimage\n#align is_add_group_hom.preimage IsAddGroupHom.preimage\n\n@[to_additive]\ntheorem preimage_normal {f : G \u2192 H} (hf : IsGroupHom f) {s : Set H} (hs : IsNormalSubgroup s) :\n    IsNormalSubgroup (f \u207b\u00b9' s) :=\n  { one_mem := by simp [hf.map_one, hs.toIsSubgroup.one_mem]\n    mul_mem := by simp (config := { contextual := true }) [hf.map_mul, hs.toIsSubgroup.mul_mem]\n    inv_mem := by simp (config := { contextual := true }) [hf.map_inv, hs.toIsSubgroup.inv_mem]\n    normal := by simp (config := { contextual := true }) [hs.normal, hf.map_mul, hf.map_inv] }\n#align is_group_hom.preimage_normal IsGroupHom.preimage_normal\n#align is_add_group_hom.preimage_normal IsAddGroupHom.preimage_normal\n\n@[to_additive]\ntheorem isNormalSubgroup_ker {f : G \u2192 H} (hf : IsGroupHom f) : IsNormalSubgroup (ker f) :=\n  hf.preimage_normal trivial_normal\n#align is_group_hom.is_normal_subgroup_ker IsGroupHom.isNormalSubgroup_ker\n#align is_add_group_hom.is_normal_add_subgroup_ker IsAddGroupHom.isNormalAddSubgroup_ker\n\n@[to_additive]\ntheorem injective_of_trivial_ker {f : G \u2192 H} (hf : IsGroupHom f) (h : ker f = trivial G) :\n    Function.Injective f := by\n  intro a\u2081 a\u2082 hfa\n  simp [ext_iff, ker, IsSubgroup.trivial] at h\n  have ha : a\u2081 * a\u2082\u207b\u00b9 = 1 := by rw [\u2190 h]; exact hf.inv_ker_one hfa\n  rw [eq_inv_of_mul_eq_one_left ha, inv_inv a\u2082]\n#align is_group_hom.injective_of_trivial_ker IsGroupHom.injective_of_trivial_ker\n#align is_add_group_hom.injective_of_trivial_ker IsAddGroupHom.injective_of_trivial_ker\n\n@[to_additive]\ntheorem trivial_ker_of_injective {f : G \u2192 H} (hf : IsGroupHom f) (h : Function.Injective f) :\n    ker f = trivial G :=\n  Set.ext fun x =>\n    Iff.intro\n      (fun hx => by\n        suffices f x = f 1 by simpa using h this\n        simp [hf.map_one]; rwa [mem_ker] at hx)\n      (by simp (config := { contextual := true }) [mem_ker, hf.map_one])\n#align is_group_hom.trivial_ker_of_injective IsGroupHom.trivial_ker_of_injective\n#align is_add_group_hom.trivial_ker_of_injective IsAddGroupHom.trivial_ker_of_injective\n\n@[to_additive]\ntheorem injective_iff_trivial_ker {f : G \u2192 H} (hf : IsGroupHom f) :\n    Function.Injective f \u2194 ker f = trivial G :=\n  \u27e8hf.trivial_ker_of_injective, hf.injective_of_trivial_ker\u27e9\n#align is_group_hom.injective_iff_trivial_ker IsGroupHom.injective_iff_trivial_ker\n#align is_add_group_hom.injective_iff_trivial_ker IsAddGroupHom.injective_iff_trivial_ker\n\n@[to_additive]\ntheorem trivial_ker_iff_eq_one {f : G \u2192 H} (hf : IsGroupHom f) :\n    ker f = trivial G \u2194 \u2200 x, f x = 1 \u2192 x = 1 := by\n  rw [Set.ext_iff]; simp [ker];\n    exact \u27e8fun h x hx => (h x).1 hx, fun h x => \u27e8h x, fun hx => by rw [hx, hf.map_one]\u27e9\u27e9\n#align is_group_hom.trivial_ker_iff_eq_one IsGroupHom.trivial_ker_iff_eq_one\n#align is_add_group_hom.trivial_ker_iff_eq_zero IsAddGroupHom.trivial_ker_iff_eq_zero\n\nend IsGroupHom\n\nnamespace AddGroup\n\nvariable [AddGroup A]\n\n/-- If `A` is an additive group and `s : Set A`, then `InClosure s : Set A` is the underlying\nsubset of the subgroup generated by `s`. -/\ninductive InClosure (s : Set A) : A \u2192 Prop\n  | basic {a : A} : a \u2208 s \u2192 InClosure s a\n  | zero : InClosure s 0\n  | neg {a : A} : InClosure s a \u2192 InClosure s (-a)\n  | add {a b : A} : InClosure s a \u2192 InClosure s b \u2192 InClosure s (a + b)\n#align add_group.in_closure AddGroup.InClosure\n\nend AddGroup\n\nnamespace Group\n\nopen IsSubmonoid IsSubgroup\n\nvariable [Group G] {s : Set G}\n\n/-- If `G` is a group and `s : Set G`, then `InClosure s : Set G` is the underlying\nsubset of the subgroup generated by `s`. -/\n@[to_additive]\ninductive InClosure (s : Set G) : G \u2192 Prop\n  | basic {a : G} : a \u2208 s \u2192 InClosure s a\n  | one : InClosure s 1\n  | inv {a : G} : InClosure s a \u2192 InClosure s a\u207b\u00b9\n  | mul {a b : G} : InClosure s a \u2192 InClosure s b \u2192 InClosure s (a * b)\n#align group.in_closure Group.InClosure\n\n/-- `Group.closure s` is the subgroup generated by `s`, i.e. the smallest subgroup containing `s`.\n-/\n@[to_additive\n  \"`AddGroup.closure s` is the additive subgroup generated by `s`, i.e., the\n  smallest additive subgroup containing `s`.\"]\ndef closure (s : Set G) : Set G :=\n  { a | InClosure s a }\n#align group.closure Group.closure\n#align add_group.closure AddGroup.closure\n\n@[to_additive]\ntheorem mem_closure {a : G} : a \u2208 s \u2192 a \u2208 closure s :=\n  InClosure.basic\n#align group.mem_closure Group.mem_closure\n#align add_group.mem_closure AddGroup.mem_closure\n\n@[to_additive]\ntheorem closure.isSubgroup (s : Set G) : IsSubgroup (closure s) :=\n  { one_mem := InClosure.one\n    mul_mem := InClosure.mul\n    inv_mem := InClosure.inv }\n#align group.closure.is_subgroup Group.closure.isSubgroup\n#align add_group.closure.is_add_subgroup AddGroup.closure.isAddSubgroup\n\n@[to_additive]\ntheorem subset_closure {s : Set G} : s \u2286 closure s := fun _ => mem_closure\n#align group.subset_closure Group.subset_closure\n#align add_group.subset_closure AddGroup.subset_closure\n\n@[to_additive]\ntheorem closure_subset {s t : Set G} (ht : IsSubgroup t) (h : s \u2286 t) : closure s \u2286 t := fun a ha =>\n  by induction ha <;> simp [h _, *, ht.one_mem, ht.mul_mem, IsSubgroup.inv_mem_iff]\n#align group.closure_subset Group.closure_subset\n#align add_group.closure_subset AddGroup.closure_subset\n\n@[to_additive]\ntheorem closure_subset_iff {s t : Set G} (ht : IsSubgroup t) : closure s \u2286 t \u2194 s \u2286 t :=\n  \u27e8fun h _ ha => h (mem_closure ha), fun h _ ha => closure_subset ht h ha\u27e9\n#align group.closure_subset_iff Group.closure_subset_iff\n#align add_group.closure_subset_iff AddGroup.closure_subset_iff\n\n@[to_additive]\ntheorem closure_mono {s t : Set G} (h : s \u2286 t) : closure s \u2286 closure t :=\n  closure_subset (closure.isSubgroup _) <| Set.Subset.trans h subset_closure\n#align group.closure_mono Group.closure_mono\n#align add_group.closure_mono AddGroup.closure_mono\n\n@[to_additive (attr := simp)]\ntheorem closure_subgroup {s : Set G} (hs : IsSubgroup s) : closure s = s :=\n  Set.Subset.antisymm (closure_subset hs <| Set.Subset.refl s) subset_closure\n#align group.closure_subgroup Group.closure_subgroup\n#align add_group.closure_add_subgroup AddGroup.closure_addSubgroup\n\n@[to_additive]\ntheorem exists_list_of_mem_closure {s : Set G} {a : G} (h : a \u2208 closure s) :\n    \u2203 l : List G, (\u2200 x \u2208 l, x \u2208 s \u2228 x\u207b\u00b9 \u2208 s) \u2227 l.prod = a :=\n  InClosure.recOn h (fun {x} hxs => \u27e8[x], List.forall_mem_singleton.2 <| Or.inl hxs, one_mul _\u27e9)\n    \u27e8[], List.forall_mem_nil _, rfl\u27e9\n    (fun {x} _ \u27e8L, HL1, HL2\u27e9 =>\n      \u27e8L.reverse.map Inv.inv, fun x hx =>\n        let \u27e8y, hy1, hy2\u27e9 := List.exists_of_mem_map hx\n        hy2 \u25b8 Or.imp id (by rw [inv_inv]; exact id) (HL1 _ <| List.mem_reverse.1 hy1).symm,\n        HL2 \u25b8\n          List.recOn L inv_one.symm fun hd tl ih => by\n            rw [List.reverse_cons, List.map_append, List.prod_append, ih, List.map_singleton,\n              List.prod_cons, List.prod_nil, mul_one, List.prod_cons, mul_inv_rev]\u27e9)\n    fun {x y} _ _ \u27e8L1, HL1, HL2\u27e9 \u27e8L2, HL3, HL4\u27e9 =>\n    \u27e8L1 ++ L2, List.forall_mem_append.2 \u27e8HL1, HL3\u27e9, by rw [List.prod_append, HL2, HL4]\u27e9\n#align group.exists_list_of_mem_closure Group.exists_list_of_mem_closure\n#align add_group.exists_list_of_mem_closure AddGroup.exists_list_of_mem_closure\n\n@[to_additive]\ntheorem image_closure [Group H] {f : G \u2192 H} (hf : IsGroupHom f) (s : Set G) :\n    f '' closure s = closure (f '' s) :=\n  le_antisymm\n    (by\n      rintro _ \u27e8x, hx, rfl\u27e9\n      exact InClosure.recOn hx\n        (by intros _ ha; exact subset_closure (mem_image_of_mem f ha))\n        (by\n          rw [hf.map_one]\n          apply IsSubmonoid.one_mem (closure.isSubgroup _).toIsSubmonoid)\n        (by\n          intros _ _\n          rw [hf.map_inv]\n          apply IsSubgroup.inv_mem (closure.isSubgroup _))\n        (by\n          intros _ _ _ _ ha hb\n          rw [hf.map_mul]\n          exact (closure.isSubgroup (f '' s)).toIsSubmonoid.mul_mem ha hb))\n    (closure_subset (hf.image_subgroup <| closure.isSubgroup _) <|\n      Set.image_subset _ subset_closure)\n#align group.image_closure Group.image_closure\n#align add_group.image_closure AddGroup.image_closure\n\n@[to_additive]\ntheorem mclosure_subset {s : Set G} : Monoid.Closure s \u2286 closure s :=\n  Monoid.closure_subset (closure.isSubgroup _).toIsSubmonoid <| subset_closure\n#align group.mclosure_subset Group.mclosure_subset\n#align add_group.mclosure_subset AddGroup.mclosure_subset\n\n@[to_additive]\ntheorem mclosure_inv_subset {s : Set G} : Monoid.Closure (Inv.inv \u207b\u00b9' s) \u2286 closure s :=\n  Monoid.closure_subset (closure.isSubgroup _).toIsSubmonoid fun x hx =>\n    inv_inv x \u25b8 ((closure.isSubgroup _).inv_mem <| subset_closure hx)\n#align group.mclosure_inv_subset Group.mclosure_inv_subset\n#align add_group.mclosure_neg_subset AddGroup.mclosure_neg_subset\n\n@[to_additive]\ntheorem closure_eq_mclosure {s : Set G} : closure s = Monoid.Closure (s \u222a Inv.inv \u207b\u00b9' s) :=\n  Set.Subset.antisymm\n    (@closure_subset _ _ _ (Monoid.Closure (s \u222a Inv.inv \u207b\u00b9' s))\n      { one_mem := (Monoid.closure.isSubmonoid _).one_mem\n        mul_mem := (Monoid.closure.isSubmonoid _).mul_mem\n        inv_mem := fun hx =>\n          Monoid.InClosure.recOn hx\n            (fun {x} hx =>\n              Or.casesOn hx\n                (fun hx =>\n                  Monoid.subset_closure <| Or.inr <| show x\u207b\u00b9\u207b\u00b9 \u2208 s from (inv_inv x).symm \u25b8 hx)\n                fun hx => Monoid.subset_closure <| Or.inl hx)\n            ((@inv_one G _).symm \u25b8 IsSubmonoid.one_mem (Monoid.closure.isSubmonoid _))\n            fun {x y} _ _ ihx ihy =>\n            (mul_inv_rev x y).symm \u25b8 IsSubmonoid.mul_mem (Monoid.closure.isSubmonoid _) ihy ihx }\n      (Set.Subset.trans (Set.subset_union_left _ _) Monoid.subset_closure))\n    (Monoid.closure_subset (closure.isSubgroup _).toIsSubmonoid <|\n      Set.union_subset subset_closure fun x hx =>\n        inv_inv x \u25b8 (IsSubgroup.inv_mem (closure.isSubgroup _) <| subset_closure hx))\n#align group.closure_eq_mclosure Group.closure_eq_mclosure\n#align add_group.closure_eq_mclosure AddGroup.closure_eq_mclosure\n\n@[to_additive]\ntheorem mem_closure_union_iff {G : Type*} [CommGroup G] {s t : Set G} {x : G} :\n    x \u2208 closure (s \u222a t) \u2194 \u2203 y \u2208 closure s, \u2203 z \u2208 closure t, y * z = x := by\n  simp only [closure_eq_mclosure, Monoid.mem_closure_union_iff, exists_prop, preimage_union];\n  constructor\n  \u00b7 rintro \u27e8_, \u27e8ys, hys, yt, hyt, rfl\u27e9, _, \u27e8zs, hzs, zt, hzt, rfl\u27e9, rfl\u27e9\n    refine' \u27e8_, \u27e8_, hys, _, hzs, rfl\u27e9, _, \u27e8_, hyt, _, hzt, rfl\u27e9, _\u27e9\n    rw [mul_assoc, mul_assoc, mul_left_comm zs]\n  \u00b7 rintro \u27e8_, \u27e8ys, hys, zs, hzs, rfl\u27e9, _, \u27e8yt, hyt, zt, hzt, rfl\u27e9, rfl\u27e9\n    refine' \u27e8_, \u27e8ys, hys, yt, hyt, rfl\u27e9, _, \u27e8zs, hzs, zt, hzt, rfl\u27e9, _\u27e9\n    rw [mul_assoc, mul_assoc, mul_left_comm yt]\n#align group.mem_closure_union_iff Group.mem_closure_union_iff\n#align add_group.mem_closure_union_iff AddGroup.mem_closure_union_iff\n\nend Group\n\nnamespace IsSubgroup\n\nvariable [Group G]\n\n@[to_additive]\ntheorem trivial_eq_closure : trivial G = Group.closure \u2205 :=\n  Subset.antisymm (by simp [Set.subset_def, (Group.closure.isSubgroup _).one_mem])\n    (Group.closure_subset trivial_normal.toIsSubgroup <| by simp)\n#align is_subgroup.trivial_eq_closure IsSubgroup.trivial_eq_closure\n#align is_add_subgroup.trivial_eq_closure IsAddSubgroup.trivial_eq_closure\n\nend IsSubgroup\n\n/-The normal closure of a set s is the subgroup closure of all the conjugates of\nelements of s. It is the smallest normal subgroup containing s. -/\nnamespace Group\n\nvariable {s : Set G} [Group G]\n\ntheorem conjugatesOf_subset {t : Set G} (ht : IsNormalSubgroup t) {a : G} (h : a \u2208 t) :\n    conjugatesOf a \u2286 t := fun x hc => by\n  obtain \u27e8c, w\u27e9 := isConj_iff.1 hc\n  have H := IsNormalSubgroup.normal ht a h c\n  rwa [\u2190 w]\n#align group.conjugates_of_subset Group.conjugatesOf_subset\n\ntheorem conjugatesOfSet_subset' {s t : Set G} (ht : IsNormalSubgroup t) (h : s \u2286 t) :\n    conjugatesOfSet s \u2286 t :=\n  Set.iUnion\u2082_subset fun _ H => conjugatesOf_subset ht (h H)\n#align group.conjugates_of_set_subset' Group.conjugatesOfSet_subset'\n\n/-- The normal closure of a set s is the subgroup closure of all the conjugates of\nelements of s. It is the smallest normal subgroup containing s. -/\ndef normalClosure (s : Set G) : Set G :=\n  closure (conjugatesOfSet s)\n#align group.normal_closure Group.normalClosure\n\ntheorem conjugatesOfSet_subset_normalClosure : conjugatesOfSet s \u2286 normalClosure s :=\n  subset_closure\n#align group.conjugates_of_set_subset_normal_closure Group.conjugatesOfSet_subset_normalClosure\n\ntheorem subset_normalClosure : s \u2286 normalClosure s :=\n  Set.Subset.trans subset_conjugatesOfSet conjugatesOfSet_subset_normalClosure\n#align group.subset_normal_closure Group.subset_normalClosure\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem normalClosure.isSubgroup (s : Set G) : IsSubgroup (normalClosure s) :=\n  closure.isSubgroup (conjugatesOfSet s)\n#align group.normal_closure.is_subgroup Group.normalClosure.isSubgroup\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem normalClosure.is_normal : IsNormalSubgroup (normalClosure s) :=\n  { normalClosure.isSubgroup _ with\n    normal := fun n h g => by\n      induction' h with x hx x hx ihx x y hx hy ihx ihy\n      \u00b7 exact conjugatesOfSet_subset_normalClosure (conj_mem_conjugatesOfSet hx)\n      \u00b7 simpa using (normalClosure.isSubgroup s).one_mem\n      \u00b7 rw [\u2190 conj_inv]\n        exact (normalClosure.isSubgroup _).inv_mem ihx\n      \u00b7 rw [\u2190 conj_mul]\n        exact (normalClosure.isSubgroup _).toIsSubmonoid.mul_mem ihx ihy }\n#align group.normal_closure.is_normal Group.normalClosure.is_normal\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem normalClosure_subset {s t : Set G} (ht : IsNormalSubgroup t) (h : s \u2286 t) :\n    normalClosure s \u2286 t := fun a w => by\n  induction' w with x hx x _ ihx x y _ _ ihx ihy\n  \u00b7 exact conjugatesOfSet_subset' ht h <| hx\n  \u00b7 exact ht.toIsSubgroup.toIsSubmonoid.one_mem\n  \u00b7 exact ht.toIsSubgroup.inv_mem ihx\n  \u00b7 exact ht.toIsSubgroup.toIsSubmonoid.mul_mem ihx ihy\n#align group.normal_closure_subset Group.normalClosure_subset\n\ntheorem normalClosure_subset_iff {s t : Set G} (ht : IsNormalSubgroup t) :\n    s \u2286 t \u2194 normalClosure s \u2286 t :=\n  \u27e8normalClosure_subset ht, Set.Subset.trans subset_normalClosure\u27e9\n#align group.normal_closure_subset_iff Group.normalClosure_subset_iff\n\ntheorem normalClosure_mono {s t : Set G} : s \u2286 t \u2192 normalClosure s \u2286 normalClosure t := fun h =>\n  normalClosure_subset normalClosure.is_normal (Set.Subset.trans h subset_normalClosure)\n#align group.normal_closure_mono Group.normalClosure_mono\n\nend Group\n\n/-- Create a bundled subgroup from a set `s` and `[IsSubgroup s]`. -/\n@[to_additive \"Create a bundled additive subgroup from a set `s` and `[IsAddSubgroup s]`.\"]\ndef Subgroup.of [Group G] {s : Set G} (h : IsSubgroup s) : Subgroup G\n    where\n  carrier := s\n  one_mem' := h.1.1\n  mul_mem' := h.1.2\n  inv_mem' := h.2\n#align subgroup.of Subgroup.of\n#align add_subgroup.of AddSubgroup.of\n\n@[to_additive]\ntheorem Subgroup.isSubgroup [Group G] (K : Subgroup G) : IsSubgroup (K : Set G) :=\n  { one_mem := K.one_mem'\n    mul_mem := K.mul_mem'\n    inv_mem := K.inv_mem' }\n#align subgroup.is_subgroup Subgroup.isSubgroup\n#align add_subgroup.is_add_subgroup AddSubgroup.isAddSubgroup\n\n-- this will never fire if it's an instance\n@[to_additive]\ntheorem Subgroup.of_normal [Group G] (s : Set G) (h : IsSubgroup s) (n : IsNormalSubgroup s) :\n    Subgroup.Normal (Subgroup.of h) :=\n  { conj_mem := n.normal }\n#align subgroup.of_normal Subgroup.of_normal\n#align add_subgroup.of_normal AddSubgroup.of_normal\n"}, {"text": "/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\nimport Mathlib.Algebra.Star.Pi\nimport Mathlib.Algebra.Star.Prod\nimport Mathlib.Topology.Algebra.Constructions\nimport Mathlib.Topology.ContinuousFunction.Basic\n\n#align_import topology.algebra.star from \"leanprover-community/mathlib\"@\"4c19a16e4b705bf135cf9a80ac18fcc99c438514\"\n\n/-!\n# Continuity of `star`\n\nThis file defines the `ContinuousStar` typeclass, along with instances on `Pi`, `Prod`,\n`MulOpposite`, and `Units`.\n-/\n\nset_option autoImplicit true\n\nopen Filter Topology\n\n/-- Basic hypothesis to talk about a topological space with a continuous `star` operator. -/\nclass ContinuousStar (R : Type*) [TopologicalSpace R] [Star R] : Prop where\n  /-- The `star` operator is continuous. -/\n  continuous_star : Continuous (star : R \u2192 R)\n#align has_continuous_star ContinuousStar\n\nexport ContinuousStar (continuous_star)\n\nsection Continuity\n\nvariable [TopologicalSpace R] [Star R] [ContinuousStar R]\n\ntheorem continuousOn_star {s : Set R} : ContinuousOn star s :=\n  continuous_star.continuousOn\n#align continuous_on_star continuousOn_star\n\ntheorem continuousWithinAt_star {s : Set R} {x : R} : ContinuousWithinAt star s x :=\n  continuous_star.continuousWithinAt\n#align continuous_within_at_star continuousWithinAt_star\n\ntheorem continuousAt_star {x : R} : ContinuousAt star x :=\n  continuous_star.continuousAt\n#align continuous_at_star continuousAt_star\n\ntheorem tendsto_star (a : R) : Tendsto star (\ud835\udcdd a) (\ud835\udcdd (star a)) :=\n  continuousAt_star\n#align tendsto_star tendsto_star\n\ntheorem Filter.Tendsto.star {f : \u03b1 \u2192 R} {l : Filter \u03b1} {y : R} (h : Tendsto f l (\ud835\udcdd y)) :\n    Tendsto (fun x => star (f x)) l (\ud835\udcdd (star y)) :=\n  (continuous_star.tendsto y).comp h\n#align filter.tendsto.star Filter.Tendsto.star\n\nvariable [TopologicalSpace \u03b1] {f : \u03b1 \u2192 R} {s : Set \u03b1} {x : \u03b1}\n\n@[continuity]\ntheorem Continuous.star (hf : Continuous f) : Continuous fun x => star (f x) :=\n  continuous_star.comp hf\n#align continuous.star Continuous.star\n\ntheorem ContinuousAt.star (hf : ContinuousAt f x) : ContinuousAt (fun x => star (f x)) x :=\n  continuousAt_star.comp hf\n#align continuous_at.star ContinuousAt.star\n\ntheorem ContinuousOn.star (hf : ContinuousOn f s) : ContinuousOn (fun x => star (f x)) s :=\n  continuous_star.comp_continuousOn hf\n#align continuous_on.star ContinuousOn.star\n\ntheorem ContinuousWithinAt.star (hf : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (fun x => star (f x)) s x :=\n  Filter.Tendsto.star hf\n#align continuous_within_at.star ContinuousWithinAt.star\n\n/-- The star operation bundled as a continuous map. -/\n@[simps]\ndef starContinuousMap : C(R, R) :=\n  \u27e8star, continuous_star\u27e9\n#align star_continuous_map starContinuousMap\n\nend Continuity\n\nsection Instances\n\ninstance [Star R] [Star S] [TopologicalSpace R] [TopologicalSpace S] [ContinuousStar R]\n    [ContinuousStar S] : ContinuousStar (R \u00d7 S) :=\n  \u27e8(continuous_star.comp continuous_fst).prod_mk (continuous_star.comp continuous_snd)\u27e9\n\ninstance {C : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (C i)] [\u2200 i, Star (C i)]\n    [\u2200 i, ContinuousStar (C i)] : ContinuousStar (\u2200 i, C i) where\n  continuous_star := continuous_pi fun i => Continuous.star (continuous_apply i)\n\ninstance [Star R] [TopologicalSpace R] [ContinuousStar R] : ContinuousStar R\u1d50\u1d52\u1d56 :=\n  \u27e8MulOpposite.continuous_op.comp <| MulOpposite.continuous_unop.star\u27e9\n\ninstance [Monoid R] [StarMul R] [TopologicalSpace R] [ContinuousStar R] :\n    ContinuousStar R\u02e3 :=\n  \u27e8continuous_induced_rng.2 Units.continuous_embedProduct.star\u27e9\n\nend Instances\n"}]