"{\"text\": \"/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\nimport Mathlib.CategoryTheory.EqToHom\n\n#align_import category_theory.sums.basic from \"leanprover-community/mathlib\"@\"dc6c365e751e34d100e80fe6e314c3c3e0fd2988\"\n\n/-!\n# Binary disjoint unions of categories\n\nWe define the category instance on `C ⊕ D` when `C` and `D` are categories.\n\nWe define:\n* `inl_`      : the functor `C ⥤ C ⊕ D`\n* `inr_`      : the functor `D ⥤ C ⊕ D`\n* `swap`      : the functor `C ⊕ D ⥤ D ⊕ C`\n    (and the fact this is an equivalence)\n\nWe further define sums of functors and natural transformations, written `F.sum G` and `α.sum β`.\n-/\n\n\nnamespace CategoryTheory\n\nuniverse v₁ u₁\n\n-- morphism levels before object levels. See note [category_theory universes].\nopen Sum\n\nsection\n\nvariable (C : Type u₁) [Category.{v₁} C] (D : Type u₁) [Category.{v₁} D]\n\n/- Porting note: `aesop_cat` not firing on `assoc` where autotac in Lean 3 did-/\n\n/-- `sum C D` gives the direct sum of two categories.\n-/\ninstance sum : Category.{v₁} (Sum C D) where\n  Hom X Y :=\n    match X, Y with\n    | inl X, inl Y => X ⟶ Y\n    | inl _, inr _ => PEmpty\n    | inr _, inl _ => PEmpty\n    | inr X, inr Y => X ⟶ Y\n  id X :=\n    match X with\n    | inl X => 𝟙 X\n    | inr X => 𝟙 X\n  comp := @fun X Y Z f g =>\n    match X, Y, Z, f, g with\n    | inl X, inl Y, inl Z, f, g => f ≫ g\n    | inr X, inr Y, inr Z, f, g => f ≫ g\n  assoc := @fun W X Y Z f g h =>\n    match X, Y, Z, W with\n    | inl X, inl Y, inl Z, inl W => Category.assoc f g h\n    | inr X, inr Y, inr Z, inr W => Category.assoc f g h\n#align category_theory.sum CategoryTheory.sum\n\n/- Porting note: seems similar to Mathlib4#1036 issue so marked as nolint  -/\n@[simp, nolint simpComm]\ntheorem sum_comp_inl {P Q R : C} (f : (inl P : Sum C D) ⟶ inl Q) (g : (inl Q : Sum C D) ⟶ inl R) :\n    @CategoryStruct.comp _ _ P Q R (f : P ⟶ Q) (g : Q ⟶ R) =\n      @CategoryStruct.comp _ _ (inl P) (inl Q) (inl R) (f : P ⟶ Q) (g : Q ⟶ R) :=\n  rfl\n#align category_theory.sum_comp_inl CategoryTheory.sum_comp_inl\n\n/- Porting note: seems similar to Mathlib4#1036 issue so marked as nolint  -/\n@[simp, nolint simpComm]\ntheorem sum_comp_inr {P Q R : D} (f : (inr P : Sum C D) ⟶ inr Q) (g : (inr Q : Sum C D) ⟶ inr R) :\n    @CategoryStruct.comp _ _ P Q R (f : P ⟶ Q) (g : Q ⟶ R) =\n      @CategoryStruct.comp _ _ (inr P) (inr Q) (inr R) (f : P ⟶ Q) (g : Q ⟶ R) :=\n  rfl\n#align category_theory.sum_comp_inr CategoryTheory.sum_comp_inr\n\nend\n\nnamespace Sum\n\nvariable (C : Type u₁) [Category.{v₁} C] (D : Type u₁) [Category.{v₁} D]\n\n-- Unfortunate naming here, suggestions welcome.\n/-- `inl_` is the functor `X ↦ inl X`. -/\n@[simps]\ndef inl_ : C ⥤ Sum C D where\n  obj X := inl X\n  map := @fun X Y f => f\n#align category_theory.sum.inl_ CategoryTheory.Sum.inl_\n\n/-- `inr_` is the functor `X ↦ inr X`. -/\n@[simps]\ndef inr_ : D ⥤ Sum C D where\n  obj X := inr X\n  map := @fun X Y f => f\n#align category_theory.sum.inr_ CategoryTheory.Sum.inr_\n\n/- Porting note: `aesop_cat` not firing on `map_comp` where autotac in Lean 3 did\nbut `map_id` was ok. -/\n\n/-- The functor exchanging two direct summand categories. -/\ndef swap : Sum C D ⥤ Sum D C where\n  obj X :=\n    match X with\n    | inl X => inr X\n    | inr X => inl X\n  map := @fun X Y f =>\n    match X, Y, f with\n    | inl _, inl _, f => f\n    | inr _, inr _, f => f\n  map_comp := fun {X} {Y} {Z} _ _ =>\n    match X, Y, Z with\n    | inl X, inl Y, inl Z => by rfl\n    | inr X, inr Y, inr Z => by rfl\n#align category_theory.sum.swap CategoryTheory.Sum.swap\n\n@[simp]\ntheorem swap_obj_inl (X : C) : (swap C D).obj (inl X) = inr X :=\n  rfl\n#align category_theory.sum.swap_obj_inl CategoryTheory.Sum.swap_obj_inl\n\n@[simp]\ntheorem swap_obj_inr (X : D) : (swap C D).obj (inr X) = inl X :=\n  rfl\n#align category_theory.sum.swap_obj_inr CategoryTheory.Sum.swap_obj_inr\n\n@[simp]\ntheorem swap_map_inl {X Y : C} {f : inl X ⟶ inl Y} : (swap C D).map f = f :=\n  rfl\n#align category_theory.sum.swap_map_inl CategoryTheory.Sum.swap_map_inl\n\n@[simp]\ntheorem swap_map_inr {X Y : D} {f : inr X ⟶ inr Y} : (swap C D).map f = f :=\n  rfl\n#align category_theory.sum.swap_map_inr CategoryTheory.Sum.swap_map_inr\n\nnamespace Swap\n\n/- Porting note: had to manually call `cases f` for `f : PEmpty` -/\n\n/-- `swap` gives an equivalence between `C ⊕ D` and `D ⊕ C`. -/\ndef equivalence : Sum C D ≌ Sum D C :=\n  Equivalence.mk (swap C D) (swap D C)\n    (NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl))\n      (by simp only [swap]; aesop_cat_nonterminal; cases f; cases f))\n    (NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl))\n      (by simp only [swap]; aesop_cat_nonterminal; cases f; cases f))\n#align category_theory.sum.swap.equivalence CategoryTheory.Sum.Swap.equivalence\n\ninstance isEquivalence : IsEquivalence (swap C D) :=\n  (by infer_instance : IsEquivalence (equivalence C D).functor)\n#align category_theory.sum.swap.is_equivalence CategoryTheory.Sum.Swap.isEquivalence\n\n/-- The double swap on `C ⊕ D` is naturally isomorphic to the identity functor. -/\ndef symmetry : swap C D ⋙ swap D C ≅ 𝟭 (Sum C D) :=\n  (equivalence C D).unitIso.symm\n#align category_theory.sum.swap.symmetry CategoryTheory.Sum.Swap.symmetry\n\nend Swap\n\nend Sum\n\nvariable {A : Type u₁} [Category.{v₁} A] {B : Type u₁} [Category.{v₁} B] {C : Type u₁}\n  [Category.{v₁} C] {D : Type u₁} [Category.{v₁} D]\n\nnamespace Functor\n\n/-- The sum of two functors. -/\ndef sum (F : A ⥤ B) (G : C ⥤ D) : Sum A C ⥤ Sum B D\n    where\n  obj X :=\n    match X with\n    | inl X => inl (F.obj X)\n    | inr X => inr (G.obj X)\n  map := @fun X Y f =>\n    match X, Y, f with\n    | inl X, inl Y, f => F.map f\n    | inr X, inr Y, f => G.map f\n  map_id := @fun X => by cases X <;> aesop_cat_nonterminal; erw [F.map_id]; rfl; erw [G.map_id]; rfl\n  map_comp := @fun X Y Z f g =>\n    match X, Y, Z, f, g with\n    | inl X, inl Y, inl Z, f, g => by\n      aesop_cat_nonterminal <;>\n      erw [F.map_comp] <;>\n      rfl\n    | inr X, inr Y, inr Z, f, g => by\n      aesop_cat_nonterminal <;>\n      erw [G.map_comp] <;>\n      rfl\n#align category_theory.functor.sum CategoryTheory.Functor.sum\n\n@[simp]\ntheorem sum_obj_inl (F : A ⥤ B) (G : C ⥤ D) (a : A) : (F.sum G).obj (inl a) = inl (F.obj a) :=\n  rfl\n#align category_theory.functor.sum_obj_inl CategoryTheory.Functor.sum_obj_inl\n\n@[simp]\ntheorem sum_obj_inr (F : A ⥤ B) (G : C ⥤ D) (c : C) : (F.sum G).obj (inr c) = inr (G.obj c) :=\n  rfl\n#align category_theory.functor.sum_obj_inr CategoryTheory.Functor.sum_obj_inr\n\n@[simp]\ntheorem sum_map_inl (F : A ⥤ B) (G : C ⥤ D) {a a' : A} (f : inl a ⟶ inl a') :\n    (F.sum G).map f = F.map f :=\n  rfl\n#align category_theory.functor.sum_map_inl CategoryTheory.Functor.sum_map_inl\n\n@[simp]\ntheorem sum_map_inr (F : A ⥤ B) (G : C ⥤ D) {c c' : C} (f : inr c ⟶ inr c') :\n    (F.sum G).map f = G.map f :=\n  rfl\n#align category_theory.functor.sum_map_inr CategoryTheory.Functor.sum_map_inr\n\nend Functor\n\nnamespace NatTrans\n\n/-- The sum of two natural transformations. -/\ndef sum {F G : A ⥤ B} {H I : C ⥤ D} (α : F ⟶ G) (β : H ⟶ I) : F.sum H ⟶ G.sum I\n    where\n  app X :=\n    match X with\n    | inl X => α.app X\n    | inr X => β.app X\n  naturality X Y f :=\n    match X, Y, f with\n    | inl X, inl Y, f => by aesop_cat_nonterminal <;> erw [α.naturality] <;> rfl\n    | inr X, inr Y, f => by aesop_cat_nonterminal <;> erw [β.naturality] <;> rfl\n#align category_theory.nat_trans.sum CategoryTheory.NatTrans.sum\n\n@[simp]\ntheorem sum_app_inl {F G : A ⥤ B} {H I : C ⥤ D} (α : F ⟶ G) (β : H ⟶ I) (a : A) :\n    (sum α β).app (inl a) = α.app a :=\n  rfl\n#align category_theory.nat_trans.sum_app_inl CategoryTheory.NatTrans.sum_app_inl\n\n@[simp]\ntheorem sum_app_inr {F G : A ⥤ B} {H I : C ⥤ D} (α : F ⟶ G) (β : H ⟶ I) (c : C) :\n    (sum α β).app (inr c) = β.app c :=\n  rfl\n#align category_theory.nat_trans.sum_app_inr CategoryTheory.NatTrans.sum_app_inr\n\nend NatTrans\n\nend CategoryTheory\n\"}"
"\n"
"{\"text\": \"/-\nCopyright (c) 2022 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\nimport Mathlib.Data.Fintype.Order\nimport Mathlib.Algebra.DirectLimit\nimport Mathlib.ModelTheory.Quotients\nimport Mathlib.ModelTheory.FinitelyGenerated\n\n#align_import model_theory.direct_limit from \"leanprover-community/mathlib\"@\"f53b23994ac4c13afa38d31195c588a1121d1860\"\n\n/-!\n# Direct Limits of First-Order Structures\nThis file constructs the direct limit of a directed system of first-order embeddings.\n\n## Main Definitions\n* `FirstOrder.Language.DirectLimit G f` is the direct limit of the directed system `f` of\n  first-order embeddings between the structures indexed by `G`.\n-/\n\n\nuniverse v w u₁ u₂\n\nopen FirstOrder\n\nnamespace FirstOrder\n\nnamespace Language\n\nopen Structure Set\n\nvariable {L : Language} {ι : Type v} [Preorder ι]\n\nvariable {G : ι → Type w} [∀ i, L.Structure (G i)]\n\nvariable (f : ∀ i j, i ≤ j → G i ↪[L] G j)\n\nnamespace DirectedSystem\n\n/-- A copy of `DirectedSystem.map_self` specialized to `L`-embeddings, as otherwise the\n`λ i j h, f i j h` can confuse the simplifier. -/\nnonrec theorem map_self [DirectedSystem G fun i j h => f i j h] (i x h) : f i i h x = x :=\n  DirectedSystem.map_self (fun i j h => f i j h) i x h\n#align first_order.language.directed_system.map_self FirstOrder.Language.DirectedSystem.map_self\n\n/-- A copy of `DirectedSystem.map_map` specialized to `L`-embeddings, as otherwise the\n`λ i j h, f i j h` can confuse the simplifier. -/\nnonrec theorem map_map [DirectedSystem G fun i j h => f i j h] {i j k} (hij hjk x) :\n    f j k hjk (f i j hij x) = f i k (le_trans hij hjk) x :=\n  DirectedSystem.map_map (fun i j h => f i j h) hij hjk x\n#align first_order.language.directed_system.map_map FirstOrder.Language.DirectedSystem.map_map\n\nvariable {G' : ℕ → Type w} [∀ i, L.Structure (G' i)] (f' : ∀ n : ℕ, G' n ↪[L] G' (n + 1))\n\n/-- Given a chain of embeddings of structures indexed by `ℕ`, defines a `DirectedSystem` by\ncomposing them. -/\ndef natLERec (m n : ℕ) (h : m ≤ n) : G' m ↪[L] G' n :=\n  Nat.leRecOn h (@fun k g => (f' k).comp g) (Embedding.refl L _)\n#align first_order.language.directed_system.nat_le_rec FirstOrder.Language.DirectedSystem.natLERec\n\n@[simp]\ntheorem coe_natLERec (m n : ℕ) (h : m ≤ n) :\n    (natLERec f' m n h : G' m → G' n) = Nat.leRecOn h (@fun k => f' k) := by\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le h\n  ext x\n  induction' k with k ih\n  · rw [natLERec, Nat.leRecOn_self, Embedding.refl_apply, Nat.leRecOn_self]\n  · rw [Nat.leRecOn_succ le_self_add, natLERec, Nat.leRecOn_succ le_self_add, ← natLERec,\n      Embedding.comp_apply, ih]\n#align first_order.language.directed_system.coe_nat_le_rec FirstOrder.Language.DirectedSystem.coe_natLERec\n\ninstance natLERec.directedSystem : DirectedSystem G' fun i j h => natLERec f' i j h :=\n  ⟨fun i x h => congr (congr rfl (Nat.leRecOn_self _)) rfl,\n   fun hij hjk => by simp [Nat.leRecOn_trans hij hjk]⟩\n#align first_order.language.directed_system.nat_le_rec.directed_system FirstOrder.Language.DirectedSystem.natLERec.directedSystem\n\nend DirectedSystem\n\n-- Porting note : Instead of `Σ i, G i`, we use the alias `Language.Structure.Sigma`\n-- which depends on `f`. This way, Lean can infer what `L` and `f` are in the `Setoid` instance.\n-- Otherwise we have a \"cannot find synthesization order\" error. See the discussion at\n-- https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/local.20instance.20cannot.20find.20synthesization.20order.20in.20porting\n\nset_option linter.unusedVariables false in\n/-- Alias for `Σ i, G i`. -/\n@[nolint unusedArguments]\nprotected abbrev Structure.Sigma (f : ∀ i j, i ≤ j → G i ↪[L] G j) := Σ i, G i\n\n-- Porting note: Setting up notation for `Language.Structure.Sigma`: add a little asterisk to `Σ`\nlocal notation \"Σˣ\" => Structure.Sigma\n\n/-- Constructor for `FirstOrder.Language.Structure.Sigma` alias. -/\nabbrev Structure.Sigma.mk (i : ι) (x : G i) : Σˣ f := ⟨i, x⟩\n\nnamespace DirectLimit\n\n/-- Raises a family of elements in the `Σ`-type to the same level along the embeddings. -/\ndef unify {α : Type*} (x : α → Σˣ f) (i : ι) (h : i ∈ upperBounds (range (Sigma.fst ∘ x)))\n    (a : α) : G i :=\n  f (x a).1 i (h (mem_range_self a)) (x a).2\n#align first_order.language.direct_limit.unify FirstOrder.Language.DirectLimit.unify\n\nvariable [DirectedSystem G fun i j h => f i j h]\n\n@[simp]\ntheorem unify_sigma_mk_self {α : Type*} {i : ι} {x : α → G i} :\n    (unify f (fun a => .mk f i (x a)) i fun j ⟨a, hj⟩ =>\n      _root_.trans (le_of_eq hj.symm) (refl _)) = x := by\n  ext a\n  rw [unify]\n  apply DirectedSystem.map_self\n#align first_order.language.direct_limit.unify_sigma_mk_self FirstOrder.Language.DirectLimit.unify_sigma_mk_self\n\ntheorem comp_unify {α : Type*} {x : α → Σˣ f} {i j : ι} (ij : i ≤ j)\n    (h : i ∈ upperBounds (range (Sigma.fst ∘ x))) :\n    f i j ij ∘ unify f x i h = unify f x j\n      fun k hk => _root_.trans (mem_upperBounds.1 h k hk) ij := by\n  ext a\n  simp [unify, DirectedSystem.map_map]\n#align first_order.language.direct_limit.comp_unify FirstOrder.Language.DirectLimit.comp_unify\n\nend DirectLimit\n\nvariable (G)\n\nnamespace DirectLimit\n\n/-- The directed limit glues together the structures along the embeddings. -/\ndef setoid [DirectedSystem G fun i j h => f i j h] [IsDirected ι (· ≤ ·)] : Setoid (Σˣ f) where\n  r := fun ⟨i, x⟩ ⟨j, y⟩ => ∃ (k : ι) (ik : i ≤ k) (jk : j ≤ k), f i k ik x = f j k jk y\n  iseqv :=\n    ⟨fun ⟨i, x⟩ => ⟨i, refl i, refl i, rfl⟩, @fun ⟨i, x⟩ ⟨j, y⟩ ⟨k, ik, jk, h⟩ =>\n      ⟨k, jk, ik, h.symm⟩,\n      @fun ⟨i, x⟩ ⟨j, y⟩ ⟨k, z⟩ ⟨ij, hiij, hjij, hij⟩ ⟨jk, hjjk, hkjk, hjk⟩ => by\n        obtain ⟨ijk, hijijk, hjkijk⟩ := directed_of (· ≤ ·) ij jk\n        refine' ⟨ijk, le_trans hiij hijijk, le_trans hkjk hjkijk, _⟩\n        rw [← DirectedSystem.map_map, hij, DirectedSystem.map_map]\n        symm\n        rw [← DirectedSystem.map_map, ← hjk, DirectedSystem.map_map] <;> assumption⟩\n#align first_order.language.direct_limit.setoid FirstOrder.Language.DirectLimit.setoid\n\n/-- The structure on the `Σ`-type which becomes the structure on the direct limit after quotienting.\n -/\nnoncomputable def sigmaStructure [IsDirected ι (· ≤ ·)] [Nonempty ι] : L.Structure (Σˣ f) where\n  funMap F x :=\n    ⟨_,\n      funMap F\n        (unify f x (Classical.choose (Fintype.bddAbove_range fun a => (x a).1))\n          (Classical.choose_spec (Fintype.bddAbove_range fun a => (x a).1)))⟩\n  RelMap R x :=\n    RelMap R\n      (unify f x (Classical.choose (Fintype.bddAbove_range fun a => (x a).1))\n        (Classical.choose_spec (Fintype.bddAbove_range fun a => (x a).1)))\n#align first_order.language.direct_limit.sigma_structure FirstOrder.Language.DirectLimit.sigmaStructure\n\nend DirectLimit\n\n/-- The direct limit of a directed system is the structures glued together along the embeddings. -/\ndef DirectLimit [DirectedSystem G fun i j h => f i j h] [IsDirected ι (· ≤ ·)] :=\n  Quotient (DirectLimit.setoid G f)\n#align first_order.language.direct_limit FirstOrder.Language.DirectLimit\n\nattribute [local instance] DirectLimit.setoid\n\n-- Porting note: Added local instance\nattribute [local instance] DirectLimit.sigmaStructure\n\n\ninstance [DirectedSystem G fun i j h => f i j h] [IsDirected ι (· ≤ ·)] [Inhabited ι]\n    [Inhabited (G default)] : Inhabited (DirectLimit G f) :=\n  ⟨⟦⟨default, default⟩⟧⟩\n\nnamespace DirectLimit\n\nvariable [IsDirected ι (· ≤ ·)] [DirectedSystem G fun i j h => f i j h]\n\ntheorem equiv_iff {x y : Σˣ f} {i : ι} (hx : x.1 ≤ i) (hy : y.1 ≤ i) :\n    x ≈ y ↔ (f x.1 i hx) x.2 = (f y.1 i hy) y.2 := by\n  cases x\n  cases y\n  refine' ⟨fun xy => _, fun xy => ⟨i, hx, hy, xy⟩⟩\n  obtain ⟨j, _, _, h⟩ := xy\n  obtain ⟨k, ik, jk⟩ := directed_of (· ≤ ·) i j\n  have h := congr_arg (f j k jk) h\n  apply (f i k ik).injective\n  rw [DirectedSystem.map_map, DirectedSystem.map_map] at *\n  exact h\n#align first_order.language.direct_limit.equiv_iff FirstOrder.Language.DirectLimit.equiv_iff\n\ntheorem funMap_unify_equiv {n : ℕ} (F : L.Functions n) (x : Fin n → Σˣ f) (i j : ι)\n    (hi : i ∈ upperBounds (range (Sigma.fst ∘ x))) (hj : j ∈ upperBounds (range (Sigma.fst ∘ x))) :\n    Structure.Sigma.mk f i (funMap F (unify f x i hi)) ≈ .mk f j (funMap F (unify f x j hj)) := by\n  obtain ⟨k, ik, jk⟩ := directed_of (· ≤ ·) i j\n  refine' ⟨k, ik, jk, _⟩\n  rw [(f i k ik).map_fun, (f j k jk).map_fun, comp_unify, comp_unify]\n#align first_order.language.direct_limit.fun_map_unify_equiv FirstOrder.Language.DirectLimit.funMap_unify_equiv\n\ntheorem relMap_unify_equiv {n : ℕ} (R : L.Relations n) (x : Fin n → Σˣ f) (i j : ι)\n    (hi : i ∈ upperBounds (range (Sigma.fst ∘ x))) (hj : j ∈ upperBounds (range (Sigma.fst ∘ x))) :\n    RelMap R (unify f x i hi) = RelMap R (unify f x j hj) := by\n  obtain ⟨k, ik, jk⟩ := directed_of (· ≤ ·) i j\n  rw [← (f i k ik).map_rel, comp_unify, ← (f j k jk).map_rel, comp_unify]\n#align first_order.language.direct_limit.rel_map_unify_equiv FirstOrder.Language.DirectLimit.relMap_unify_equiv\n\nvariable [Nonempty ι]\n\ntheorem exists_unify_eq {α : Type*} [Fintype α] {x y : α → Σˣ f} (xy : x ≈ y) :\n    ∃ (i : ι)(hx : i ∈ upperBounds (range (Sigma.fst ∘ x)))(hy :\n      i ∈ upperBounds (range (Sigma.fst ∘ y))), unify f x i hx = unify f y i hy := by\n  obtain ⟨i, hi⟩ := Fintype.bddAbove_range (Sum.elim (fun a => (x a).1) fun a => (y a).1)\n  rw [Sum.elim_range, upperBounds_union] at hi\n  simp_rw [← Function.comp_apply (f := Sigma.fst)] at hi\n  exact ⟨i, hi.1, hi.2, funext fun a => (equiv_iff G f _ _).1 (xy a)⟩\n#align first_order.language.direct_limit.exists_unify_eq FirstOrder.Language.DirectLimit.exists_unify_eq\n\ntheorem funMap_equiv_unify {n : ℕ} (F : L.Functions n) (x : Fin n → Σˣ f) (i : ι)\n    (hi : i ∈ upperBounds (range (Sigma.fst ∘ x))) :\n    funMap F x ≈ .mk f _ (funMap F (unify f x i hi)) :=\n  funMap_unify_equiv G f F x (Classical.choose (Fintype.bddAbove_range fun a => (x a).1)) i _ hi\n#align first_order.language.direct_limit.fun_map_equiv_unify FirstOrder.Language.DirectLimit.funMap_equiv_unify\n\ntheorem relMap_equiv_unify {n : ℕ} (R : L.Relations n) (x : Fin n → Σˣ f) (i : ι)\n    (hi : i ∈ upperBounds (range (Sigma.fst ∘ x))) :\n    RelMap R x = RelMap R (unify f x i hi) :=\n  relMap_unify_equiv G f R x (Classical.choose (Fintype.bddAbove_range fun a => (x a).1)) i _ hi\n#align first_order.language.direct_limit.rel_map_equiv_unify FirstOrder.Language.DirectLimit.relMap_equiv_unify\n\n/-- The direct limit `setoid` respects the structure `sigmaStructure`, so quotienting by it\n  gives rise to a valid structure. -/\nnoncomputable instance prestructure : L.Prestructure (DirectLimit.setoid G f) where\n  toStructure := sigmaStructure G f\n  fun_equiv {n} {F} x y xy := by\n    obtain ⟨i, hx, hy, h⟩ := exists_unify_eq G f xy\n    refine'\n      Setoid.trans (funMap_equiv_unify G f F x i hx)\n        (Setoid.trans _ (Setoid.symm (funMap_equiv_unify G f F y i hy)))\n    rw [h]\n  rel_equiv {n} {R} x y xy := by\n    obtain ⟨i, hx, hy, h⟩ := exists_unify_eq G f xy\n    refine' _root_.trans (relMap_equiv_unify G f R x i hx)\n      (_root_.trans _ (symm (relMap_equiv_unify G f R y i hy)))\n    rw [h]\n#align first_order.language.direct_limit.prestructure FirstOrder.Language.DirectLimit.prestructure\n\n/-- The `L.Structure` on a direct limit of `L.Structure`s. -/\nnoncomputable instance instStructureDirectLimit : L.Structure (DirectLimit G f) :=\n  Language.quotientStructure\nset_option linter.uppercaseLean3 false in\n#align first_order.language.direct_limit.Structure FirstOrder.Language.DirectLimit.instStructureDirectLimit\n\n@[simp]\ntheorem funMap_quotient_mk'_sigma_mk' {n : ℕ} {F : L.Functions n} {i : ι} {x : Fin n → G i} :\n    funMap F (fun a => (⟦.mk f i (x a)⟧ : DirectLimit G f)) = ⟦.mk f i (funMap F x)⟧ := by\n  simp [Function.comp_apply, funMap_quotient_mk', Quotient.eq']\n  obtain ⟨k, ik, jk⟩ :=\n    directed_of (· ≤ ·) i (Classical.choose (Fintype.bddAbove_range fun _ : Fin n => i))\n  refine' ⟨k, jk, ik, _⟩\n  simp only [Embedding.map_fun, comp_unify]\n  rfl\n#align first_order.language.direct_limit.fun_map_quotient_mk_sigma_mk FirstOrder.Language.DirectLimit.funMap_quotient_mk'_sigma_mk'\n\n@[simp]\ntheorem relMap_quotient_mk'_sigma_mk' {n : ℕ} {R : L.Relations n} {i : ι} {x : Fin n → G i} :\n    RelMap R (fun a => (⟦.mk f i (x a)⟧ : DirectLimit G f)) = RelMap R x := by\n  rw [relMap_quotient_mk']\n  obtain ⟨k, _, _⟩ :=\n    directed_of (· ≤ ·) i (Classical.choose (Fintype.bddAbove_range fun _ : Fin n => i))\n  rw [relMap_equiv_unify G f R (fun a => .mk f i (x a)) i]\n  rw [unify_sigma_mk_self]\n#align first_order.language.direct_limit.rel_map_quotient_mk_sigma_mk FirstOrder.Language.DirectLimit.relMap_quotient_mk'_sigma_mk'\n\ntheorem exists_quotient_mk'_sigma_mk'_eq {α : Type*} [Fintype α] (x : α → DirectLimit G f) :\n    ∃ (i : ι) (y : α → G i), x = fun a => ⟦.mk f i (y a)⟧ := by\n  obtain ⟨i, hi⟩ := Fintype.bddAbove_range fun a => (x a).out.1\n  refine' ⟨i, unify f (Quotient.out ∘ x) i hi, _⟩\n  ext a\n  rw [Quotient.eq_mk_iff_out, unify]\n  generalize_proofs r\n  change _ ≈ .mk f i (f (Quotient.out (x a)).fst i r (Quotient.out (x a)).snd)\n  have : (.mk f i (f (Quotient.out (x a)).fst i r (Quotient.out (x a)).snd) : Σˣ f).fst ≤ i :=\n    le_rfl\n  rw [equiv_iff G f (i := i) (hi _) this]\n  · simp only [DirectedSystem.map_self]\n  exact ⟨a, rfl⟩\n#align first_order.language.direct_limit.exists_quotient_mk_sigma_mk_eq FirstOrder.Language.DirectLimit.exists_quotient_mk'_sigma_mk'_eq\n\nvariable (L ι)\n\n/-- The canonical map from a component to the direct limit. -/\ndef of (i : ι) : G i ↪[L] DirectLimit G f where\n  toFun := fun a => ⟦.mk f i a⟧\n  inj' x y h := by\n    rw [Quotient.eq] at h\n    obtain ⟨j, h1, _, h3⟩ := h\n    exact (f i j h1).injective h3\n  map_fun' F x := by\n    simp\n    rw [← funMap_quotient_mk'_sigma_mk']\n    rfl\n  map_rel' := by\n    intro n R x\n    change RelMap R (fun a => (⟦.mk f i (x a)⟧ : DirectLimit G f)) ↔ _\n    simp only [relMap_quotient_mk'_sigma_mk']\n\n\n#align first_order.language.direct_limit.of FirstOrder.Language.DirectLimit.of\n\nvariable {L ι G f}\n\n@[simp]\ntheorem of_apply {i : ι} {x : G i} : of L ι G f i x = ⟦.mk f i x⟧ :=\n  rfl\n#align first_order.language.direct_limit.of_apply FirstOrder.Language.DirectLimit.of_apply\n\n-- Porting note: removed the `@[simp]`, it is not in simp-normal form, but the simp-normal version\n-- of this theorem would not be useful.\ntheorem of_f {i j : ι} {hij : i ≤ j} {x : G i} : of L ι G f j (f i j hij x) = of L ι G f i x := by\n  rw [of_apply, of_apply, Quotient.eq]\n  refine' Setoid.symm ⟨j, hij, refl j, _⟩\n  simp only [DirectedSystem.map_self]\n#align first_order.language.direct_limit.of_f FirstOrder.Language.DirectLimit.of_f\n\n/-- Every element of the direct limit corresponds to some element in\nsome component of the directed system. -/\ntheorem exists_of (z : DirectLimit G f) : ∃ i x, of L ι G f i x = z :=\n  ⟨z.out.1, z.out.2, by simp⟩\n#align first_order.language.direct_limit.exists_of FirstOrder.Language.DirectLimit.exists_of\n\n@[elab_as_elim]\nprotected theorem inductionOn {C : DirectLimit G f → Prop} (z : DirectLimit G f)\n    (ih : ∀ i x, C (of L ι G f i x)) : C z :=\n  let ⟨i, x, h⟩ := exists_of z\n  h ▸ ih i x\n#align first_order.language.direct_limit.induction_on FirstOrder.Language.DirectLimit.inductionOn\n\nvariable {P : Type u₁} [L.Structure P] (g : ∀ i, G i ↪[L] P)\n\nvariable (Hg : ∀ i j hij x, g j (f i j hij x) = g i x)\n\nvariable (L ι G f)\n\n/-- The universal property of the direct limit: maps from the components to another module\nthat respect the directed system structure (i.e. make some diagram commute) give rise\nto a unique map out of the direct limit. -/\ndef lift : DirectLimit G f ↪[L] P where\n  toFun :=\n    Quotient.lift (fun x : Σˣ f => (g x.1) x.2) fun x y xy => by\n      simp\n      obtain ⟨i, hx, hy⟩ := directed_of (· ≤ ·) x.1 y.1\n      rw [← Hg x.1 i hx, ← Hg y.1 i hy]\n      exact congr_arg _ ((equiv_iff ..).1 xy)\n  inj' x y xy := by\n    rw [← Quotient.out_eq x, ← Quotient.out_eq y, Quotient.lift_mk, Quotient.lift_mk] at xy\n    obtain ⟨i, hx, hy⟩ := directed_of (· ≤ ·) x.out.1 y.out.1\n    rw [← Hg x.out.1 i hx, ← Hg y.out.1 i hy] at xy\n    rw [← Quotient.out_eq x, ← Quotient.out_eq y, Quotient.eq, equiv_iff G f hx hy]\n    exact (g i).injective xy\n  map_fun' F x := by\n    obtain ⟨i, y, rfl⟩ := exists_quotient_mk'_sigma_mk'_eq G f x\n    change _ = funMap F (Quotient.lift _ _ ∘ Quotient.mk _ ∘ Structure.Sigma.mk f i ∘ y)\n    rw [funMap_quotient_mk'_sigma_mk', ← Function.comp.assoc, Quotient.lift_comp_mk]\n    simp only [Quotient.lift_mk, Embedding.map_fun]\n    rfl\n  map_rel' R x := by\n    obtain ⟨i, y, rfl⟩ := exists_quotient_mk'_sigma_mk'_eq G f x\n    change RelMap R (Quotient.lift _ _ ∘ Quotient.mk _ ∘ Structure.Sigma.mk f i ∘ y) ↔ _\n    rw [relMap_quotient_mk'_sigma_mk' G f, ← (g i).map_rel R y, ← Function.comp.assoc,\n      Quotient.lift_comp_mk]\n    rfl\n#align first_order.language.direct_limit.lift FirstOrder.Language.DirectLimit.lift\n\nvariable {L ι G f}\n\n@[simp]\ntheorem lift_quotient_mk'_sigma_mk' {i} (x : G i) : lift L ι G f g Hg ⟦.mk f i x⟧ = (g i) x := by\n  change (lift L ι G f g Hg).toFun ⟦.mk f i x⟧ = _\n  simp only [lift, Quotient.lift_mk]\n#align first_order.language.direct_limit.lift_quotient_mk_sigma_mk FirstOrder.Language.DirectLimit.lift_quotient_mk'_sigma_mk'\n\ntheorem lift_of {i} (x : G i) : lift L ι G f g Hg (of L ι G f i x) = g i x := by simp\n#align first_order.language.direct_limit.lift_of FirstOrder.Language.DirectLimit.lift_of\n\ntheorem lift_unique (F : DirectLimit G f ↪[L] P) (x) :\n    F x =\n      lift L ι G f (fun i => F.comp <| of L ι G f i)\n        (fun i j hij x => by rw [F.comp_apply, F.comp_apply, of_f]) x :=\n  DirectLimit.inductionOn x fun i x => by rw [lift_of]; rfl\n#align first_order.language.direct_limit.lift_unique FirstOrder.Language.DirectLimit.lift_unique\n\n/-- The direct limit of countably many countably generated structures is countably generated. -/\ntheorem cg {ι : Type*} [Encodable ι] [Preorder ι] [IsDirected ι (· ≤ ·)] [Nonempty ι]\n    {G : ι → Type w} [∀ i, L.Structure (G i)] (f : ∀ i j, i ≤ j → G i ↪[L] G j)\n    (h : ∀ i, Structure.CG L (G i)) [DirectedSystem G fun i j h => f i j h] :\n    Structure.CG L (DirectLimit G f) := by\n  refine' ⟨⟨⋃ i, DirectLimit.of L ι G f i '' Classical.choose (h i).out, _, _⟩⟩\n  · exact Set.countable_iUnion fun i => Set.Countable.image (Classical.choose_spec (h i).out).1 _\n  · rw [eq_top_iff, Substructure.closure_unionᵢ]\n    simp_rw [← Embedding.coe_toHom, Substructure.closure_image]\n    rw [le_iSup_iff]\n    intro S hS x _\n    let out := Quotient.out (s := DirectLimit.setoid G f)\n    refine' hS (out x).1 ⟨(out x).2, _, _⟩\n    · rw [(Classical.choose_spec (h (out x).1).out).2]\n      trivial\n    · simp only [Embedding.coe_toHom, DirectLimit.of_apply, Sigma.eta, Quotient.out_eq]\n#align first_order.language.direct_limit.cg FirstOrder.Language.DirectLimit.cg\n\ninstance cg' {ι : Type*} [Encodable ι] [Preorder ι] [IsDirected ι (· ≤ ·)] [Nonempty ι]\n    {G : ι → Type w} [∀ i, L.Structure (G i)] (f : ∀ i j, i ≤ j → G i ↪[L] G j)\n    [h : ∀ i, Structure.CG L (G i)] [DirectedSystem G fun i j h => f i j h] :\n    Structure.CG L (DirectLimit G f) :=\n  cg f h\n#align first_order.language.direct_limit.cg' FirstOrder.Language.DirectLimit.cg'\n\nend DirectLimit\n\nend Language\n\nend FirstOrder\n\"}"
"\n"
"{\"text\": \"/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative ℕ` to `ℕ`.\n-/\n\nvariable {α : Type*} (p : α → Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n/-- `List.countP` as a bundled additive monoid homomorphism. -/\ndef countP : FreeAddMonoid α →+ ℕ where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : α) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid α) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n/-- `List.count` as a bundled additive monoid homomorphism. -/\n-- Porting note: was (x = ·)\ndef count [DecidableEq α] (x : α) : FreeAddMonoid α →+ ℕ := countP (· = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq α] (x y : α) : count x (of y) = (Pi.single x 1 : α → ℕ) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq α] (x : α) (l : FreeAddMonoid α) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n/-- `List.countP` as a bundled multiplicative monoid homomorphism. -/\ndef countP : FreeMonoid α →* Multiplicative ℕ :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : α) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : α) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid α) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n/-- `List.count` as a bundled additive monoid homomorphism. -/\ndef count [DecidableEq α] (x : α) : FreeMonoid α →* Multiplicative ℕ := countP (· = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq α] (x : α) (l : FreeAddMonoid α) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq α] (x y : α) :\n    count x (of y) = @Pi.mulSingle α (fun _ => Multiplicative ℕ) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMonoid.count_of\n\nend FreeMonoid\n\"}"
"\n"
"{\"text\": \"/-\nCopyright (c) 2022 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Adam Topaz, Junyan Xu, Jack McKoen\n-/\nimport Mathlib.RingTheory.Valuation.ValuationRing\nimport Mathlib.RingTheory.Localization.AsSubring\nimport Mathlib.RingTheory.Subring.Pointwise\nimport Mathlib.AlgebraicGeometry.PrimeSpectrum.Basic\n\n#align_import ring_theory.valuation.valuation_subring from \"leanprover-community/mathlib\"@\"2196ab363eb097c008d4497125e0dde23fb36db2\"\n\n/-!\n\n# Valuation subrings of a field\n\n## Projects\n\nThe order structure on `ValuationSubring K`.\n\n-/\n\n\nuniverse u\n\nopen scoped Classical\n\nnoncomputable section\n\nvariable (K : Type u) [Field K]\n\n/-- A valuation subring of a field `K` is a subring `A` such that for every `x : K`,\neither `x ∈ A` or `x⁻¹ ∈ A`. -/\nstructure ValuationSubring extends Subring K where\n  mem_or_inv_mem' : ∀ x : K, x ∈ carrier ∨ x⁻¹ ∈ carrier\n#align valuation_subring ValuationSubring\n\nnamespace ValuationSubring\n\nvariable {K}\nvariable (A : ValuationSubring K)\n\ninstance : SetLike (ValuationSubring K) K where\n  coe A := A.toSubring\n  coe_injective' := by\n    intro ⟨_, _⟩ ⟨_, _⟩ h\n    replace h := SetLike.coe_injective' h\n    congr\n\n@[simp, nolint simpNF] -- Porting note: simp cannot prove that\ntheorem mem_carrier (x : K) : x ∈ A.carrier ↔ x ∈ A := Iff.refl _\n#align valuation_subring.mem_carrier ValuationSubring.mem_carrier\n\n@[simp]\ntheorem mem_toSubring (x : K) : x ∈ A.toSubring ↔ x ∈ A := Iff.refl _\n#align valuation_subring.mem_to_subring ValuationSubring.mem_toSubring\n\n@[ext]\ntheorem ext (A B : ValuationSubring K) (h : ∀ x, x ∈ A ↔ x ∈ B) : A = B := SetLike.ext h\n#align valuation_subring.ext ValuationSubring.ext\n\ntheorem zero_mem : (0 : K) ∈ A := A.toSubring.zero_mem\n#align valuation_subring.zero_mem ValuationSubring.zero_mem\n\ntheorem one_mem : (1 : K) ∈ A := A.toSubring.one_mem\n#align valuation_subring.one_mem ValuationSubring.one_mem\n\ntheorem add_mem (x y : K) : x ∈ A → y ∈ A → x + y ∈ A := A.toSubring.add_mem\n#align valuation_subring.add_mem ValuationSubring.add_mem\n\ntheorem mul_mem (x y : K) : x ∈ A → y ∈ A → x * y ∈ A := A.toSubring.mul_mem\n#align valuation_subring.mul_mem ValuationSubring.mul_mem\n\ntheorem neg_mem (x : K) : x ∈ A → -x ∈ A := A.toSubring.neg_mem\n#align valuation_subring.neg_mem ValuationSubring.neg_mem\n\ntheorem mem_or_inv_mem (x : K) : x ∈ A ∨ x⁻¹ ∈ A := A.mem_or_inv_mem' _\n#align valuation_subring.mem_or_inv_mem ValuationSubring.mem_or_inv_mem\n\ninstance : SubringClass (ValuationSubring K) K where\n  zero_mem := zero_mem\n  add_mem {_} a b := add_mem _ a b\n  one_mem := one_mem\n  mul_mem {_} a b := mul_mem _ a b\n  neg_mem {_} x := neg_mem _ x\n\ntheorem toSubring_injective : Function.Injective (toSubring : ValuationSubring K → Subring K) :=\n  fun x y h => by cases x; cases y; congr\n#align valuation_subring.to_subring_injective ValuationSubring.toSubring_injective\n\ninstance : CommRing A :=\n  show CommRing A.toSubring by infer_instance\n\ninstance : IsDomain A :=\n  show IsDomain A.toSubring by infer_instance\n\ninstance : Top (ValuationSubring K) :=\n  Top.mk <| { (⊤ : Subring K) with mem_or_inv_mem' := fun _ => Or.inl trivial }\n\ntheorem mem_top (x : K) : x ∈ (⊤ : ValuationSubring K) :=\n  trivial\n#align valuation_subring.mem_top ValuationSubring.mem_top\n\ntheorem le_top : A ≤ ⊤ := fun _a _ha => mem_top _\n#align valuation_subring.le_top ValuationSubring.le_top\n\ninstance : OrderTop (ValuationSubring K) where\n  top := ⊤\n  le_top := le_top\n\ninstance : Inhabited (ValuationSubring K) :=\n  ⟨⊤⟩\n\ninstance : ValuationRing A where\n  cond' a b := by\n    by_cases (b : K) = 0\n    · use 0\n      left\n      ext\n      simp [h]\n    by_cases (a : K) = 0\n    · use 0; right\n      ext\n      simp [h]\n    cases' A.mem_or_inv_mem (a / b) with hh hh\n    · use ⟨a / b, hh⟩\n      right\n      ext\n      field_simp\n      ring\n    · rw [show (a / b : K)⁻¹ = b / a by field_simp] at hh\n      use ⟨b / a, hh⟩;\n      left\n      ext\n      field_simp\n      ring\n\ninstance : Algebra A K :=\n  show Algebra A.toSubring K by infer_instance\n\n-- Porting note: Somehow it cannot find this instance and I'm too lazy to debug. wrong prio?\ninstance localRing : LocalRing A := ValuationRing.localRing A\n\n@[simp]\ntheorem algebraMap_apply (a : A) : algebraMap A K a = a := rfl\n#align valuation_subring.algebra_map_apply ValuationSubring.algebraMap_apply\n\ninstance : IsFractionRing A K where\n  map_units' := fun ⟨y, hy⟩ =>\n    (Units.mk0 (y : K) fun c => nonZeroDivisors.ne_zero hy <| Subtype.ext c).isUnit\n  surj' z := by\n    by_cases z = 0; · use (0, 1); simp [h]\n    cases' A.mem_or_inv_mem z with hh hh\n    · use (⟨z, hh⟩, 1); simp\n    · refine ⟨⟨1, ⟨⟨_, hh⟩, ?_⟩⟩, mul_inv_cancel h⟩\n      exact mem_nonZeroDivisors_iff_ne_zero.2 fun c => h (inv_eq_zero.mp (congr_arg Subtype.val c))\n  eq_iff_exists' {a b} :=\n    ⟨fun h => ⟨1, by ext; simpa using h⟩, fun ⟨c, h⟩ =>\n      congr_arg Subtype.val ((mul_eq_mul_left_iff.1 h).resolve_right (nonZeroDivisors.ne_zero c.2))⟩\n\n/-- The value group of the valuation associated to `A`. Note: it is actually a group with zero. -/\ndef ValueGroup :=\n  ValuationRing.ValueGroup A K\n-- deriving LinearOrderedCommGroupWithZero\n#align valuation_subring.value_group ValuationSubring.ValueGroup\n\n-- Porting note: see https://github.com/leanprover-community/mathlib4/issues/5020\ninstance : LinearOrderedCommGroupWithZero (ValueGroup A) := by\n  unfold ValueGroup\n  infer_instance\n\n/-- Any valuation subring of `K` induces a natural valuation on `K`. -/\ndef valuation : Valuation K A.ValueGroup :=\n  ValuationRing.valuation A K\n#align valuation_subring.valuation ValuationSubring.valuation\n\ninstance inhabitedValueGroup : Inhabited A.ValueGroup := ⟨A.valuation 0⟩\n#align valuation_subring.inhabited_value_group ValuationSubring.inhabitedValueGroup\n\ntheorem valuation_le_one (a : A) : A.valuation a ≤ 1 :=\n  (ValuationRing.mem_integer_iff A K _).2 ⟨a, rfl⟩\n#align valuation_subring.valuation_le_one ValuationSubring.valuation_le_one\n\ntheorem mem_of_valuation_le_one (x : K) (h : A.valuation x ≤ 1) : x ∈ A :=\n  let ⟨a, ha⟩ := (ValuationRing.mem_integer_iff A K x).1 h\n  ha ▸ a.2\n#align valuation_subring.mem_of_valuation_le_one ValuationSubring.mem_of_valuation_le_one\n\ntheorem valuation_le_one_iff (x : K) : A.valuation x ≤ 1 ↔ x ∈ A :=\n  ⟨mem_of_valuation_le_one _ _, fun ha => A.valuation_le_one ⟨x, ha⟩⟩\n#align valuation_subring.valuation_le_one_iff ValuationSubring.valuation_le_one_iff\n\ntheorem valuation_eq_iff (x y : K) : A.valuation x = A.valuation y ↔ ∃ a : Aˣ, (a : K) * y = x :=\n  Quotient.eq''\n#align valuation_subring.valuation_eq_iff ValuationSubring.valuation_eq_iff\n\ntheorem valuation_le_iff (x y : K) : A.valuation x ≤ A.valuation y ↔ ∃ a : A, (a : K) * y = x :=\n  Iff.rfl\n#align valuation_subring.valuation_le_iff ValuationSubring.valuation_le_iff\n\ntheorem valuation_surjective : Function.Surjective A.valuation := surjective_quot_mk _\n#align valuation_subring.valuation_surjective ValuationSubring.valuation_surjective\n\ntheorem valuation_unit (a : Aˣ) : A.valuation a = 1 := by\n  rw [← A.valuation.map_one, valuation_eq_iff]; use a; simp\n#align valuation_subring.valuation_unit ValuationSubring.valuation_unit\n\ntheorem valuation_eq_one_iff (a : A) : IsUnit a ↔ A.valuation a = 1 :=\n  ⟨fun h => A.valuation_unit h.unit, fun h => by\n    have ha : (a : K) ≠ 0\n    · intro c\n      rw [c, A.valuation.map_zero] at h\n      exact zero_ne_one h\n    have ha' : (a : K)⁻¹ ∈ A := by rw [← valuation_le_one_iff, map_inv₀, h, inv_one]\n    apply isUnit_of_mul_eq_one a ⟨a⁻¹, ha'⟩; ext; field_simp⟩\n#align valuation_subring.valuation_eq_one_iff ValuationSubring.valuation_eq_one_iff\n\ntheorem valuation_lt_one_or_eq_one (a : A) : A.valuation a < 1 ∨ A.valuation a = 1 :=\n  lt_or_eq_of_le (A.valuation_le_one a)\n#align valuation_subring.valuation_lt_one_or_eq_one ValuationSubring.valuation_lt_one_or_eq_one\n\ntheorem valuation_lt_one_iff (a : A) : a ∈ LocalRing.maximalIdeal A ↔ A.valuation a < 1 := by\n  rw [LocalRing.mem_maximalIdeal]\n  dsimp [nonunits]; rw [valuation_eq_one_iff]\n  exact (A.valuation_le_one a).lt_iff_ne.symm\n#align valuation_subring.valuation_lt_one_iff ValuationSubring.valuation_lt_one_iff\n\n/-- A subring `R` of `K` such that for all `x : K` either `x ∈ R` or `x⁻¹ ∈ R` is\n  a valuation subring of `K`. -/\ndef ofSubring (R : Subring K) (hR : ∀ x : K, x ∈ R ∨ x⁻¹ ∈ R) : ValuationSubring K :=\n  { R with mem_or_inv_mem' := hR }\n#align valuation_subring.of_subring ValuationSubring.ofSubring\n\n@[simp]\ntheorem mem_ofSubring (R : Subring K) (hR : ∀ x : K, x ∈ R ∨ x⁻¹ ∈ R) (x : K) :\n    x ∈ ofSubring R hR ↔ x ∈ R :=\n  Iff.refl _\n#align valuation_subring.mem_of_subring ValuationSubring.mem_ofSubring\n\n/-- An overring of a valuation ring is a valuation ring. -/\ndef ofLE (R : ValuationSubring K) (S : Subring K) (h : R.toSubring ≤ S) : ValuationSubring K :=\n  { S with mem_or_inv_mem' := fun x => (R.mem_or_inv_mem x).imp (@h x) (@h _) }\n#align valuation_subring.of_le ValuationSubring.ofLE\n\nsection Order\n\ninstance : SemilatticeSup (ValuationSubring K) :=\n  { (inferInstance : PartialOrder (ValuationSubring K)) with\n    sup := fun R S => ofLE R (R.toSubring ⊔ S.toSubring) <| le_sup_left\n    le_sup_left := fun R S _ hx => (le_sup_left : R.toSubring ≤ R.toSubring ⊔ S.toSubring) hx\n    le_sup_right := fun R S _ hx => (le_sup_right : S.toSubring ≤ R.toSubring ⊔ S.toSubring) hx\n    sup_le := fun R S T hR hT _ hx => (sup_le hR hT : R.toSubring ⊔ S.toSubring ≤ T.toSubring) hx }\n\n/-- The ring homomorphism induced by the partial order. -/\ndef inclusion (R S : ValuationSubring K) (h : R ≤ S) : R →+* S :=\n  Subring.inclusion h\n#align valuation_subring.inclusion ValuationSubring.inclusion\n\n/-- The canonical ring homomorphism from a valuation ring to its field of fractions. -/\ndef subtype (R : ValuationSubring K) : R →+* K :=\n  Subring.subtype R.toSubring\n#align valuation_subring.subtype ValuationSubring.subtype\n\n/-- The canonical map on value groups induced by a coarsening of valuation rings. -/\ndef mapOfLE (R S : ValuationSubring K) (h : R ≤ S) : R.ValueGroup →*₀ S.ValueGroup where\n  toFun := Quotient.map' id fun x y ⟨u, hu⟩ => ⟨Units.map (R.inclusion S h).toMonoidHom u, hu⟩\n  map_zero' := rfl\n  map_one' := rfl\n  map_mul' := by rintro ⟨⟩ ⟨⟩; rfl\n#align valuation_subring.map_of_le ValuationSubring.mapOfLE\n\n@[mono]\ntheorem monotone_mapOfLE (R S : ValuationSubring K) (h : R ≤ S) : Monotone (R.mapOfLE S h) := by\n  rintro ⟨⟩ ⟨⟩ ⟨a, ha⟩; exact ⟨R.inclusion S h a, ha⟩\n#align valuation_subring.monotone_map_of_le ValuationSubring.monotone_mapOfLE\n\n@[simp]\ntheorem mapOfLE_comp_valuation (R S : ValuationSubring K) (h : R ≤ S) :\n    R.mapOfLE S h ∘ R.valuation = S.valuation := by ext; rfl\n#align valuation_subring.map_of_le_comp_valuation ValuationSubring.mapOfLE_comp_valuation\n\n@[simp]\ntheorem mapOfLE_valuation_apply (R S : ValuationSubring K) (h : R ≤ S) (x : K) :\n    R.mapOfLE S h (R.valuation x) = S.valuation x := rfl\n#align valuation_subring.map_of_le_valuation_apply ValuationSubring.mapOfLE_valuation_apply\n\n/-- The ideal corresponding to a coarsening of a valuation ring. -/\ndef idealOfLE (R S : ValuationSubring K) (h : R ≤ S) : Ideal R :=\n  (LocalRing.maximalIdeal S).comap (R.inclusion S h)\n#align valuation_subring.ideal_of_le ValuationSubring.idealOfLE\n\ninstance prime_idealOfLE (R S : ValuationSubring K) (h : R ≤ S) : (idealOfLE R S h).IsPrime :=\n  (LocalRing.maximalIdeal S).comap_isPrime _\n#align valuation_subring.prime_ideal_of_le ValuationSubring.prime_idealOfLE\n\n/-- The coarsening of a valuation ring associated to a prime ideal. -/\ndef ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] : ValuationSubring K :=\n  ofLE A (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors).toSubring\n    -- Porting note: added `Subalgebra.mem_toSubring.mpr`\n    fun a ha => Subalgebra.mem_toSubring.mpr <|\n      Subalgebra.algebraMap_mem\n        (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors) (⟨a, ha⟩ : A)\n#align valuation_subring.of_prime ValuationSubring.ofPrime\n\ninstance ofPrimeAlgebra (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    Algebra A (A.ofPrime P) :=\n  -- Porting note: filled in the argument\n  Subalgebra.algebra (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors)\n#align valuation_subring.of_prime_algebra ValuationSubring.ofPrimeAlgebra\n\ninstance ofPrime_scalar_tower (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    -- Porting note: added instance\n    letI : SMul A (A.ofPrime P) := SMulZeroClass.toSMul\n    IsScalarTower A (A.ofPrime P) K :=\n  IsScalarTower.subalgebra' A K K\n    -- Porting note: filled in the argument\n    (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors)\n#align valuation_subring.of_prime_scalar_tower ValuationSubring.ofPrime_scalar_tower\n\ninstance ofPrime_localization (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    IsLocalization.AtPrime (A.ofPrime P) P := by\n  apply\n    Localization.subalgebra.isLocalization_ofField K P.primeCompl\n      P.primeCompl_le_nonZeroDivisors\n#align valuation_subring.of_prime_localization ValuationSubring.ofPrime_localization\n\ntheorem le_ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] : A ≤ ofPrime A P :=\n  -- Porting note: added `Subalgebra.mem_toSubring.mpr`\n  fun a ha => Subalgebra.mem_toSubring.mpr <| Subalgebra.algebraMap_mem _ (⟨a, ha⟩ : A)\n#align valuation_subring.le_of_prime ValuationSubring.le_ofPrime\n\ntheorem ofPrime_valuation_eq_one_iff_mem_primeCompl (A : ValuationSubring K) (P : Ideal A)\n    [P.IsPrime] (x : A) : (ofPrime A P).valuation x = 1 ↔ x ∈ P.primeCompl := by\n  rw [← IsLocalization.AtPrime.isUnit_to_map_iff (A.ofPrime P) P x, valuation_eq_one_iff]; rfl\n#align valuation_subring.of_prime_valuation_eq_one_iff_mem_prime_compl ValuationSubring.ofPrime_valuation_eq_one_iff_mem_primeCompl\n\n@[simp]\ntheorem idealOfLE_ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    idealOfLE A (ofPrime A P) (le_ofPrime A P) = P := by\n  refine Ideal.ext (fun x => ?_)\n  apply IsLocalization.AtPrime.to_map_mem_maximal_iff\n  exact localRing (ofPrime A P)\n#align valuation_subring.ideal_of_le_of_prime ValuationSubring.idealOfLE_ofPrime\n\n@[simp]\ntheorem ofPrime_idealOfLE (R S : ValuationSubring K) (h : R ≤ S) :\n    ofPrime R (idealOfLE R S h) = S := by\n  ext x; constructor\n  · rintro ⟨a, r, hr, rfl⟩; apply mul_mem; · exact h a.2\n    · rw [← valuation_le_one_iff, map_inv₀, ← inv_one, inv_le_inv₀]\n      · exact not_lt.1 ((not_iff_not.2 <| valuation_lt_one_iff S _).1 hr)\n      · intro hh; erw [Valuation.zero_iff, Subring.coe_eq_zero_iff] at hh\n        apply hr; rw [hh]; apply Ideal.zero_mem (R.idealOfLE S h)\n      · exact one_ne_zero\n  · intro hx; by_cases hr : x ∈ R; · exact R.le_ofPrime _ hr\n    have : x ≠ 0 := fun h => hr (by rw [h]; exact R.zero_mem)\n    replace hr := (R.mem_or_inv_mem x).resolve_left hr\n    · -- Porting note: added `⟨⟩` brackets and reordered goals\n      use 1, ⟨x⁻¹, hr⟩; constructor\n      · field_simp\n      · change (⟨x⁻¹, h hr⟩ : S) ∉ nonunits S\n        rw [mem_nonunits_iff, Classical.not_not]\n        apply isUnit_of_mul_eq_one _ (⟨x, hx⟩ : S)\n        ext; field_simp\n#align valuation_subring.of_prime_ideal_of_le ValuationSubring.ofPrime_idealOfLE\n\ntheorem ofPrime_le_of_le (P Q : Ideal A) [P.IsPrime] [Q.IsPrime] (h : P ≤ Q) :\n    ofPrime A Q ≤ ofPrime A P := fun _x ⟨a, s, hs, he⟩ => ⟨a, s, fun c => hs (h c), he⟩\n#align valuation_subring.of_prime_le_of_le ValuationSubring.ofPrime_le_of_le\n\ntheorem idealOfLE_le_of_le (R S : ValuationSubring K) (hR : A ≤ R) (hS : A ≤ S) (h : R ≤ S) :\n    idealOfLE A S hS ≤ idealOfLE A R hR := fun x hx =>\n  (valuation_lt_one_iff R _).2\n    (by\n      by_contra c; push_neg at c; replace c := monotone_mapOfLE R S h c\n      rw [(mapOfLE _ _ _).map_one, mapOfLE_valuation_apply] at c\n      apply not_le_of_lt ((valuation_lt_one_iff S _).1 hx) c)\n#align valuation_subring.ideal_of_le_le_of_le ValuationSubring.idealOfLE_le_of_le\n\n/-- The equivalence between coarsenings of a valuation ring and its prime ideals.-/\n@[simps]\ndef primeSpectrumEquiv : PrimeSpectrum A ≃ {S | A ≤ S} where\n  toFun P := ⟨ofPrime A P.asIdeal, le_ofPrime _ _⟩\n  invFun S := ⟨idealOfLE _ S S.2, inferInstance⟩\n  left_inv P := by ext1; simp\n  right_inv S := by ext1; simp\n#align valuation_subring.prime_spectrum_equiv ValuationSubring.primeSpectrumEquiv\n\n/-- An ordered variant of `primeSpectrumEquiv`. -/\n@[simps]\ndef primeSpectrumOrderEquiv : (PrimeSpectrum A)ᵒᵈ ≃o {S | A ≤ S} :=\n  { primeSpectrumEquiv A with\n    map_rel_iff' :=\n      ⟨fun h => by\n        dsimp at h\n        have := idealOfLE_le_of_le A _ _ ?_ ?_ h\n        iterate 2 erw [idealOfLE_ofPrime] at this\n        exact this\n        all_goals exact le_ofPrime A (PrimeSpectrum.asIdeal _),\n      fun h => by apply ofPrime_le_of_le; exact h⟩ }\n#align valuation_subring.prime_spectrum_order_equiv ValuationSubring.primeSpectrumOrderEquiv\n\ninstance linearOrderOverring : LinearOrder {S | A ≤ S} :=\n  { (inferInstance : PartialOrder _) with\n    le_total :=\n      let i : IsTotal (PrimeSpectrum A) (· ≤ ·) := ⟨fun ⟨x, _⟩ ⟨y, _⟩ => LE.isTotal.total x y⟩\n      (primeSpectrumOrderEquiv A).symm.toRelEmbedding.isTotal.total\n    decidableLE := inferInstance }\n#align valuation_subring.linear_order_overring ValuationSubring.linearOrderOverring\n\nend Order\n\nend ValuationSubring\n\nnamespace Valuation\n\nvariable {K}\nvariable {Γ Γ₁ Γ₂ : Type*} [LinearOrderedCommGroupWithZero Γ]\n  [LinearOrderedCommGroupWithZero Γ₁] [LinearOrderedCommGroupWithZero Γ₂] (v : Valuation K Γ)\n  (v₁ : Valuation K Γ₁) (v₂ : Valuation K Γ₂)\n\n/-- The valuation subring associated to a valuation. -/\ndef valuationSubring : ValuationSubring K :=\n  { v.integer with\n    mem_or_inv_mem' := by\n      intro x\n      cases' le_or_lt (v x) 1 with h h\n      · left; exact h\n      · right; change v x⁻¹ ≤ 1\n        rw [map_inv₀ v, ← inv_one, inv_le_inv₀]\n        · exact le_of_lt h\n        · intro c; simp [c] at h\n        · exact one_ne_zero }\n#align valuation.valuation_subring Valuation.valuationSubring\n\n@[simp]\ntheorem mem_valuationSubring_iff (x : K) : x ∈ v.valuationSubring ↔ v x ≤ 1 := Iff.refl _\n#align valuation.mem_valuation_subring_iff Valuation.mem_valuationSubring_iff\n\ntheorem isEquiv_iff_valuationSubring :\n    v₁.IsEquiv v₂ ↔ v₁.valuationSubring = v₂.valuationSubring := by\n  constructor\n  · intro h; ext x; specialize h x 1; simpa using h\n  · intro h; apply isEquiv_of_val_le_one\n    intro x\n    have : x ∈ v₁.valuationSubring ↔ x ∈ v₂.valuationSubring := by rw [h]\n    simpa using this\n#align valuation.is_equiv_iff_valuation_subring Valuation.isEquiv_iff_valuationSubring\n\ntheorem isEquiv_valuation_valuationSubring : v.IsEquiv v.valuationSubring.valuation := by\n  rw [isEquiv_iff_val_le_one]\n  intro x\n  rw [ValuationSubring.valuation_le_one_iff]\n  rfl\n#align valuation.is_equiv_valuation_valuation_subring Valuation.isEquiv_valuation_valuationSubring\n\nend Valuation\n\nnamespace ValuationSubring\n\nvariable {K}\nvariable (A : ValuationSubring K)\n\n@[simp]\ntheorem valuationSubring_valuation : A.valuation.valuationSubring = A := by\n  ext; rw [← A.valuation_le_one_iff]; rfl\n#align valuation_subring.valuation_subring_valuation ValuationSubring.valuationSubring_valuation\n\nsection UnitGroup\n\n/-- The unit group of a valuation subring, as a subgroup of `Kˣ`. -/\ndef unitGroup : Subgroup Kˣ :=\n  (A.valuation.toMonoidWithZeroHom.toMonoidHom.comp (Units.coeHom K)).ker\n#align valuation_subring.unit_group ValuationSubring.unitGroup\n\n@[simp]\ntheorem mem_unitGroup_iff (x : Kˣ) : x ∈ A.unitGroup ↔ A.valuation x = 1 := Iff.rfl\n#align valuation_subring.mem_unit_group_iff ValuationSubring.mem_unitGroup_iff\n\n/-- For a valuation subring `A`, `A.unitGroup` agrees with the units of `A`. -/\ndef unitGroupMulEquiv : A.unitGroup ≃* Aˣ where\n  toFun x :=\n    { val := ⟨(x : Kˣ), mem_of_valuation_le_one A _ x.prop.le⟩\n      inv := ⟨((x⁻¹ : A.unitGroup) : Kˣ), mem_of_valuation_le_one _ _ x⁻¹.prop.le⟩\n      -- Porting note: was `Units.mul_inv x`\n      val_inv := Subtype.ext (by simp)\n      -- Porting note: was `Units.inv_mul x`\n      inv_val := Subtype.ext (by simp) }\n  invFun x := ⟨Units.map A.subtype.toMonoidHom x, A.valuation_unit x⟩\n  left_inv a := by ext; rfl\n  right_inv a := by ext; rfl\n  map_mul' a b := by ext; rfl\n#align valuation_subring.unit_group_mul_equiv ValuationSubring.unitGroupMulEquiv\n\n@[simp]\ntheorem coe_unitGroupMulEquiv_apply (a : A.unitGroup) :\n    ((A.unitGroupMulEquiv a : A) : K) = ((a : Kˣ) : K) := rfl\n#align valuation_subring.coe_unit_group_mul_equiv_apply ValuationSubring.coe_unitGroupMulEquiv_apply\n\n@[simp]\ntheorem coe_unitGroupMulEquiv_symm_apply (a : Aˣ) : ((A.unitGroupMulEquiv.symm a : Kˣ) : K) = a :=\n  rfl\n#align valuation_subring.coe_unit_group_mul_equiv_symm_apply ValuationSubring.coe_unitGroupMulEquiv_symm_apply\n\ntheorem unitGroup_le_unitGroup {A B : ValuationSubring K} : A.unitGroup ≤ B.unitGroup ↔ A ≤ B := by\n  constructor\n  · intro h x hx\n    rw [← A.valuation_le_one_iff x, le_iff_lt_or_eq] at hx\n    by_cases h_1 : x = 0; · simp only [h_1, zero_mem]\n    by_cases h_2 : 1 + x = 0\n    · simp only [← add_eq_zero_iff_neg_eq.1 h_2, neg_mem _ _ (one_mem _)]\n    cases' hx with hx hx\n    · have := h (show Units.mk0 _ h_2 ∈ A.unitGroup from A.valuation.map_one_add_of_lt hx)\n      simpa using\n        B.add_mem _ _ (show 1 + x ∈ B from SetLike.coe_mem (B.unitGroupMulEquiv ⟨_, this⟩ : B))\n          (B.neg_mem _ B.one_mem)\n    · have := h (show Units.mk0 x h_1 ∈ A.unitGroup from hx)\n      refine' SetLike.coe_mem (B.unitGroupMulEquiv ⟨_, this⟩ : B)\n  · rintro h x (hx : A.valuation x = 1)\n    apply_fun A.mapOfLE B h at hx\n    simpa using hx\n#align valuation_subring.unit_group_le_unit_group ValuationSubring.unitGroup_le_unitGroup\n\ntheorem unitGroup_injective : Function.Injective (unitGroup : ValuationSubring K → Subgroup _) :=\n  fun A B h => by simpa only [le_antisymm_iff, unitGroup_le_unitGroup] using h\n#align valuation_subring.unit_group_injective ValuationSubring.unitGroup_injective\n\ntheorem eq_iff_unitGroup {A B : ValuationSubring K} : A = B ↔ A.unitGroup = B.unitGroup :=\n  unitGroup_injective.eq_iff.symm\n#align valuation_subring.eq_iff_unit_group ValuationSubring.eq_iff_unitGroup\n\n/-- The map on valuation subrings to their unit groups is an order embedding. -/\ndef unitGroupOrderEmbedding : ValuationSubring K ↪o Subgroup Kˣ where\n  toFun A := A.unitGroup\n  inj' := unitGroup_injective\n  map_rel_iff' {_A _B} := unitGroup_le_unitGroup\n#align valuation_subring.unit_group_order_embedding ValuationSubring.unitGroupOrderEmbedding\n\ntheorem unitGroup_strictMono : StrictMono (unitGroup : ValuationSubring K → Subgroup _) :=\n  unitGroupOrderEmbedding.strictMono\n#align valuation_subring.unit_group_strict_mono ValuationSubring.unitGroup_strictMono\n\nend UnitGroup\n\nsection nonunits\n\n/-- The nonunits of a valuation subring of `K`, as a subsemigroup of `K`-/\ndef nonunits : Subsemigroup K where\n  carrier := {x | A.valuation x < 1}\n  -- Porting note: added `Set.mem_setOf.mp`\n  mul_mem' ha hb := (mul_lt_mul₀ (Set.mem_setOf.mp ha) (Set.mem_setOf.mp hb)).trans_eq <| mul_one _\n#align valuation_subring.nonunits ValuationSubring.nonunits\n\ntheorem mem_nonunits_iff {x : K} : x ∈ A.nonunits ↔ A.valuation x < 1 :=\n  Iff.rfl\n#align valuation_subring.mem_nonunits_iff ValuationSubring.mem_nonunits_iff\n\ntheorem nonunits_le_nonunits {A B : ValuationSubring K} : B.nonunits ≤ A.nonunits ↔ A ≤ B := by\n  constructor\n  · intro h x hx\n    by_cases h_1 : x = 0; · simp only [h_1, zero_mem]\n    rw [← valuation_le_one_iff, ← not_lt, Valuation.one_lt_val_iff _ h_1] at hx ⊢\n    by_contra h_2; exact hx (h h_2)\n  · intro h x hx\n    by_contra h_1; exact not_lt.2 (monotone_mapOfLE _ _ h (not_lt.1 h_1)) hx\n#align valuation_subring.nonunits_le_nonunits ValuationSubring.nonunits_le_nonunits\n\ntheorem nonunits_injective : Function.Injective (nonunits : ValuationSubring K → Subsemigroup _) :=\n  fun A B h => by simpa only [le_antisymm_iff, nonunits_le_nonunits] using h.symm\n#align valuation_subring.nonunits_injective ValuationSubring.nonunits_injective\n\ntheorem nonunits_inj {A B : ValuationSubring K} : A.nonunits = B.nonunits ↔ A = B :=\n  nonunits_injective.eq_iff\n#align valuation_subring.nonunits_inj ValuationSubring.nonunits_inj\n\n/-- The map on valuation subrings to their nonunits is a dual order embedding. -/\ndef nonunitsOrderEmbedding : ValuationSubring K ↪o (Subsemigroup K)ᵒᵈ where\n  toFun A := A.nonunits\n  inj' := nonunits_injective\n  map_rel_iff' {_A _B} := nonunits_le_nonunits\n#align valuation_subring.nonunits_order_embedding ValuationSubring.nonunitsOrderEmbedding\n\nvariable {A}\n\n/-- The elements of `A.nonunits` are those of the maximal ideal of `A` after coercion to `K`.\n\nSee also `mem_nonunits_iff_exists_mem_maximalIdeal`, which gets rid of the coercion to `K`,\nat the expense of a more complicated right hand side.\n -/\ntheorem coe_mem_nonunits_iff {a : A} : (a : K) ∈ A.nonunits ↔ a ∈ LocalRing.maximalIdeal A :=\n  (valuation_lt_one_iff _ _).symm\n#align valuation_subring.coe_mem_nonunits_iff ValuationSubring.coe_mem_nonunits_iff\n\ntheorem nonunits_le : A.nonunits ≤ A.toSubring.toSubmonoid.toSubsemigroup := fun _a ha =>\n  (A.valuation_le_one_iff _).mp (A.mem_nonunits_iff.mp ha).le\n#align valuation_subring.nonunits_le ValuationSubring.nonunits_le\n\ntheorem nonunits_subset : (A.nonunits : Set K) ⊆ A :=\n  nonunits_le\n#align valuation_subring.nonunits_subset ValuationSubring.nonunits_subset\n\n/-- The elements of `A.nonunits` are those of the maximal ideal of `A`.\n\nSee also `coe_mem_nonunits_iff`, which has a simpler right hand side but requires the element\nto be in `A` already.\n -/\ntheorem mem_nonunits_iff_exists_mem_maximalIdeal {a : K} :\n    a ∈ A.nonunits ↔ ∃ ha, (⟨a, ha⟩ : A) ∈ LocalRing.maximalIdeal A :=\n  ⟨fun h => ⟨nonunits_subset h, coe_mem_nonunits_iff.mp h⟩, fun ⟨_, h⟩ =>\n    coe_mem_nonunits_iff.mpr h⟩\n#align valuation_subring.mem_nonunits_iff_exists_mem_maximal_ideal ValuationSubring.mem_nonunits_iff_exists_mem_maximalIdeal\n\n/-- `A.nonunits` agrees with the maximal ideal of `A`, after taking its image in `K`. -/\ntheorem image_maximalIdeal : ((↑) : A → K) '' LocalRing.maximalIdeal A = A.nonunits := by\n  ext a\n  simp only [Set.mem_image, SetLike.mem_coe, mem_nonunits_iff_exists_mem_maximalIdeal]\n  erw [Subtype.exists]\n  simp_rw [exists_and_right, exists_eq_right]\n  -- Porting note: added\n  simp\n#align valuation_subring.image_maximal_ideal ValuationSubring.image_maximalIdeal\n\nend nonunits\n\nsection PrincipalUnitGroup\n\n/-- The principal unit group of a valuation subring, as a subgroup of `Kˣ`. -/\ndef principalUnitGroup : Subgroup Kˣ where\n  carrier := {x | A.valuation (x - 1) < 1}\n  mul_mem' := by\n    intro a b ha hb\n    -- Porting note: added\n    rw [Set.mem_setOf] at ha hb\n    refine' lt_of_le_of_lt _ (max_lt hb ha)\n    -- Porting note: `sub_add_sub_cancel` needed some help\n    rw [← one_mul (A.valuation (b - 1)), ← A.valuation.map_one_add_of_lt ha, add_sub_cancel'_right,\n      ← Valuation.map_mul, mul_sub_one, ← sub_add_sub_cancel (↑(a * b) : K) _ 1]\n    exact A.valuation.map_add _ _\n  one_mem' := by simp\n  inv_mem' := by\n    dsimp\n    intro a ha\n    conv =>\n      lhs\n      rw [← mul_one (A.valuation _), ← A.valuation.map_one_add_of_lt ha]\n    rwa [add_sub_cancel'_right, ← Valuation.map_mul, sub_mul, Units.inv_mul, ← neg_sub, one_mul,\n      Valuation.map_neg]\n#align valuation_subring.principal_unit_group ValuationSubring.principalUnitGroup\n\ntheorem principal_units_le_units : A.principalUnitGroup ≤ A.unitGroup := fun a h => by\n  simpa only [add_sub_cancel'_right] using A.valuation.map_one_add_of_lt h\n#align valuation_subring.principal_units_le_units ValuationSubring.principal_units_le_units\n\ntheorem mem_principalUnitGroup_iff (x : Kˣ) :\n    x ∈ A.principalUnitGroup ↔ A.valuation ((x : K) - 1) < 1 :=\n  Iff.rfl\n#align valuation_subring.mem_principal_unit_group_iff ValuationSubring.mem_principalUnitGroup_iff\n\ntheorem principalUnitGroup_le_principalUnitGroup {A B : ValuationSubring K} :\n    B.principalUnitGroup ≤ A.principalUnitGroup ↔ A ≤ B := by\n  constructor\n  · intro h x hx\n    by_cases h_1 : x = 0; · simp only [h_1, zero_mem]\n    by_cases h_2 : x⁻¹ + 1 = 0\n    · rw [add_eq_zero_iff_eq_neg, inv_eq_iff_eq_inv, inv_neg, inv_one] at h_2\n      simpa only [h_2] using B.neg_mem _ B.one_mem\n    · rw [← valuation_le_one_iff, ← not_lt, Valuation.one_lt_val_iff _ h_1, ← add_sub_cancel x⁻¹, ←\n        Units.val_mk0 h_2, ← mem_principalUnitGroup_iff] at hx ⊢\n      simpa only [hx] using @h (Units.mk0 (x⁻¹ + 1) h_2)\n  · intro h x hx\n    by_contra h_1; exact not_lt.2 (monotone_mapOfLE _ _ h (not_lt.1 h_1)) hx\n#align valuation_subring.principal_unit_group_le_principal_unit_group ValuationSubring.principalUnitGroup_le_principalUnitGroup\n\ntheorem principalUnitGroup_injective :\n    Function.Injective (principalUnitGroup : ValuationSubring K → Subgroup _) := fun A B h => by\n  simpa [le_antisymm_iff, principalUnitGroup_le_principalUnitGroup] using h.symm\n#align valuation_subring.principal_unit_group_injective ValuationSubring.principalUnitGroup_injective\n\ntheorem eq_iff_principalUnitGroup {A B : ValuationSubring K} :\n    A = B ↔ A.principalUnitGroup = B.principalUnitGroup :=\n  principalUnitGroup_injective.eq_iff.symm\n#align valuation_subring.eq_iff_principal_unit_group ValuationSubring.eq_iff_principalUnitGroup\n\n/-- The map on valuation subrings to their principal unit groups is an order embedding. -/\ndef principalUnitGroupOrderEmbedding : ValuationSubring K ↪o (Subgroup Kˣ)ᵒᵈ where\n  toFun A := A.principalUnitGroup\n  inj' := principalUnitGroup_injective\n  map_rel_iff' {_A _B} := principalUnitGroup_le_principalUnitGroup\n#align valuation_subring.principal_unit_group_order_embedding ValuationSubring.principalUnitGroupOrderEmbedding\n\ntheorem coe_mem_principalUnitGroup_iff {x : A.unitGroup} :\n    (x : Kˣ) ∈ A.principalUnitGroup ↔\n      A.unitGroupMulEquiv x ∈ (Units.map (LocalRing.residue A).toMonoidHom).ker := by\n  rw [MonoidHom.mem_ker, Units.ext_iff]\n  let π := Ideal.Quotient.mk (LocalRing.maximalIdeal A); convert_to _ ↔ π _ = 1\n  rw [← π.map_one, ← sub_eq_zero, ← π.map_sub, Ideal.Quotient.eq_zero_iff_mem, valuation_lt_one_iff]\n  simp [mem_principalUnitGroup_iff]\n#align valuation_subring.coe_mem_principal_unit_group_iff ValuationSubring.coe_mem_principalUnitGroup_iff\n\n/-- The principal unit group agrees with the kernel of the canonical map from\nthe units of `A` to the units of the residue field of `A`. -/\ndef principalUnitGroupEquiv :\n    A.principalUnitGroup ≃* (Units.map (LocalRing.residue A).toMonoidHom).ker where\n  toFun x :=\n    ⟨A.unitGroupMulEquiv ⟨_, A.principal_units_le_units x.2⟩,\n      A.coe_mem_principalUnitGroup_iff.1 x.2⟩\n  invFun x :=\n    ⟨A.unitGroupMulEquiv.symm x, by\n      rw [A.coe_mem_principalUnitGroup_iff]; simpa using SetLike.coe_mem x⟩\n  left_inv x := by simp\n  right_inv x := by simp\n  map_mul' x y := rfl\n#align valuation_subring.principal_unit_group_equiv ValuationSubring.principalUnitGroupEquiv\n\n@[simp]\ntheorem principalUnitGroupEquiv_apply (a : A.principalUnitGroup) :\n    (((principalUnitGroupEquiv A a : Aˣ) : A) : K) = (a : Kˣ) :=\n  rfl\n#align valuation_subring.principal_unit_group_equiv_apply ValuationSubring.principalUnitGroupEquiv_apply\n\n@[simp]\ntheorem principalUnitGroup_symm_apply (a : (Units.map (LocalRing.residue A).toMonoidHom).ker) :\n    ((A.principalUnitGroupEquiv.symm a : Kˣ) : K) = ((a : Aˣ) : A) :=\n  rfl\n#align valuation_subring.principal_unit_group_symm_apply ValuationSubring.principalUnitGroup_symm_apply\n\n/-- The canonical map from the unit group of `A` to the units of the residue field of `A`. -/\ndef unitGroupToResidueFieldUnits : A.unitGroup →* (LocalRing.ResidueField A)ˣ :=\n  MonoidHom.comp (Units.map <| (Ideal.Quotient.mk _).toMonoidHom) A.unitGroupMulEquiv.toMonoidHom\n#align valuation_subring.unit_group_to_residue_field_units ValuationSubring.unitGroupToResidueFieldUnits\n\n@[simp]\ntheorem coe_unitGroupToResidueFieldUnits_apply (x : A.unitGroup) :\n    (A.unitGroupToResidueFieldUnits x : LocalRing.ResidueField A) =\n      Ideal.Quotient.mk _ (A.unitGroupMulEquiv x : A) :=\n  rfl\n#align valuation_subring.coe_unit_group_to_residue_field_units_apply ValuationSubring.coe_unitGroupToResidueFieldUnits_apply\n\ntheorem ker_unitGroupToResidueFieldUnits :\n    A.unitGroupToResidueFieldUnits.ker = A.principalUnitGroup.comap A.unitGroup.subtype := by\n  ext\n  -- Porting note: simp fails but rw works\n  -- See https://github.com/leanprover-community/mathlib4/issues/5026\n  -- simp [Subgroup.mem_comap, Subgroup.coeSubtype, coe_mem_principalUnitGroup_iff]\n  rw [Subgroup.mem_comap, Subgroup.coeSubtype, coe_mem_principalUnitGroup_iff]\n  rfl\n  -- simp [Subgroup.mem_comap, Subgroup.coeSubtype, coe_mem_principalUnitGroup_iff]\n#align valuation_subring.ker_unit_group_to_residue_field_units ValuationSubring.ker_unitGroupToResidueFieldUnits\n\ntheorem surjective_unitGroupToResidueFieldUnits :\n    Function.Surjective A.unitGroupToResidueFieldUnits :=\n  (LocalRing.surjective_units_map_of_local_ringHom _ Ideal.Quotient.mk_surjective\n        LocalRing.isLocalRingHom_residue).comp\n    (MulEquiv.surjective _)\n#align valuation_subring.surjective_unit_group_to_residue_field_units ValuationSubring.surjective_unitGroupToResidueFieldUnits\n\n/-- The quotient of the unit group of `A` by the principal unit group of `A` agrees with\nthe units of the residue field of `A`. -/\ndef unitsModPrincipalUnitsEquivResidueFieldUnits :\n    A.unitGroup ⧸ A.principalUnitGroup.comap A.unitGroup.subtype ≃* (LocalRing.ResidueField A)ˣ :=\n  (QuotientGroup.quotientMulEquivOfEq A.ker_unitGroupToResidueFieldUnits.symm).trans\n    (QuotientGroup.quotientKerEquivOfSurjective _ A.surjective_unitGroupToResidueFieldUnits)\n#align valuation_subring.units_mod_principal_units_equiv_residue_field_units ValuationSubring.unitsModPrincipalUnitsEquivResidueFieldUnits\n\n-- Porting note: Lean needs to be reminded of this instance\nlocal instance : MulOneClass ({ x // x ∈ unitGroup A } ⧸\n  Subgroup.comap (Subgroup.subtype (unitGroup A)) (principalUnitGroup A)) := inferInstance\n\n-- @[simp] -- Porting note: not in simpNF\ntheorem unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk :\n    A.unitsModPrincipalUnitsEquivResidueFieldUnits.toMonoidHom.comp (QuotientGroup.mk' _) =\n      A.unitGroupToResidueFieldUnits := rfl\n#align valuation_subring.units_mod_principal_units_equiv_residue_field_units_comp_quotient_group_mk ValuationSubring.unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk\n\n@[simp]\ntheorem unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk_apply\n    (x : A.unitGroup) :\n    A.unitsModPrincipalUnitsEquivResidueFieldUnits.toMonoidHom (QuotientGroup.mk x) =\n      A.unitGroupToResidueFieldUnits x := rfl\n#align valuation_subring.units_mod_principal_units_equiv_residue_field_units_comp_quotient_group_mk_apply ValuationSubring.unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk_apply\n\nend PrincipalUnitGroup\n\n/-! ### Pointwise actions\n\nThis transfers the action from `Subring.pointwiseMulAction`, noting that it only applies when\nthe action is by a group. Notably this provides an instances when `G` is `K ≃+* K`.\n\nThese instances are in the `Pointwise` locale.\n\nThe lemmas in this section are copied from `RingTheory/Subring/Pointwise.lean`; try to keep these\nin sync.\n-/\n\n\nsection PointwiseActions\n\nopen scoped Pointwise\n\nvariable {G : Type*} [Group G] [MulSemiringAction G K]\n\n/-- The action on a valuation subring corresponding to applying the action to every element.\n\nThis is available as an instance in the `Pointwise` locale. -/\ndef pointwiseHasSMul : SMul G (ValuationSubring K) where\n  smul g S :=-- TODO: if we add `ValuationSubring.map` at a later date, we should use it here\n    { g • S.toSubring with\n      mem_or_inv_mem' := fun x =>\n        (mem_or_inv_mem S (g⁻¹ • x)).imp Subring.mem_pointwise_smul_iff_inv_smul_mem.mpr fun h =>\n          Subring.mem_pointwise_smul_iff_inv_smul_mem.mpr <| by rwa [smul_inv''] }\n#align valuation_subring.pointwise_has_smul ValuationSubring.pointwiseHasSMul\n\nscoped[Pointwise] attribute [instance] ValuationSubring.pointwiseHasSMul\n\nopen scoped Pointwise\n\n@[simp]\ntheorem coe_pointwise_smul (g : G) (S : ValuationSubring K) : ↑(g • S) = g • (S : Set K) := rfl\n#align valuation_subring.coe_pointwise_smul ValuationSubring.coe_pointwise_smul\n\n@[simp]\ntheorem pointwise_smul_toSubring (g : G) (S : ValuationSubring K) :\n    (g • S).toSubring = g • S.toSubring := rfl\n#align valuation_subring.pointwise_smul_to_subring ValuationSubring.pointwise_smul_toSubring\n\n/-- The action on a valuation subring corresponding to applying the action to every element.\n\nThis is available as an instance in the `pointwise` locale.\n\nThis is a stronger version of `ValuationSubring.pointwiseSMul`. -/\ndef pointwiseMulAction : MulAction G (ValuationSubring K) :=\n  toSubring_injective.mulAction toSubring pointwise_smul_toSubring\n#align valuation_subring.pointwise_mul_action ValuationSubring.pointwiseMulAction\n\nscoped[Pointwise] attribute [instance] ValuationSubring.pointwiseMulAction\n\nopen scoped Pointwise\n\ntheorem smul_mem_pointwise_smul (g : G) (x : K) (S : ValuationSubring K) : x ∈ S → g • x ∈ g • S :=\n  (Set.smul_mem_smul_set : _ → _ ∈ g • (S : Set K))\n#align valuation_subring.smul_mem_pointwise_smul ValuationSubring.smul_mem_pointwise_smul\n\ntheorem mem_smul_pointwise_iff_exists (g : G) (x : K) (S : ValuationSubring K) :\n    x ∈ g • S ↔ ∃ s : K, s ∈ S ∧ g • s = x :=\n  (Set.mem_smul_set : x ∈ g • (S : Set K) ↔ _)\n#align valuation_subring.mem_smul_pointwise_iff_exists ValuationSubring.mem_smul_pointwise_iff_exists\n\ninstance pointwise_central_scalar [MulSemiringAction Gᵐᵒᵖ K] [IsCentralScalar G K] :\n    IsCentralScalar G (ValuationSubring K) :=\n  ⟨fun g S => toSubring_injective <| op_smul_eq_smul g S.toSubring⟩\n#align valuation_subring.pointwise_central_scalar ValuationSubring.pointwise_central_scalar\n\n@[simp]\ntheorem smul_mem_pointwise_smul_iff {g : G} {S : ValuationSubring K} {x : K} :\n    g • x ∈ g • S ↔ x ∈ S := Set.smul_mem_smul_set_iff\n#align valuation_subring.smul_mem_pointwise_smul_iff ValuationSubring.smul_mem_pointwise_smul_iff\n\ntheorem mem_pointwise_smul_iff_inv_smul_mem {g : G} {S : ValuationSubring K} {x : K} :\n    x ∈ g • S ↔ g⁻¹ • x ∈ S := Set.mem_smul_set_iff_inv_smul_mem\n#align valuation_subring.mem_pointwise_smul_iff_inv_smul_mem ValuationSubring.mem_pointwise_smul_iff_inv_smul_mem\n\ntheorem mem_inv_pointwise_smul_iff {g : G} {S : ValuationSubring K} {x : K} :\n    x ∈ g⁻¹ • S ↔ g • x ∈ S := Set.mem_inv_smul_set_iff\n#align valuation_subring.mem_inv_pointwise_smul_iff ValuationSubring.mem_inv_pointwise_smul_iff\n\n@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff {g : G} {S T : ValuationSubring K} :\n    g • S ≤ g • T ↔ S ≤ T := Set.set_smul_subset_set_smul_iff\n#align valuation_subring.pointwise_smul_le_pointwise_smul_iff ValuationSubring.pointwise_smul_le_pointwise_smul_iff\n\ntheorem pointwise_smul_subset_iff {g : G} {S T : ValuationSubring K} : g • S ≤ T ↔ S ≤ g⁻¹ • T :=\n  Set.set_smul_subset_iff\n#align valuation_subring.pointwise_smul_subset_iff ValuationSubring.pointwise_smul_subset_iff\n\ntheorem subset_pointwise_smul_iff {g : G} {S T : ValuationSubring K} : S ≤ g • T ↔ g⁻¹ • S ≤ T :=\n  Set.subset_set_smul_iff\n#align valuation_subring.subset_pointwise_smul_iff ValuationSubring.subset_pointwise_smul_iff\n\nend PointwiseActions\n\nsection\n\nvariable {L J : Type*} [Field L] [Field J]\n\n/-- The pullback of a valuation subring `A` along a ring homomorphism `K →+* L`. -/\ndef comap (A : ValuationSubring L) (f : K →+* L) : ValuationSubring K :=\n  { A.toSubring.comap f with mem_or_inv_mem' := fun k => by simp [ValuationSubring.mem_or_inv_mem] }\n#align valuation_subring.comap ValuationSubring.comap\n\n@[simp]\ntheorem coe_comap (A : ValuationSubring L) (f : K →+* L) : (A.comap f : Set K) = f ⁻¹' A := rfl\n#align valuation_subring.coe_comap ValuationSubring.coe_comap\n\n@[simp]\ntheorem mem_comap {A : ValuationSubring L} {f : K →+* L} {x : K} : x ∈ A.comap f ↔ f x ∈ A :=\n  Iff.rfl\n#align valuation_subring.mem_comap ValuationSubring.mem_comap\n\ntheorem comap_comap (A : ValuationSubring J) (g : L →+* J) (f : K →+* L) :\n    (A.comap g).comap f = A.comap (g.comp f) := rfl\n#align valuation_subring.comap_comap ValuationSubring.comap_comap\n\nend\n\nend ValuationSubring\n\nnamespace Valuation\n\nvariable {Γ : Type*} [LinearOrderedCommGroupWithZero Γ] (v : Valuation K Γ) (x : Kˣ)\n\n-- @[simp] -- Porting note: not in simpNF\ntheorem mem_unitGroup_iff : x ∈ v.valuationSubring.unitGroup ↔ v x = 1 :=\n  (Valuation.isEquiv_iff_val_eq_one _ _).mp (Valuation.isEquiv_valuation_valuationSubring _).symm\n#align valuation.mem_unit_group_iff Valuation.mem_unitGroup_iff\n\nend Valuation\n\"}"
"\n"
"{\"text\": \"/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n/-!\n# Lemmas about quotients in characteristic zero\n-/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n/-- `z • r` is a multiple of `p` iff `r` is `pk/z` above a multiple of `p`, where `0 ≤ k < |z|`. -/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : ℤ} (hz : z ≠ 0) :\n    z • r ∈ AddSubgroup.zmultiples p ↔\n      ∃ k : Fin z.natAbs, r - (k : ℕ) • (p / z : R) ∈ AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, ← smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) ≠ 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [← (mul_right_injective₀ hz').eq_iff]\n  simp_rw [← zsmul_eq_mul, smul_add, ← mul_smul_comm, zsmul_eq_mul (z : R)⁻¹, mul_inv_cancel hz',\n    mul_one, ← coe_nat_zsmul, smul_smul, ← add_smul]\n  constructor\n  · rintro ⟨k, h⟩\n    simp_rw [← h]\n    refine' ⟨⟨(k % z).toNat, _⟩, k / z, _⟩\n    · rw [← Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [← Int.div_add_mod k z]\n    rw [Int.mod_def, ← Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  · rintro ⟨k, n, h⟩\n    exact ⟨_, h⟩\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : ℕ} (hn : n ≠ 0) :\n    n • r ∈ AddSubgroup.zmultiples p ↔\n      ∃ k : Fin n, r - (k : ℕ) • (p / n : R) ∈ AddSubgroup.zmultiples p := by\n  rw [← coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {ψ θ : R ⧸ AddSubgroup.zmultiples p} {z : ℤ} (hz : z ≠ 0) :\n    z • ψ = z • θ ↔ ∃ k : Fin z.natAbs, ψ = θ + (k : ℕ) • (p / z : R) := by\n  induction ψ using Quotient.inductionOn'\n  induction θ using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R → R ⧸ Zp) = ((↑) : R → R ⧸ Zp) := rfl\n  simp only [this]\n  simp_rw [← QuotientAddGroup.mk_zsmul, ← QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, ← smul_sub, ← sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {ψ θ : R ⧸ AddSubgroup.zmultiples p} {n : ℕ} (hz : n ≠ 0) :\n    n • ψ = n • θ ↔ ∃ k : Fin n, ψ = θ + (k : ℕ) • (p / n : R) := by\n  rw [← coe_nat_zsmul ψ, ← coe_nat_zsmul θ,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_nsmul_iff\n\nend QuotientAddGroup\n\"}"
"\n"
"{\"text\": \"/-\nCopyright (c) 2021 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin\n-/\nimport Mathlib.Algebra.Homology.HomologicalComplex\n\n#align_import algebra.homology.functor from \"leanprover-community/mathlib\"@\"8e25bb6c1645bb80670e13848b79a54aa45cb84f\"\n\n/-!\n# Complexes in functor categories\n\nWe can view a complex valued in a functor category `T ⥤ V` as\na functor from `T` to complexes valued in `V`.\n\n## Future work\nIn fact this is an equivalence of categories.\n\n-/\n\n\nuniverse v u\n\nopen CategoryTheory\n\nopen CategoryTheory.Limits\n\nnamespace HomologicalComplex\n\nvariable {V : Type u} [Category.{v} V] [HasZeroMorphisms V]\n\nvariable {ι : Type*} {c : ComplexShape ι}\n\n/-- A complex of functors gives a functor to complexes. -/\n@[simps obj map]\ndef asFunctor {T : Type*} [Category T] (C : HomologicalComplex (T ⥤ V) c) :\n    T ⥤ HomologicalComplex V c where\n  obj t :=\n    { X := fun i => (C.X i).obj t\n      d := fun i j => (C.d i j).app t\n      d_comp_d' := fun i j k _ _ => by\n        have := C.d_comp_d i j k\n        rw [NatTrans.ext_iff, Function.funext_iff] at this\n        exact this t\n      shape := fun i j h => by\n        have := C.shape _ _ h\n        rw [NatTrans.ext_iff, Function.funext_iff] at this\n        exact this t }\n  map h :=\n    { f := fun i => (C.X i).map h\n      comm' := fun i j _ => NatTrans.naturality _ _ }\n  map_id t := by\n    ext i\n    dsimp\n    rw [(C.X i).map_id]\n  map_comp h₁ h₂ := by\n    ext i\n    dsimp\n    rw [Functor.map_comp]\n#align homological_complex.as_functor HomologicalComplex.asFunctor\n\n-- TODO in fact, this is an equivalence of categories.\n/-- The functorial version of `HomologicalComplex.asFunctor`. -/\n@[simps]\ndef complexOfFunctorsToFunctorToComplex {T : Type*} [Category T] :\n    HomologicalComplex (T ⥤ V) c ⥤ T ⥤ HomologicalComplex V c where\n  obj C := C.asFunctor\n  map f :=\n    { app := fun t =>\n        { f := fun i => (f.f i).app t\n          comm' := fun i j _ => NatTrans.congr_app (f.comm i j) t }\n      naturality := fun t t' g => by\n        ext i\n        exact (f.f i).naturality g }\n#align homological_complex.complex_of_functors_to_functor_to_complex HomologicalComplex.complexOfFunctorsToFunctorToComplex\n\nend HomologicalComplex\n\"}"
"\n"
"{\"text\": \"/-\nCopyright (c) 2020 Bhavik Mehta. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Bhavik Mehta\n-/\nimport Mathlib.CategoryTheory.Limits.Shapes.Reflexive\nimport Mathlib.CategoryTheory.Limits.Shapes.SplitCoequalizer\nimport Mathlib.CategoryTheory.Monad.Algebra\n\n#align_import category_theory.monad.coequalizer from \"leanprover-community/mathlib\"@\"3a061790136d13594ec10c7c90d202335ac5d854\"\n\n/-!\n# Special coequalizers associated to a monad\n\nAssociated to a monad `T : C ⥤ C` we have important coequalizer constructions:\nAny algebra is a coequalizer (in the category of algebras) of free algebras. Furthermore, this\ncoequalizer is reflexive.\nIn `C`, this cofork diagram is a split coequalizer (in particular, it is still a coequalizer).\nThis split coequalizer is known as the Beck coequalizer (as it features heavily in Beck's\nmonadicity theorem).\n-/\n\n\nuniverse v₁ u₁\n\nnamespace CategoryTheory\n\nnamespace Monad\n\nopen Limits\n\nvariable {C : Type u₁}\n\nvariable [Category.{v₁} C]\n\nvariable {T : Monad C} (X : Algebra T)\n\n/-!\nShow that any algebra is a coequalizer of free algebras.\n-/\n\n\n/-- The top map in the coequalizer diagram we will construct. -/\n@[simps!]\ndef FreeCoequalizer.topMap : (Monad.free T).obj (T.obj X.A) ⟶ (Monad.free T).obj X.A :=\n  (Monad.free T).map X.a\n#align category_theory.monad.free_coequalizer.top_map CategoryTheory.Monad.FreeCoequalizer.topMap\n\n/-- The bottom map in the coequalizer diagram we will construct. -/\n@[simps]\ndef FreeCoequalizer.bottomMap : (Monad.free T).obj (T.obj X.A) ⟶ (Monad.free T).obj X.A where\n  f := T.μ.app X.A\n  h := T.assoc X.A\n#align category_theory.monad.free_coequalizer.bottom_map CategoryTheory.Monad.FreeCoequalizer.bottomMap\n\n/-- The cofork map in the coequalizer diagram we will construct. -/\n@[simps]\ndef FreeCoequalizer.π : (Monad.free T).obj X.A ⟶ X where\n  f := X.a\n  h := X.assoc.symm\n#align category_theory.monad.free_coequalizer.π CategoryTheory.Monad.FreeCoequalizer.π\n\ntheorem FreeCoequalizer.condition :\n    FreeCoequalizer.topMap X ≫ FreeCoequalizer.π X =\n      FreeCoequalizer.bottomMap X ≫ FreeCoequalizer.π X :=\n  Algebra.Hom.ext _ _ X.assoc.symm\n#align category_theory.monad.free_coequalizer.condition CategoryTheory.Monad.FreeCoequalizer.condition\n\ninstance : IsReflexivePair (FreeCoequalizer.topMap X) (FreeCoequalizer.bottomMap X) := by\n  apply IsReflexivePair.mk' _ _ _\n  apply (free T).map (T.η.app X.A)\n  · ext\n    dsimp\n    rw [← Functor.map_comp, X.unit, Functor.map_id]\n  · ext\n    apply Monad.right_unit\n\n/-- Construct the Beck cofork in the category of algebras. This cofork is reflexive as well as a\ncoequalizer.\n-/\n@[simps!]\ndef beckAlgebraCofork : Cofork (FreeCoequalizer.topMap X) (FreeCoequalizer.bottomMap X) :=\n  Cofork.ofπ _ (FreeCoequalizer.condition X)\n#align category_theory.monad.beck_algebra_cofork CategoryTheory.Monad.beckAlgebraCofork\n\n/-- The cofork constructed is a colimit. This shows that any algebra is a (reflexive) coequalizer of\nfree algebras.\n-/\ndef beckAlgebraCoequalizer : IsColimit (beckAlgebraCofork X) :=\n  Cofork.IsColimit.mk' _ fun s => by\n    have h₁ : (T : C ⥤ C).map X.a ≫ s.π.f = T.μ.app X.A ≫ s.π.f :=\n      congr_arg Monad.Algebra.Hom.f s.condition\n    have h₂ : (T : C ⥤ C).map s.π.f ≫ s.pt.a = T.μ.app X.A ≫ s.π.f := s.π.h\n    refine' ⟨⟨T.η.app _ ≫ s.π.f, _⟩, _, _⟩\n    · dsimp\n      rw [Functor.map_comp, Category.assoc, h₂, Monad.right_unit_assoc,\n        show X.a ≫ _ ≫ _ = _ from T.η.naturality_assoc _ _, h₁, Monad.left_unit_assoc]\n    · ext\n      simpa [← T.η.naturality_assoc, T.left_unit_assoc] using T.η.app ((T : C ⥤ C).obj X.A) ≫= h₁\n    · intro m hm\n      ext\n      dsimp only\n      rw [← hm]\n      apply (X.unit_assoc _).symm\n#align category_theory.monad.beck_algebra_coequalizer CategoryTheory.Monad.beckAlgebraCoequalizer\n\n/-- The Beck cofork is a split coequalizer. -/\ndef beckSplitCoequalizer : IsSplitCoequalizer (T.map X.a) (T.μ.app _) X.a :=\n  ⟨T.η.app _, T.η.app _, X.assoc.symm, X.unit, T.left_unit _, (T.η.naturality _).symm⟩\n#align category_theory.monad.beck_split_coequalizer CategoryTheory.Monad.beckSplitCoequalizer\n\n/-- This is the Beck cofork. It is a split coequalizer, in particular a coequalizer. -/\n@[simps! pt]\ndef beckCofork : Cofork (T.map X.a) (T.μ.app _) :=\n  (beckSplitCoequalizer X).asCofork\n#align category_theory.monad.beck_cofork CategoryTheory.Monad.beckCofork\n\n@[simp]\ntheorem beckCofork_π : (beckCofork X).π = X.a :=\n  rfl\n#align category_theory.monad.beck_cofork_π CategoryTheory.Monad.beckCofork_π\n\n/-- The Beck cofork is a coequalizer. -/\ndef beckCoequalizer : IsColimit (beckCofork X) :=\n  (beckSplitCoequalizer X).isCoequalizer\n#align category_theory.monad.beck_coequalizer CategoryTheory.Monad.beckCoequalizer\n\n@[simp]\ntheorem beckCoequalizer_desc (s : Cofork (T.toFunctor.map X.a) (T.μ.app X.A)) :\n    (beckCoequalizer X).desc s = T.η.app _ ≫ s.π :=\n  rfl\n#align category_theory.monad.beck_coequalizer_desc CategoryTheory.Monad.beckCoequalizer_desc\n\nend Monad\n\nend CategoryTheory\n\"}"
"\n"
"{\"text\": \"/-\nCopyright (c) 2014 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Leonardo de Moura\n-/\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.Algebra.GroupWithZero.Divisibility\nimport Mathlib.Data.Nat.Order.Lemmas\nimport Mathlib.Tactic.NthRewrite\n\n#align_import data.nat.gcd.basic from \"leanprover-community/mathlib\"@\"e8638a0fcaf73e4500469f368ef9494e495099b3\"\n\n/-!\n# Definitions and properties of `Nat.gcd`, `Nat.lcm`, and `Nat.coprime`\n\nGeneralizations of these are provided in a later file as `GCDMonoid.gcd` and\n`GCDMonoid.lcm`.\n\nNote that the global `IsCoprime` is not a straightforward generalization of `Nat.coprime`, see\n`Nat.isCoprime_iff_coprime` for the connection between the two.\n\n-/\n\nnamespace Nat\n\n/-! ### `gcd` -/\n\ntheorem gcd_greatest {a b d : ℕ} (hda : d ∣ a) (hdb : d ∣ b) (hd : ∀ e : ℕ, e ∣ a → e ∣ b → e ∣ d) :\n    d = a.gcd b :=\n  (dvd_antisymm (hd _ (gcd_dvd_left a b) (gcd_dvd_right a b)) (dvd_gcd hda hdb)).symm\n#align nat.gcd_greatest Nat.gcd_greatest\n\n-- Lemmas where one argument consists of addition of a multiple of the other\n@[simp]\ntheorem gcd_add_mul_right_right (m n k : ℕ) : gcd m (n + k * m) = gcd m n := by\n  simp [gcd_rec m (n + k * m), gcd_rec m n]\n#align nat.gcd_add_mul_right_right Nat.gcd_add_mul_right_right\n\n@[simp]\ntheorem gcd_add_mul_left_right (m n k : ℕ) : gcd m (n + m * k) = gcd m n := by\n  simp [gcd_rec m (n + m * k), gcd_rec m n]\n#align nat.gcd_add_mul_left_right Nat.gcd_add_mul_left_right\n\n@[simp]\ntheorem gcd_mul_right_add_right (m n k : ℕ) : gcd m (k * m + n) = gcd m n := by simp [add_comm _ n]\n#align nat.gcd_mul_right_add_right Nat.gcd_mul_right_add_right\n\n@[simp]\ntheorem gcd_mul_left_add_right (m n k : ℕ) : gcd m (m * k + n) = gcd m n := by simp [add_comm _ n]\n#align nat.gcd_mul_left_add_right Nat.gcd_mul_left_add_right\n\n@[simp]\ntheorem gcd_add_mul_right_left (m n k : ℕ) : gcd (m + k * n) n = gcd m n := by\n  rw [gcd_comm, gcd_add_mul_right_right, gcd_comm]\n#align nat.gcd_add_mul_right_left Nat.gcd_add_mul_right_left\n\n@[simp]\ntheorem gcd_add_mul_left_left (m n k : ℕ) : gcd (m + n * k) n = gcd m n := by\n  rw [gcd_comm, gcd_add_mul_left_right, gcd_comm]\n#align nat.gcd_add_mul_left_left Nat.gcd_add_mul_left_left\n\n@[simp]\ntheorem gcd_mul_right_add_left (m n k : ℕ) : gcd (k * n + m) n = gcd m n := by\n  rw [gcd_comm, gcd_mul_right_add_right, gcd_comm]\n#align nat.gcd_mul_right_add_left Nat.gcd_mul_right_add_left\n\n@[simp]\ntheorem gcd_mul_left_add_left (m n k : ℕ) : gcd (n * k + m) n = gcd m n := by\n  rw [gcd_comm, gcd_mul_left_add_right, gcd_comm]\n#align nat.gcd_mul_left_add_left Nat.gcd_mul_left_add_left\n\n-- Lemmas where one argument consists of an addition of the other\n@[simp]\ntheorem gcd_add_self_right (m n : ℕ) : gcd m (n + m) = gcd m n :=\n  Eq.trans (by rw [one_mul]) (gcd_add_mul_right_right m n 1)\n#align nat.gcd_add_self_right Nat.gcd_add_self_right\n\n@[simp]\ntheorem gcd_add_self_left (m n : ℕ) : gcd (m + n) n = gcd m n := by\n  rw [gcd_comm, gcd_add_self_right, gcd_comm]\n#align nat.gcd_add_self_left Nat.gcd_add_self_left\n\n@[simp]\ntheorem gcd_self_add_left (m n : ℕ) : gcd (m + n) m = gcd n m := by rw [add_comm, gcd_add_self_left]\n#align nat.gcd_self_add_left Nat.gcd_self_add_left\n\n@[simp]\ntheorem gcd_self_add_right (m n : ℕ) : gcd m (m + n) = gcd m n := by\n  rw [add_comm, gcd_add_self_right]\n#align nat.gcd_self_add_right Nat.gcd_self_add_right\n\n-- Lemmas where one argument consists of a subtraction of the other\n@[simp]\ntheorem gcd_sub_self_left {m n : ℕ} (h : m ≤ n) : gcd (n - m) m = gcd n m := by\n  calc\n    gcd (n - m) m = gcd (n - m + m) m  := by rw [← gcd_add_self_left (n - m) m]\n                _ = gcd n m := by rw [Nat.sub_add_cancel h]\n\n@[simp]\ntheorem gcd_sub_self_right {m n : ℕ} (h : m ≤ n) : gcd m (n - m) = gcd m n := by\n  rw [gcd_comm, gcd_sub_self_left h, gcd_comm]\n\n@[simp]\ntheorem gcd_self_sub_left {m n : ℕ} (h : m ≤ n) : gcd (n - m) n = gcd m n := by\n  have := Nat.sub_add_cancel h\n  rw [gcd_comm m n, ← this, gcd_add_self_left (n - m) m]\n  have : gcd (n - m) n = gcd (n - m) m := by\n    nth_rw 2 [← Nat.add_sub_cancel' h]\n    rw [gcd_add_self_right, gcd_comm]\n  convert this\n\n@[simp]\ntheorem gcd_self_sub_right {m n : ℕ} (h : m ≤ n) : gcd n (n - m) = gcd n m := by\n  rw [gcd_comm, gcd_self_sub_left h, gcd_comm]\n\n/-! ### `lcm` -/\n\ntheorem lcm_dvd_mul (m n : ℕ) : lcm m n ∣ m * n :=\n  lcm_dvd (dvd_mul_right _ _) (dvd_mul_left _ _)\n#align nat.lcm_dvd_mul Nat.lcm_dvd_mul\n\ntheorem lcm_dvd_iff {m n k : ℕ} : lcm m n ∣ k ↔ m ∣ k ∧ n ∣ k :=\n  ⟨fun h => ⟨(dvd_lcm_left _ _).trans h, (dvd_lcm_right _ _).trans h⟩, and_imp.2 lcm_dvd⟩\n#align nat.lcm_dvd_iff Nat.lcm_dvd_iff\n\ntheorem lcm_pos {m n : ℕ} : 0 < m → 0 < n → 0 < m.lcm n := by\n  simp_rw [pos_iff_ne_zero]\n  exact lcm_ne_zero\n#align nat.lcm_pos Nat.lcm_pos\n\n/-!\n### `Coprime`\n\nSee also `Nat.coprime_of_dvd` and `Nat.coprime_of_dvd'` to prove `Nat.Coprime m n`.\n-/\n\ninstance (m n : ℕ) : Decidable (Coprime m n) := inferInstanceAs (Decidable (gcd m n = 1))\n\ntheorem Coprime.lcm_eq_mul {m n : ℕ} (h : Coprime m n) : lcm m n = m * n := by\n  rw [← one_mul (lcm m n), ← h.gcd_eq_one, gcd_mul_lcm]\n#align nat.coprime.lcm_eq_mul Nat.Coprime.lcm_eq_mul\n\ntheorem Coprime.symmetric : Symmetric Coprime := fun _ _ => Coprime.symm\n#align nat.coprime.symmetric Nat.Coprime.symmetric\n\ntheorem Coprime.dvd_mul_right {m n k : ℕ} (H : Coprime k n) : k ∣ m * n ↔ k ∣ m :=\n  ⟨H.dvd_of_dvd_mul_right, fun h => dvd_mul_of_dvd_left h n⟩\n#align nat.coprime.dvd_mul_right Nat.Coprime.dvd_mul_right\n\ntheorem Coprime.dvd_mul_left {m n k : ℕ} (H : Coprime k m) : k ∣ m * n ↔ k ∣ n :=\n  ⟨H.dvd_of_dvd_mul_left, fun h => dvd_mul_of_dvd_right h m⟩\n#align nat.coprime.dvd_mul_left Nat.Coprime.dvd_mul_left\n\n@[simp]\ntheorem coprime_add_self_right {m n : ℕ} : Coprime m (n + m) ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_self_right]\n#align nat.coprime_add_self_right Nat.coprime_add_self_right\n\n@[simp]\ntheorem coprime_self_add_right {m n : ℕ} : Coprime m (m + n) ↔ Coprime m n := by\n  rw [add_comm, coprime_add_self_right]\n#align nat.coprime_self_add_right Nat.coprime_self_add_right\n\n@[simp]\ntheorem coprime_add_self_left {m n : ℕ} : Coprime (m + n) n ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_self_left]\n#align nat.coprime_add_self_left Nat.coprime_add_self_left\n\n@[simp]\ntheorem coprime_self_add_left {m n : ℕ} : Coprime (m + n) m ↔ Coprime n m := by\n  rw [Coprime, Coprime, gcd_self_add_left]\n#align nat.coprime_self_add_left Nat.coprime_self_add_left\n\n@[simp]\ntheorem coprime_add_mul_right_right (m n k : ℕ) : Coprime m (n + k * m) ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_mul_right_right]\n#align nat.coprime_add_mul_right_right Nat.coprime_add_mul_right_right\n\n@[simp]\ntheorem coprime_add_mul_left_right (m n k : ℕ) : Coprime m (n + m * k) ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_mul_left_right]\n#align nat.coprime_add_mul_left_right Nat.coprime_add_mul_left_right\n\n@[simp]\ntheorem coprime_mul_right_add_right (m n k : ℕ) : Coprime m (k * m + n) ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_mul_right_add_right]\n#align nat.coprime_mul_right_add_right Nat.coprime_mul_right_add_right\n\n@[simp]\ntheorem coprime_mul_left_add_right (m n k : ℕ) : Coprime m (m * k + n) ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_mul_left_add_right]\n#align nat.coprime_mul_left_add_right Nat.coprime_mul_left_add_right\n\n@[simp]\ntheorem coprime_add_mul_right_left (m n k : ℕ) : Coprime (m + k * n) n ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_mul_right_left]\n#align nat.coprime_add_mul_right_left Nat.coprime_add_mul_right_left\n\n@[simp]\ntheorem coprime_add_mul_left_left (m n k : ℕ) : Coprime (m + n * k) n ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_add_mul_left_left]\n#align nat.coprime_add_mul_left_left Nat.coprime_add_mul_left_left\n\n@[simp]\ntheorem coprime_mul_right_add_left (m n k : ℕ) : Coprime (k * n + m) n ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_mul_right_add_left]\n#align nat.coprime_mul_right_add_left Nat.coprime_mul_right_add_left\n\n@[simp]\ntheorem coprime_mul_left_add_left (m n k : ℕ) : Coprime (n * k + m) n ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_mul_left_add_left]\n#align nat.coprime_mul_left_add_left Nat.coprime_mul_left_add_left\n\n@[simp]\ntheorem coprime_sub_self_left {m n : ℕ} (h : m ≤ n) : Coprime (n - m) m ↔ Coprime n m := by\n  rw [Coprime, Coprime, gcd_sub_self_left h]\n\n@[simp]\ntheorem coprime_sub_self_right {m n : ℕ} (h : m ≤ n) : Coprime m (n - m) ↔ Coprime m n:= by\n  rw [Coprime, Coprime, gcd_sub_self_right h]\n\n@[simp]\ntheorem coprime_self_sub_left {m n : ℕ} (h : m ≤ n) : Coprime (n - m) n ↔ Coprime m n := by\n  rw [Coprime, Coprime, gcd_self_sub_left h]\n\n@[simp]\ntheorem coprime_self_sub_right {m n : ℕ} (h : m ≤ n) : Coprime n (n - m) ↔ Coprime n m := by\n  rw [Coprime, Coprime, gcd_self_sub_right h]\n\n@[simp]\ntheorem coprime_pow_left_iff {n : ℕ} (hn : 0 < n) (a b : ℕ) :\n    Nat.Coprime (a ^ n) b ↔ Nat.Coprime a b := by\n  obtain ⟨n, rfl⟩ := exists_eq_succ_of_ne_zero hn.ne'\n  rw [pow_succ, Nat.coprime_mul_iff_left]\n  exact ⟨And.right, fun hab => ⟨hab.pow_left _, hab⟩⟩\n#align nat.coprime_pow_left_iff Nat.coprime_pow_left_iff\n\n@[simp]\ntheorem coprime_pow_right_iff {n : ℕ} (hn : 0 < n) (a b : ℕ) :\n    Nat.Coprime a (b ^ n) ↔ Nat.Coprime a b := by\n  rw [Nat.coprime_comm, coprime_pow_left_iff hn, Nat.coprime_comm]\n#align nat.coprime_pow_right_iff Nat.coprime_pow_right_iff\n\ntheorem not_coprime_zero_zero : ¬Coprime 0 0 := by simp\n#align nat.not_coprime_zero_zero Nat.not_coprime_zero_zero\n\ntheorem coprime_one_left_iff (n : ℕ) : Coprime 1 n ↔ True := by simp [Coprime]\n#align nat.coprime_one_left_iff Nat.coprime_one_left_iff\n\ntheorem coprime_one_right_iff (n : ℕ) : Coprime n 1 ↔ True := by simp [Coprime]\n#align nat.coprime_one_right_iff Nat.coprime_one_right_iff\n\ntheorem gcd_mul_of_coprime_of_dvd {a b c : ℕ} (hac : Coprime a c) (b_dvd_c : b ∣ c) :\n    gcd (a * b) c = b := by\n  rcases exists_eq_mul_left_of_dvd b_dvd_c with ⟨d, rfl⟩\n  rw [gcd_mul_right]\n  convert one_mul b\n  exact Coprime.coprime_mul_right_right hac\n#align nat.gcd_mul_of_coprime_of_dvd Nat.gcd_mul_of_coprime_of_dvd\n\ntheorem Coprime.eq_of_mul_eq_zero {m n : ℕ} (h : m.Coprime n) (hmn : m * n = 0) :\n    m = 0 ∧ n = 1 ∨ m = 1 ∧ n = 0 :=\n  (Nat.eq_zero_of_mul_eq_zero hmn).imp (fun hm => ⟨hm, n.coprime_zero_left.mp <| hm ▸ h⟩) fun hn =>\n    let eq := hn ▸ h.symm\n    ⟨m.coprime_zero_left.mp <| eq, hn⟩\n#align nat.coprime.eq_of_mul_eq_zero Nat.Coprime.eq_of_mul_eq_zero\n\n/-- Represent a divisor of `m * n` as a product of a divisor of `m` and a divisor of `n`.\n\nSee `exists_dvd_and_dvd_of_dvd_mul` for the more general but less constructive version for other\n`GCDMonoid`s. -/\ndef prodDvdAndDvdOfDvdProd {m n k : ℕ} (H : k ∣ m * n) :\n    { d : { m' // m' ∣ m } × { n' // n' ∣ n } // k = d.1 * d.2 } := by\n  cases h0 : gcd k m\n  case zero =>\n    obtain rfl : k = 0 := eq_zero_of_gcd_eq_zero_left h0\n    obtain rfl : m = 0 := eq_zero_of_gcd_eq_zero_right h0\n    exact ⟨⟨⟨0, dvd_refl 0⟩, ⟨n, dvd_refl n⟩⟩, (zero_mul n).symm⟩\n  case succ tmp =>\n    have hpos : 0 < gcd k m := h0.symm ▸ Nat.zero_lt_succ _; clear h0 tmp\n    have hd : gcd k m * (k / gcd k m) = k := Nat.mul_div_cancel' (gcd_dvd_left k m)\n    refine' ⟨⟨⟨gcd k m, gcd_dvd_right k m⟩, ⟨k / gcd k m, _⟩⟩, hd.symm⟩\n    apply Nat.dvd_of_mul_dvd_mul_left hpos\n    rw [hd, ← gcd_mul_right]\n    exact dvd_gcd (dvd_mul_right _ _) H\n#align nat.prod_dvd_and_dvd_of_dvd_prod Nat.prodDvdAndDvdOfDvdProd\n\ntheorem dvd_mul {x m n : ℕ} : x ∣ m * n ↔ ∃ y z, y ∣ m ∧ z ∣ n ∧ y * z = x := by\n  constructor\n  · intro h\n    obtain ⟨⟨⟨y, hy⟩, ⟨z, hz⟩⟩, rfl⟩ := prod_dvd_and_dvd_of_dvd_prod h\n    exact ⟨y, z, hy, hz, rfl⟩\n  · rintro ⟨y, z, hy, hz, rfl⟩\n    exact mul_dvd_mul hy hz\n#align nat.dvd_mul Nat.dvd_mul\n\ntheorem pow_dvd_pow_iff {a b n : ℕ} (n0 : 0 < n) : a ^ n ∣ b ^ n ↔ a ∣ b := by\n  refine' ⟨fun h => _, fun h => pow_dvd_pow_of_dvd h _⟩\n  cases' Nat.eq_zero_or_pos (gcd a b) with g0 g0\n  · simp [eq_zero_of_gcd_eq_zero_right g0]\n  rcases exists_coprime' g0 with ⟨g, a', b', g0', co, rfl, rfl⟩\n  rw [mul_pow, mul_pow] at h\n  replace h := Nat.dvd_of_mul_dvd_mul_right (pow_pos g0' _) h\n  have := pow_dvd_pow a' n0\n  rw [pow_one, (co.pow n n).eq_one_of_dvd h] at this\n  simp [eq_one_of_dvd_one this]\n#align nat.pow_dvd_pow_iff Nat.pow_dvd_pow_iff\n\n/-- If `k:ℕ` divides coprime `a` and `b` then `k = 1` -/\ntheorem eq_one_of_dvd_coprimes {a b k : ℕ} (h_ab_coprime : Coprime a b) (hka : k ∣ a)\n    (hkb : k ∣ b) : k = 1 := by\n  rw [coprime_iff_gcd_eq_one] at h_ab_coprime\n  have h1 := dvd_gcd hka hkb\n  rw [h_ab_coprime] at h1\n  exact Nat.dvd_one.mp h1\n#align nat.eq_one_of_dvd_coprimes Nat.eq_one_of_dvd_coprimes\n\ntheorem Coprime.mul_add_mul_ne_mul {m n a b : ℕ} (cop : Coprime m n) (ha : a ≠ 0) (hb : b ≠ 0) :\n    a * m + b * n ≠ m * n := by\n  intro h\n  obtain ⟨x, rfl⟩ : n ∣ a :=\n    cop.symm.dvd_of_dvd_mul_right\n      ((Nat.dvd_add_iff_left (Nat.dvd_mul_left n b)).mpr\n        ((congr_arg _ h).mpr (Nat.dvd_mul_left n m)))\n  obtain ⟨y, rfl⟩ : m ∣ b :=\n    cop.dvd_of_dvd_mul_right\n      ((Nat.dvd_add_iff_right (Nat.dvd_mul_left m (n * x))).mpr\n        ((congr_arg _ h).mpr (Nat.dvd_mul_right m n)))\n  rw [mul_comm, mul_ne_zero_iff, ← one_le_iff_ne_zero] at ha hb\n  refine' mul_ne_zero hb.2 ha.2 (eq_zero_of_mul_eq_self_left (ne_of_gt (add_le_add ha.1 hb.1)) _)\n  rw [← mul_assoc, ← h, add_mul, add_mul, mul_comm _ n, ← mul_assoc, mul_comm y]\n#align nat.coprime.mul_add_mul_ne_mul Nat.Coprime.mul_add_mul_ne_mul\n\nend Nat\n\"}"
"\n"
"{\"text\": \"/-\nCopyright (c) 2018 Johannes Hölzl. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johannes Hölzl, Mitchell Rowett, Scott Morrison, Johan Commelin, Mario Carneiro,\n  Michael Howes\n-/\nimport Mathlib.GroupTheory.Subgroup.Basic\nimport Mathlib.Deprecated.Submonoid\n\n#align_import deprecated.subgroup from \"leanprover-community/mathlib\"@\"f93c11933efbc3c2f0299e47b8ff83e9b539cbf6\"\n\n/-!\n# Unbundled subgroups (deprecated)\n\nThis file is deprecated, and is no longer imported by anything in mathlib other than other\ndeprecated files, and test files. You should not need to import it.\n\nThis file defines unbundled multiplicative and additive subgroups. Instead of using this file,\nplease use `Subgroup G` and `AddSubgroup A`, defined in `GroupTheory.Subgroup.Basic`.\n\n## Main definitions\n\n`IsAddSubgroup (S : Set A)` : the predicate that `S` is the underlying subset of an additive\nsubgroup of `A`. The bundled variant `AddSubgroup A` should be used in preference to this.\n\n`IsSubgroup (S : Set G)` : the predicate that `S` is the underlying subset of a subgroup\nof `G`. The bundled variant `Subgroup G` should be used in preference to this.\n\n## Tags\n\nsubgroup, subgroups, IsSubgroup\n-/\n\n\nopen Set Function\n\nvariable {G : Type*} {H : Type*} {A : Type*} {a a₁ a₂ b c : G}\n\nsection Group\n\nvariable [Group G] [AddGroup A]\n\n/-- `s` is an additive subgroup: a set containing 0 and closed under addition and negation. -/\nstructure IsAddSubgroup (s : Set A) extends IsAddSubmonoid s : Prop where\n  /-- The proposition that `s` is closed under negation. -/\n  neg_mem {a} : a ∈ s → -a ∈ s\n#align is_add_subgroup IsAddSubgroup\n\n/-- `s` is a subgroup: a set containing 1 and closed under multiplication and inverse. -/\n@[to_additive]\nstructure IsSubgroup (s : Set G) extends IsSubmonoid s : Prop where\n  /-- The proposition that `s` is closed under inverse. -/\n  inv_mem {a} : a ∈ s → a⁻¹ ∈ s\n#align is_subgroup IsSubgroup\n\n@[to_additive]\ntheorem IsSubgroup.div_mem {s : Set G} (hs : IsSubgroup s) {x y : G} (hx : x ∈ s) (hy : y ∈ s) :\n    x / y ∈ s := by simpa only [div_eq_mul_inv] using hs.mul_mem hx (hs.inv_mem hy)\n#align is_subgroup.div_mem IsSubgroup.div_mem\n#align is_add_subgroup.sub_mem IsAddSubgroup.sub_mem\n\ntheorem Additive.isAddSubgroup {s : Set G} (hs : IsSubgroup s) : @IsAddSubgroup (Additive G) _ s :=\n  @IsAddSubgroup.mk (Additive G) _ _ (Additive.isAddSubmonoid hs.toIsSubmonoid) hs.inv_mem\n#align additive.is_add_subgroup Additive.isAddSubgroup\n\ntheorem Additive.isAddSubgroup_iff {s : Set G} : @IsAddSubgroup (Additive G) _ s ↔ IsSubgroup s :=\n  ⟨by rintro ⟨⟨h₁, h₂⟩, h₃⟩; exact @IsSubgroup.mk G _ _ ⟨h₁, @h₂⟩ @h₃, fun h =>\n    Additive.isAddSubgroup h⟩\n#align additive.is_add_subgroup_iff Additive.isAddSubgroup_iff\n\ntheorem Multiplicative.isSubgroup {s : Set A} (hs : IsAddSubgroup s) :\n    @IsSubgroup (Multiplicative A) _ s :=\n  @IsSubgroup.mk (Multiplicative A) _ _ (Multiplicative.isSubmonoid hs.toIsAddSubmonoid) hs.neg_mem\n#align multiplicative.is_subgroup Multiplicative.isSubgroup\n\ntheorem Multiplicative.isSubgroup_iff {s : Set A} :\n    @IsSubgroup (Multiplicative A) _ s ↔ IsAddSubgroup s :=\n  ⟨by rintro ⟨⟨h₁, h₂⟩, h₃⟩; exact @IsAddSubgroup.mk A _ _ ⟨h₁, @h₂⟩ @h₃, fun h =>\n    Multiplicative.isSubgroup h⟩\n#align multiplicative.is_subgroup_iff Multiplicative.isSubgroup_iff\n\n@[to_additive of_add_neg]\ntheorem IsSubgroup.of_div (s : Set G) (one_mem : (1 : G) ∈ s)\n    (div_mem : ∀ {a b : G}, a ∈ s → b ∈ s → a * b⁻¹ ∈ s) : IsSubgroup s :=\n  have inv_mem : ∀ a, a ∈ s → a⁻¹ ∈ s := fun a ha => by\n    have : 1 * a⁻¹ ∈ s := div_mem one_mem ha\n    convert this using 1\n    rw [one_mul]\n  { inv_mem := inv_mem _\n    mul_mem := fun {a b} ha hb => by\n      have : a * b⁻¹⁻¹ ∈ s := div_mem ha (inv_mem b hb)\n      convert this\n      rw [inv_inv]\n    one_mem }\n#align is_subgroup.of_div IsSubgroup.of_div\n#align is_add_subgroup.of_add_neg IsAddSubgroup.of_add_neg\n\ntheorem IsAddSubgroup.of_sub (s : Set A) (zero_mem : (0 : A) ∈ s)\n    (sub_mem : ∀ {a b : A}, a ∈ s → b ∈ s → a - b ∈ s) : IsAddSubgroup s :=\n  IsAddSubgroup.of_add_neg s zero_mem fun {x y} hx hy => by\n    simpa only [sub_eq_add_neg] using sub_mem hx hy\n#align is_add_subgroup.of_sub IsAddSubgroup.of_sub\n\n@[to_additive]\ntheorem IsSubgroup.inter {s₁ s₂ : Set G} (hs₁ : IsSubgroup s₁) (hs₂ : IsSubgroup s₂) :\n    IsSubgroup (s₁ ∩ s₂) :=\n  { IsSubmonoid.inter hs₁.toIsSubmonoid hs₂.toIsSubmonoid with\n    inv_mem := fun hx => ⟨hs₁.inv_mem hx.1, hs₂.inv_mem hx.2⟩ }\n#align is_subgroup.inter IsSubgroup.inter\n#align is_add_subgroup.inter IsAddSubgroup.inter\n\n@[to_additive]\ntheorem IsSubgroup.iInter {ι : Sort*} {s : ι → Set G} (hs : ∀ y : ι, IsSubgroup (s y)) :\n    IsSubgroup (Set.iInter s) :=\n  { IsSubmonoid.iInter fun y => (hs y).toIsSubmonoid with\n    inv_mem := fun h =>\n      Set.mem_iInter.2 fun y => IsSubgroup.inv_mem (hs _) (Set.mem_iInter.1 h y) }\n#align is_subgroup.Inter IsSubgroup.iInter\n#align is_add_subgroup.Inter IsAddSubgroup.iInter\n\n@[to_additive]\ntheorem isSubgroup_iUnion_of_directed {ι : Type*} [Nonempty ι] {s : ι → Set G}\n    (hs : ∀ i, IsSubgroup (s i)) (directed : ∀ i j, ∃ k, s i ⊆ s k ∧ s j ⊆ s k) :\n    IsSubgroup (⋃ i, s i) :=\n  { inv_mem := fun ha =>\n      let ⟨i, hi⟩ := Set.mem_iUnion.1 ha\n      Set.mem_iUnion.2 ⟨i, (hs i).inv_mem hi⟩\n    toIsSubmonoid := isSubmonoid_iUnion_of_directed (fun i => (hs i).toIsSubmonoid) directed }\n#align is_subgroup_Union_of_directed isSubgroup_iUnion_of_directed\n#align is_add_subgroup_Union_of_directed isAddSubgroup_iUnion_of_directed\n\nend Group\n\nnamespace IsSubgroup\n\nopen IsSubmonoid\n\nvariable [Group G] {s : Set G} (hs : IsSubgroup s)\n\n@[to_additive]\ntheorem inv_mem_iff : a⁻¹ ∈ s ↔ a ∈ s :=\n  ⟨fun h => by simpa using hs.inv_mem h, inv_mem hs⟩\n#align is_subgroup.inv_mem_iff IsSubgroup.inv_mem_iff\n#align is_add_subgroup.neg_mem_iff IsAddSubgroup.neg_mem_iff\n\n@[to_additive]\ntheorem mul_mem_cancel_right (h : a ∈ s) : b * a ∈ s ↔ b ∈ s :=\n  ⟨fun hba => by simpa using hs.mul_mem hba (hs.inv_mem h), fun hb => hs.mul_mem hb h⟩\n#align is_subgroup.mul_mem_cancel_right IsSubgroup.mul_mem_cancel_right\n#align is_add_subgroup.add_mem_cancel_right IsAddSubgroup.add_mem_cancel_right\n\n@[to_additive]\ntheorem mul_mem_cancel_left (h : a ∈ s) : a * b ∈ s ↔ b ∈ s :=\n  ⟨fun hab => by simpa using hs.mul_mem (hs.inv_mem h) hab, hs.mul_mem h⟩\n#align is_subgroup.mul_mem_cancel_left IsSubgroup.mul_mem_cancel_left\n#align is_add_subgroup.add_mem_cancel_left IsAddSubgroup.add_mem_cancel_left\n\nend IsSubgroup\n\n/-- `IsNormalAddSubgroup (s : Set A)` expresses the fact that `s` is a normal additive subgroup\nof the additive group `A`. Important: the preferred way to say this in Lean is via bundled\nsubgroups `S : AddSubgroup A` and `hs : S.normal`, and not via this structure. -/\nstructure IsNormalAddSubgroup [AddGroup A] (s : Set A) extends IsAddSubgroup s : Prop where\n  /-- The proposition that `s` is closed under (additive) conjugation. -/\n  normal : ∀ n ∈ s, ∀ g : A, g + n + -g ∈ s\n#align is_normal_add_subgroup IsNormalAddSubgroup\n\n/-- `IsNormalSubgroup (s : Set G)` expresses the fact that `s` is a normal subgroup\nof the group `G`. Important: the preferred way to say this in Lean is via bundled\nsubgroups `S : Subgroup G` and not via this structure. -/\n@[to_additive]\nstructure IsNormalSubgroup [Group G] (s : Set G) extends IsSubgroup s : Prop where\n  /-- The proposition that `s` is closed under conjugation. -/\n  normal : ∀ n ∈ s, ∀ g : G, g * n * g⁻¹ ∈ s\n#align is_normal_subgroup IsNormalSubgroup\n\n@[to_additive]\ntheorem isNormalSubgroup_of_commGroup [CommGroup G] {s : Set G} (hs : IsSubgroup s) :\n    IsNormalSubgroup s :=\n  { hs with normal := fun n hn g => by rwa [mul_right_comm, mul_right_inv, one_mul] }\n#align is_normal_subgroup_of_comm_group isNormalSubgroup_of_commGroup\n#align is_normal_add_subgroup_of_add_comm_group isNormalAddSubgroup_of_addCommGroup\n\ntheorem Additive.isNormalAddSubgroup [Group G] {s : Set G} (hs : IsNormalSubgroup s) :\n    @IsNormalAddSubgroup (Additive G) _ s :=\n  @IsNormalAddSubgroup.mk (Additive G) _ _ (Additive.isAddSubgroup hs.toIsSubgroup)\n    (@IsNormalSubgroup.normal _ ‹Group (Additive G)› _ hs)\n    -- porting note: Lean needs help synthesising\n#align additive.is_normal_add_subgroup Additive.isNormalAddSubgroup\n\ntheorem Additive.isNormalAddSubgroup_iff [Group G] {s : Set G} :\n    @IsNormalAddSubgroup (Additive G) _ s ↔ IsNormalSubgroup s :=\n  ⟨by rintro ⟨h₁, h₂⟩; exact @IsNormalSubgroup.mk G _ _ (Additive.isAddSubgroup_iff.1 h₁) @h₂,\n    fun h => Additive.isNormalAddSubgroup h⟩\n#align additive.is_normal_add_subgroup_iff Additive.isNormalAddSubgroup_iff\n\ntheorem Multiplicative.isNormalSubgroup [AddGroup A] {s : Set A} (hs : IsNormalAddSubgroup s) :\n    @IsNormalSubgroup (Multiplicative A) _ s :=\n  @IsNormalSubgroup.mk (Multiplicative A) _ _ (Multiplicative.isSubgroup hs.toIsAddSubgroup)\n    (@IsNormalAddSubgroup.normal _ ‹AddGroup (Multiplicative A)› _ hs)\n#align multiplicative.is_normal_subgroup Multiplicative.isNormalSubgroup\n\ntheorem Multiplicative.isNormalSubgroup_iff [AddGroup A] {s : Set A} :\n    @IsNormalSubgroup (Multiplicative A) _ s ↔ IsNormalAddSubgroup s :=\n  ⟨by\n    rintro ⟨h₁, h₂⟩;\n      exact @IsNormalAddSubgroup.mk A _ _ (Multiplicative.isSubgroup_iff.1 h₁) @h₂,\n    fun h => Multiplicative.isNormalSubgroup h⟩\n#align multiplicative.is_normal_subgroup_iff Multiplicative.isNormalSubgroup_iff\n\nnamespace IsSubgroup\n\nvariable [Group G]\n\n-- Normal subgroup properties\n@[to_additive]\ntheorem mem_norm_comm {s : Set G} (hs : IsNormalSubgroup s) {a b : G} (hab : a * b ∈ s) :\n    b * a ∈ s := by\n  have h : a⁻¹ * (a * b) * a⁻¹⁻¹ ∈ s := hs.normal (a * b) hab a⁻¹\n  simp at h; exact h\n#align is_subgroup.mem_norm_comm IsSubgroup.mem_norm_comm\n#align is_add_subgroup.mem_norm_comm IsAddSubgroup.mem_norm_comm\n\n@[to_additive]\ntheorem mem_norm_comm_iff {s : Set G} (hs : IsNormalSubgroup s) {a b : G} : a * b ∈ s ↔ b * a ∈ s :=\n  ⟨mem_norm_comm hs, mem_norm_comm hs⟩\n#align is_subgroup.mem_norm_comm_iff IsSubgroup.mem_norm_comm_iff\n#align is_add_subgroup.mem_norm_comm_iff IsAddSubgroup.mem_norm_comm_iff\n\n/-- The trivial subgroup -/\n@[to_additive \"the trivial additive subgroup\"]\ndef trivial (G : Type*) [Group G] : Set G :=\n  {1}\n#align is_subgroup.trivial IsSubgroup.trivial\n#align is_add_subgroup.trivial IsAddSubgroup.trivial\n\n@[to_additive (attr := simp)]\ntheorem mem_trivial {g : G} : g ∈ trivial G ↔ g = 1 :=\n  mem_singleton_iff\n#align is_subgroup.mem_trivial IsSubgroup.mem_trivial\n#align is_add_subgroup.mem_trivial IsAddSubgroup.mem_trivial\n\n@[to_additive]\ntheorem trivial_normal : IsNormalSubgroup (trivial G) := by\n  refine' { .. } <;> simp (config := { contextual := true }) [trivial]\n#align is_subgroup.trivial_normal IsSubgroup.trivial_normal\n#align is_add_subgroup.trivial_normal IsAddSubgroup.trivial_normal\n\n@[to_additive]\ntheorem eq_trivial_iff {s : Set G} (hs : IsSubgroup s) : s = trivial G ↔ ∀ x ∈ s, x = (1 : G) := by\n  simp only [Set.ext_iff, IsSubgroup.mem_trivial];\n    exact ⟨fun h x => (h x).1, fun h x => ⟨h x, fun hx => hx.symm ▸ hs.toIsSubmonoid.one_mem⟩⟩\n#align is_subgroup.eq_trivial_iff IsSubgroup.eq_trivial_iff\n#align is_add_subgroup.eq_trivial_iff IsAddSubgroup.eq_trivial_iff\n\n@[to_additive]\ntheorem univ_subgroup : IsNormalSubgroup (@univ G) := by refine' { .. } <;> simp\n#align is_subgroup.univ_subgroup IsSubgroup.univ_subgroup\n#align is_add_subgroup.univ_add_subgroup IsAddSubgroup.univ_addSubgroup\n\n/-- The underlying set of the center of a group. -/\n@[to_additive addCenter \"The underlying set of the center of an additive group.\"]\ndef center (G : Type*) [Group G] : Set G :=\n  { z | ∀ g, g * z = z * g }\n#align is_subgroup.center IsSubgroup.center\n#align is_add_subgroup.add_center IsAddSubgroup.addCenter\n\n@[to_additive mem_add_center]\ntheorem mem_center {a : G} : a ∈ center G ↔ ∀ g, g * a = a * g :=\n  Iff.rfl\n#align is_subgroup.mem_center IsSubgroup.mem_center\n#align is_add_subgroup.mem_add_center IsAddSubgroup.mem_add_center\n\n@[to_additive add_center_normal]\ntheorem center_normal : IsNormalSubgroup (center G) :=\n  { one_mem := by simp [center]\n    mul_mem := fun ha hb g => by\n      rw [← mul_assoc, mem_center.2 ha g, mul_assoc, mem_center.2 hb g, ← mul_assoc]\n    inv_mem := fun {a} ha g =>\n      calc\n        g * a⁻¹ = a⁻¹ * (g * a) * a⁻¹ := by simp [ha g]\n        _ = a⁻¹ * g := by rw [← mul_assoc, mul_assoc]; simp\n    normal := fun n ha g h =>\n      calc\n        h * (g * n * g⁻¹) = h * n := by simp [ha g, mul_assoc]\n        _ = g * g⁻¹ * n * h := by rw [ha h]; simp\n        _ = g * n * g⁻¹ * h := by rw [mul_assoc g, ha g⁻¹, ← mul_assoc]\n         }\n#align is_subgroup.center_normal IsSubgroup.center_normal\n#align is_add_subgroup.add_center_normal IsAddSubgroup.add_center_normal\n\n/-- The underlying set of the normalizer of a subset `S : Set G` of a group `G`. That is,\n  the elements `g : G` such that `g * S * g⁻¹ = S`. -/\n@[to_additive addNormalizer\n      \"The underlying set of the normalizer of a subset `S : Set A` of an\n      additive group `A`. That is, the elements `a : A` such that `a + S - a = S`.\"]\ndef normalizer (s : Set G) : Set G :=\n  { g : G | ∀ n, n ∈ s ↔ g * n * g⁻¹ ∈ s }\n#align is_subgroup.normalizer IsSubgroup.normalizer\n#align is_add_subgroup.add_normalizer IsAddSubgroup.addNormalizer\n\n@[to_additive]\ntheorem normalizer_isSubgroup (s : Set G) : IsSubgroup (normalizer s) :=\n  { one_mem := by simp [normalizer]\n    mul_mem := fun {a b}\n      (ha : ∀ n, n ∈ s ↔ a * n * a⁻¹ ∈ s) (hb : ∀ n, n ∈ s ↔ b * n * b⁻¹ ∈ s) n =>\n      by rw [mul_inv_rev, ← mul_assoc, mul_assoc a, mul_assoc a, ← ha, ← hb]\n    inv_mem := fun {a} (ha : ∀ n, n ∈ s ↔ a * n * a⁻¹ ∈ s) n => by\n      rw [ha (a⁻¹ * n * a⁻¹⁻¹)]; simp [mul_assoc] }\n#align is_subgroup.normalizer_is_subgroup IsSubgroup.normalizer_isSubgroup\n#align is_add_subgroup.normalizer_is_add_subgroup IsAddSubgroup.normalizer_isAddSubgroup\n\n@[to_additive subset_add_normalizer]\ntheorem subset_normalizer {s : Set G} (hs : IsSubgroup s) : s ⊆ normalizer s := fun g hg n => by\n  rw [IsSubgroup.mul_mem_cancel_right hs ((IsSubgroup.inv_mem_iff hs).2 hg),\n    IsSubgroup.mul_mem_cancel_left hs hg]\n#align is_subgroup.subset_normalizer IsSubgroup.subset_normalizer\n#align is_add_subgroup.subset_add_normalizer IsAddSubgroup.subset_add_normalizer\n\nend IsSubgroup\n\n-- Homomorphism subgroups\nnamespace IsGroupHom\n\nopen IsSubmonoid IsSubgroup\n\n/-- `ker f : Set G` is the underlying subset of the kernel of a map `G → H`. -/\n@[to_additive \"`ker f : Set A` is the underlying subset of the kernel of a map `A → B`\"]\ndef ker [Group H] (f : G → H) : Set G :=\n  preimage f (trivial H)\n#align is_group_hom.ker IsGroupHom.ker\n#align is_add_group_hom.ker IsAddGroupHom.ker\n\n@[to_additive]\ntheorem mem_ker [Group H] (f : G → H) {x : G} : x ∈ ker f ↔ f x = 1 :=\n  mem_trivial\n#align is_group_hom.mem_ker IsGroupHom.mem_ker\n#align is_add_group_hom.mem_ker IsAddGroupHom.mem_ker\n\nvariable [Group G] [Group H]\n\n@[to_additive]\ntheorem one_ker_inv {f : G → H} (hf : IsGroupHom f) {a b : G} (h : f (a * b⁻¹) = 1) :\n    f a = f b := by\n  rw [hf.map_mul, hf.map_inv] at h\n  rw [← inv_inv (f b), eq_inv_of_mul_eq_one_left h]\n#align is_group_hom.one_ker_inv IsGroupHom.one_ker_inv\n#align is_add_group_hom.zero_ker_neg IsAddGroupHom.zero_ker_neg\n\n@[to_additive]\ntheorem one_ker_inv' {f : G → H} (hf : IsGroupHom f) {a b : G} (h : f (a⁻¹ * b) = 1) :\n    f a = f b := by\n  rw [hf.map_mul, hf.map_inv] at h\n  apply inv_injective\n  rw [eq_inv_of_mul_eq_one_left h]\n#align is_group_hom.one_ker_inv' IsGroupHom.one_ker_inv'\n#align is_add_group_hom.zero_ker_neg' IsAddGroupHom.zero_ker_neg'\n\n@[to_additive]\ntheorem inv_ker_one {f : G → H} (hf : IsGroupHom f) {a b : G} (h : f a = f b) :\n    f (a * b⁻¹) = 1 := by\n  have : f a * (f b)⁻¹ = 1 := by rw [h, mul_right_inv]\n  rwa [← hf.map_inv, ← hf.map_mul] at this\n#align is_group_hom.inv_ker_one IsGroupHom.inv_ker_one\n#align is_add_group_hom.neg_ker_zero IsAddGroupHom.neg_ker_zero\n\n@[to_additive]\ntheorem inv_ker_one' {f : G → H} (hf : IsGroupHom f) {a b : G} (h : f a = f b) :\n    f (a⁻¹ * b) = 1 := by\n  have : (f a)⁻¹ * f b = 1 := by rw [h, mul_left_inv]\n  rwa [← hf.map_inv, ← hf.map_mul] at this\n#align is_group_hom.inv_ker_one' IsGroupHom.inv_ker_one'\n#align is_add_group_hom.neg_ker_zero' IsAddGroupHom.neg_ker_zero'\n\n@[to_additive]\ntheorem one_iff_ker_inv {f : G → H} (hf : IsGroupHom f) (a b : G) : f a = f b ↔ f (a * b⁻¹) = 1 :=\n  ⟨hf.inv_ker_one, hf.one_ker_inv⟩\n#align is_group_hom.one_iff_ker_inv IsGroupHom.one_iff_ker_inv\n#align is_add_group_hom.zero_iff_ker_neg IsAddGroupHom.zero_iff_ker_neg\n\n@[to_additive]\ntheorem one_iff_ker_inv' {f : G → H} (hf : IsGroupHom f) (a b : G) : f a = f b ↔ f (a⁻¹ * b) = 1 :=\n  ⟨hf.inv_ker_one', hf.one_ker_inv'⟩\n#align is_group_hom.one_iff_ker_inv' IsGroupHom.one_iff_ker_inv'\n#align is_add_group_hom.zero_iff_ker_neg' IsAddGroupHom.zero_iff_ker_neg'\n\n@[to_additive]\ntheorem inv_iff_ker {f : G → H} (hf : IsGroupHom f) (a b : G) : f a = f b ↔ a * b⁻¹ ∈ ker f := by\n  rw [mem_ker]; exact one_iff_ker_inv hf _ _\n#align is_group_hom.inv_iff_ker IsGroupHom.inv_iff_ker\n#align is_add_group_hom.neg_iff_ker IsAddGroupHom.neg_iff_ker\n\n@[to_additive]\ntheorem inv_iff_ker' {f : G → H} (hf : IsGroupHom f) (a b : G) : f a = f b ↔ a⁻¹ * b ∈ ker f := by\n  rw [mem_ker]; exact one_iff_ker_inv' hf _ _\n#align is_group_hom.inv_iff_ker' IsGroupHom.inv_iff_ker'\n#align is_add_group_hom.neg_iff_ker' IsAddGroupHom.neg_iff_ker'\n\n@[to_additive]\ntheorem image_subgroup {f : G → H} (hf : IsGroupHom f) {s : Set G} (hs : IsSubgroup s) :\n    IsSubgroup (f '' s) :=\n  { mul_mem := fun {a₁ a₂} ⟨b₁, hb₁, eq₁⟩ ⟨b₂, hb₂, eq₂⟩ =>\n      ⟨b₁ * b₂, hs.mul_mem hb₁ hb₂, by simp [eq₁, eq₂, hf.map_mul]⟩\n    one_mem := ⟨1, hs.toIsSubmonoid.one_mem, hf.map_one⟩\n    inv_mem := fun {a} ⟨b, hb, Eq⟩ =>\n      ⟨b⁻¹, hs.inv_mem hb, by\n        rw [hf.map_inv]\n        simp [*]⟩ }\n#align is_group_hom.image_subgroup IsGroupHom.image_subgroup\n#align is_add_group_hom.image_add_subgroup IsAddGroupHom.image_addSubgroup\n\n@[to_additive]\ntheorem range_subgroup {f : G → H} (hf : IsGroupHom f) : IsSubgroup (Set.range f) :=\n  @Set.image_univ _ _ f ▸ hf.image_subgroup univ_subgroup.toIsSubgroup\n#align is_group_hom.range_subgroup IsGroupHom.range_subgroup\n#align is_add_group_hom.range_add_subgroup IsAddGroupHom.range_addSubgroup\n\nattribute [local simp] IsSubmonoid.one_mem IsSubgroup.inv_mem\n  IsSubmonoid.mul_mem IsNormalSubgroup.normal\n\n@[to_additive]\ntheorem preimage {f : G → H} (hf : IsGroupHom f) {s : Set H} (hs : IsSubgroup s) :\n    IsSubgroup (f ⁻¹' s) := by\n  refine' { .. } <;>\n    simp (config := { contextual := true }) [hs.one_mem, hs.mul_mem, hs.inv_mem, hf.map_mul,\n      hf.map_one, hf.map_inv, InvMemClass.inv_mem]\n#align is_group_hom.preimage IsGroupHom.preimage\n#align is_add_group_hom.preimage IsAddGroupHom.preimage\n\n@[to_additive]\ntheorem preimage_normal {f : G → H} (hf : IsGroupHom f) {s : Set H} (hs : IsNormalSubgroup s) :\n    IsNormalSubgroup (f ⁻¹' s) :=\n  { one_mem := by simp [hf.map_one, hs.toIsSubgroup.one_mem]\n    mul_mem := by simp (config := { contextual := true }) [hf.map_mul, hs.toIsSubgroup.mul_mem]\n    inv_mem := by simp (config := { contextual := true }) [hf.map_inv, hs.toIsSubgroup.inv_mem]\n    normal := by simp (config := { contextual := true }) [hs.normal, hf.map_mul, hf.map_inv] }\n#align is_group_hom.preimage_normal IsGroupHom.preimage_normal\n#align is_add_group_hom.preimage_normal IsAddGroupHom.preimage_normal\n\n@[to_additive]\ntheorem isNormalSubgroup_ker {f : G → H} (hf : IsGroupHom f) : IsNormalSubgroup (ker f) :=\n  hf.preimage_normal trivial_normal\n#align is_group_hom.is_normal_subgroup_ker IsGroupHom.isNormalSubgroup_ker\n#align is_add_group_hom.is_normal_add_subgroup_ker IsAddGroupHom.isNormalAddSubgroup_ker\n\n@[to_additive]\ntheorem injective_of_trivial_ker {f : G → H} (hf : IsGroupHom f) (h : ker f = trivial G) :\n    Function.Injective f := by\n  intro a₁ a₂ hfa\n  simp [ext_iff, ker, IsSubgroup.trivial] at h\n  have ha : a₁ * a₂⁻¹ = 1 := by rw [← h]; exact hf.inv_ker_one hfa\n  rw [eq_inv_of_mul_eq_one_left ha, inv_inv a₂]\n#align is_group_hom.injective_of_trivial_ker IsGroupHom.injective_of_trivial_ker\n#align is_add_group_hom.injective_of_trivial_ker IsAddGroupHom.injective_of_trivial_ker\n\n@[to_additive]\ntheorem trivial_ker_of_injective {f : G → H} (hf : IsGroupHom f) (h : Function.Injective f) :\n    ker f = trivial G :=\n  Set.ext fun x =>\n    Iff.intro\n      (fun hx => by\n        suffices f x = f 1 by simpa using h this\n        simp [hf.map_one]; rwa [mem_ker] at hx)\n      (by simp (config := { contextual := true }) [mem_ker, hf.map_one])\n#align is_group_hom.trivial_ker_of_injective IsGroupHom.trivial_ker_of_injective\n#align is_add_group_hom.trivial_ker_of_injective IsAddGroupHom.trivial_ker_of_injective\n\n@[to_additive]\ntheorem injective_iff_trivial_ker {f : G → H} (hf : IsGroupHom f) :\n    Function.Injective f ↔ ker f = trivial G :=\n  ⟨hf.trivial_ker_of_injective, hf.injective_of_trivial_ker⟩\n#align is_group_hom.injective_iff_trivial_ker IsGroupHom.injective_iff_trivial_ker\n#align is_add_group_hom.injective_iff_trivial_ker IsAddGroupHom.injective_iff_trivial_ker\n\n@[to_additive]\ntheorem trivial_ker_iff_eq_one {f : G → H} (hf : IsGroupHom f) :\n    ker f = trivial G ↔ ∀ x, f x = 1 → x = 1 := by\n  rw [Set.ext_iff]; simp [ker];\n    exact ⟨fun h x hx => (h x).1 hx, fun h x => ⟨h x, fun hx => by rw [hx, hf.map_one]⟩⟩\n#align is_group_hom.trivial_ker_iff_eq_one IsGroupHom.trivial_ker_iff_eq_one\n#align is_add_group_hom.trivial_ker_iff_eq_zero IsAddGroupHom.trivial_ker_iff_eq_zero\n\nend IsGroupHom\n\nnamespace AddGroup\n\nvariable [AddGroup A]\n\n/-- If `A` is an additive group and `s : Set A`, then `InClosure s : Set A` is the underlying\nsubset of the subgroup generated by `s`. -/\ninductive InClosure (s : Set A) : A → Prop\n  | basic {a : A} : a ∈ s → InClosure s a\n  | zero : InClosure s 0\n  | neg {a : A} : InClosure s a → InClosure s (-a)\n  | add {a b : A} : InClosure s a → InClosure s b → InClosure s (a + b)\n#align add_group.in_closure AddGroup.InClosure\n\nend AddGroup\n\nnamespace Group\n\nopen IsSubmonoid IsSubgroup\n\nvariable [Group G] {s : Set G}\n\n/-- If `G` is a group and `s : Set G`, then `InClosure s : Set G` is the underlying\nsubset of the subgroup generated by `s`. -/\n@[to_additive]\ninductive InClosure (s : Set G) : G → Prop\n  | basic {a : G} : a ∈ s → InClosure s a\n  | one : InClosure s 1\n  | inv {a : G} : InClosure s a → InClosure s a⁻¹\n  | mul {a b : G} : InClosure s a → InClosure s b → InClosure s (a * b)\n#align group.in_closure Group.InClosure\n\n/-- `Group.closure s` is the subgroup generated by `s`, i.e. the smallest subgroup containing `s`.\n-/\n@[to_additive\n  \"`AddGroup.closure s` is the additive subgroup generated by `s`, i.e., the\n  smallest additive subgroup containing `s`.\"]\ndef closure (s : Set G) : Set G :=\n  { a | InClosure s a }\n#align group.closure Group.closure\n#align add_group.closure AddGroup.closure\n\n@[to_additive]\ntheorem mem_closure {a : G} : a ∈ s → a ∈ closure s :=\n  InClosure.basic\n#align group.mem_closure Group.mem_closure\n#align add_group.mem_closure AddGroup.mem_closure\n\n@[to_additive]\ntheorem closure.isSubgroup (s : Set G) : IsSubgroup (closure s) :=\n  { one_mem := InClosure.one\n    mul_mem := InClosure.mul\n    inv_mem := InClosure.inv }\n#align group.closure.is_subgroup Group.closure.isSubgroup\n#align add_group.closure.is_add_subgroup AddGroup.closure.isAddSubgroup\n\n@[to_additive]\ntheorem subset_closure {s : Set G} : s ⊆ closure s := fun _ => mem_closure\n#align group.subset_closure Group.subset_closure\n#align add_group.subset_closure AddGroup.subset_closure\n\n@[to_additive]\ntheorem closure_subset {s t : Set G} (ht : IsSubgroup t) (h : s ⊆ t) : closure s ⊆ t := fun a ha =>\n  by induction ha <;> simp [h _, *, ht.one_mem, ht.mul_mem, IsSubgroup.inv_mem_iff]\n#align group.closure_subset Group.closure_subset\n#align add_group.closure_subset AddGroup.closure_subset\n\n@[to_additive]\ntheorem closure_subset_iff {s t : Set G} (ht : IsSubgroup t) : closure s ⊆ t ↔ s ⊆ t :=\n  ⟨fun h _ ha => h (mem_closure ha), fun h _ ha => closure_subset ht h ha⟩\n#align group.closure_subset_iff Group.closure_subset_iff\n#align add_group.closure_subset_iff AddGroup.closure_subset_iff\n\n@[to_additive]\ntheorem closure_mono {s t : Set G} (h : s ⊆ t) : closure s ⊆ closure t :=\n  closure_subset (closure.isSubgroup _) <| Set.Subset.trans h subset_closure\n#align group.closure_mono Group.closure_mono\n#align add_group.closure_mono AddGroup.closure_mono\n\n@[to_additive (attr := simp)]\ntheorem closure_subgroup {s : Set G} (hs : IsSubgroup s) : closure s = s :=\n  Set.Subset.antisymm (closure_subset hs <| Set.Subset.refl s) subset_closure\n#align group.closure_subgroup Group.closure_subgroup\n#align add_group.closure_add_subgroup AddGroup.closure_addSubgroup\n\n@[to_additive]\ntheorem exists_list_of_mem_closure {s : Set G} {a : G} (h : a ∈ closure s) :\n    ∃ l : List G, (∀ x ∈ l, x ∈ s ∨ x⁻¹ ∈ s) ∧ l.prod = a :=\n  InClosure.recOn h (fun {x} hxs => ⟨[x], List.forall_mem_singleton.2 <| Or.inl hxs, one_mul _⟩)\n    ⟨[], List.forall_mem_nil _, rfl⟩\n    (fun {x} _ ⟨L, HL1, HL2⟩ =>\n      ⟨L.reverse.map Inv.inv, fun x hx =>\n        let ⟨y, hy1, hy2⟩ := List.exists_of_mem_map hx\n        hy2 ▸ Or.imp id (by rw [inv_inv]; exact id) (HL1 _ <| List.mem_reverse.1 hy1).symm,\n        HL2 ▸\n          List.recOn L inv_one.symm fun hd tl ih => by\n            rw [List.reverse_cons, List.map_append, List.prod_append, ih, List.map_singleton,\n              List.prod_cons, List.prod_nil, mul_one, List.prod_cons, mul_inv_rev]⟩)\n    fun {x y} _ _ ⟨L1, HL1, HL2⟩ ⟨L2, HL3, HL4⟩ =>\n    ⟨L1 ++ L2, List.forall_mem_append.2 ⟨HL1, HL3⟩, by rw [List.prod_append, HL2, HL4]⟩\n#align group.exists_list_of_mem_closure Group.exists_list_of_mem_closure\n#align add_group.exists_list_of_mem_closure AddGroup.exists_list_of_mem_closure\n\n@[to_additive]\ntheorem image_closure [Group H] {f : G → H} (hf : IsGroupHom f) (s : Set G) :\n    f '' closure s = closure (f '' s) :=\n  le_antisymm\n    (by\n      rintro _ ⟨x, hx, rfl⟩\n      exact InClosure.recOn hx\n        (by intros _ ha; exact subset_closure (mem_image_of_mem f ha))\n        (by\n          rw [hf.map_one]\n          apply IsSubmonoid.one_mem (closure.isSubgroup _).toIsSubmonoid)\n        (by\n          intros _ _\n          rw [hf.map_inv]\n          apply IsSubgroup.inv_mem (closure.isSubgroup _))\n        (by\n          intros _ _ _ _ ha hb\n          rw [hf.map_mul]\n          exact (closure.isSubgroup (f '' s)).toIsSubmonoid.mul_mem ha hb))\n    (closure_subset (hf.image_subgroup <| closure.isSubgroup _) <|\n      Set.image_subset _ subset_closure)\n#align group.image_closure Group.image_closure\n#align add_group.image_closure AddGroup.image_closure\n\n@[to_additive]\ntheorem mclosure_subset {s : Set G} : Monoid.Closure s ⊆ closure s :=\n  Monoid.closure_subset (closure.isSubgroup _).toIsSubmonoid <| subset_closure\n#align group.mclosure_subset Group.mclosure_subset\n#align add_group.mclosure_subset AddGroup.mclosure_subset\n\n@[to_additive]\ntheorem mclosure_inv_subset {s : Set G} : Monoid.Closure (Inv.inv ⁻¹' s) ⊆ closure s :=\n  Monoid.closure_subset (closure.isSubgroup _).toIsSubmonoid fun x hx =>\n    inv_inv x ▸ ((closure.isSubgroup _).inv_mem <| subset_closure hx)\n#align group.mclosure_inv_subset Group.mclosure_inv_subset\n#align add_group.mclosure_neg_subset AddGroup.mclosure_neg_subset\n\n@[to_additive]\ntheorem closure_eq_mclosure {s : Set G} : closure s = Monoid.Closure (s ∪ Inv.inv ⁻¹' s) :=\n  Set.Subset.antisymm\n    (@closure_subset _ _ _ (Monoid.Closure (s ∪ Inv.inv ⁻¹' s))\n      { one_mem := (Monoid.closure.isSubmonoid _).one_mem\n        mul_mem := (Monoid.closure.isSubmonoid _).mul_mem\n        inv_mem := fun hx =>\n          Monoid.InClosure.recOn hx\n            (fun {x} hx =>\n              Or.casesOn hx\n                (fun hx =>\n                  Monoid.subset_closure <| Or.inr <| show x⁻¹⁻¹ ∈ s from (inv_inv x).symm ▸ hx)\n                fun hx => Monoid.subset_closure <| Or.inl hx)\n            ((@inv_one G _).symm ▸ IsSubmonoid.one_mem (Monoid.closure.isSubmonoid _))\n            fun {x y} _ _ ihx ihy =>\n            (mul_inv_rev x y).symm ▸ IsSubmonoid.mul_mem (Monoid.closure.isSubmonoid _) ihy ihx }\n      (Set.Subset.trans (Set.subset_union_left _ _) Monoid.subset_closure))\n    (Monoid.closure_subset (closure.isSubgroup _).toIsSubmonoid <|\n      Set.union_subset subset_closure fun x hx =>\n        inv_inv x ▸ (IsSubgroup.inv_mem (closure.isSubgroup _) <| subset_closure hx))\n#align group.closure_eq_mclosure Group.closure_eq_mclosure\n#align add_group.closure_eq_mclosure AddGroup.closure_eq_mclosure\n\n@[to_additive]\ntheorem mem_closure_union_iff {G : Type*} [CommGroup G] {s t : Set G} {x : G} :\n    x ∈ closure (s ∪ t) ↔ ∃ y ∈ closure s, ∃ z ∈ closure t, y * z = x := by\n  simp only [closure_eq_mclosure, Monoid.mem_closure_union_iff, exists_prop, preimage_union];\n  constructor\n  · rintro ⟨_, ⟨ys, hys, yt, hyt, rfl⟩, _, ⟨zs, hzs, zt, hzt, rfl⟩, rfl⟩\n    refine' ⟨_, ⟨_, hys, _, hzs, rfl⟩, _, ⟨_, hyt, _, hzt, rfl⟩, _⟩\n    rw [mul_assoc, mul_assoc, mul_left_comm zs]\n  · rintro ⟨_, ⟨ys, hys, zs, hzs, rfl⟩, _, ⟨yt, hyt, zt, hzt, rfl⟩, rfl⟩\n    refine' ⟨_, ⟨ys, hys, yt, hyt, rfl⟩, _, ⟨zs, hzs, zt, hzt, rfl⟩, _⟩\n    rw [mul_assoc, mul_assoc, mul_left_comm yt]\n#align group.mem_closure_union_iff Group.mem_closure_union_iff\n#align add_group.mem_closure_union_iff AddGroup.mem_closure_union_iff\n\nend Group\n\nnamespace IsSubgroup\n\nvariable [Group G]\n\n@[to_additive]\ntheorem trivial_eq_closure : trivial G = Group.closure ∅ :=\n  Subset.antisymm (by simp [Set.subset_def, (Group.closure.isSubgroup _).one_mem])\n    (Group.closure_subset trivial_normal.toIsSubgroup <| by simp)\n#align is_subgroup.trivial_eq_closure IsSubgroup.trivial_eq_closure\n#align is_add_subgroup.trivial_eq_closure IsAddSubgroup.trivial_eq_closure\n\nend IsSubgroup\n\n/-The normal closure of a set s is the subgroup closure of all the conjugates of\nelements of s. It is the smallest normal subgroup containing s. -/\nnamespace Group\n\nvariable {s : Set G} [Group G]\n\ntheorem conjugatesOf_subset {t : Set G} (ht : IsNormalSubgroup t) {a : G} (h : a ∈ t) :\n    conjugatesOf a ⊆ t := fun x hc => by\n  obtain ⟨c, w⟩ := isConj_iff.1 hc\n  have H := IsNormalSubgroup.normal ht a h c\n  rwa [← w]\n#align group.conjugates_of_subset Group.conjugatesOf_subset\n\ntheorem conjugatesOfSet_subset' {s t : Set G} (ht : IsNormalSubgroup t) (h : s ⊆ t) :\n    conjugatesOfSet s ⊆ t :=\n  Set.iUnion₂_subset fun _ H => conjugatesOf_subset ht (h H)\n#align group.conjugates_of_set_subset' Group.conjugatesOfSet_subset'\n\n/-- The normal closure of a set s is the subgroup closure of all the conjugates of\nelements of s. It is the smallest normal subgroup containing s. -/\ndef normalClosure (s : Set G) : Set G :=\n  closure (conjugatesOfSet s)\n#align group.normal_closure Group.normalClosure\n\ntheorem conjugatesOfSet_subset_normalClosure : conjugatesOfSet s ⊆ normalClosure s :=\n  subset_closure\n#align group.conjugates_of_set_subset_normal_closure Group.conjugatesOfSet_subset_normalClosure\n\ntheorem subset_normalClosure : s ⊆ normalClosure s :=\n  Set.Subset.trans subset_conjugatesOfSet conjugatesOfSet_subset_normalClosure\n#align group.subset_normal_closure Group.subset_normalClosure\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem normalClosure.isSubgroup (s : Set G) : IsSubgroup (normalClosure s) :=\n  closure.isSubgroup (conjugatesOfSet s)\n#align group.normal_closure.is_subgroup Group.normalClosure.isSubgroup\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem normalClosure.is_normal : IsNormalSubgroup (normalClosure s) :=\n  { normalClosure.isSubgroup _ with\n    normal := fun n h g => by\n      induction' h with x hx x hx ihx x y hx hy ihx ihy\n      · exact conjugatesOfSet_subset_normalClosure (conj_mem_conjugatesOfSet hx)\n      · simpa using (normalClosure.isSubgroup s).one_mem\n      · rw [← conj_inv]\n        exact (normalClosure.isSubgroup _).inv_mem ihx\n      · rw [← conj_mul]\n        exact (normalClosure.isSubgroup _).toIsSubmonoid.mul_mem ihx ihy }\n#align group.normal_closure.is_normal Group.normalClosure.is_normal\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem normalClosure_subset {s t : Set G} (ht : IsNormalSubgroup t) (h : s ⊆ t) :\n    normalClosure s ⊆ t := fun a w => by\n  induction' w with x hx x _ ihx x y _ _ ihx ihy\n  · exact conjugatesOfSet_subset' ht h <| hx\n  · exact ht.toIsSubgroup.toIsSubmonoid.one_mem\n  · exact ht.toIsSubgroup.inv_mem ihx\n  · exact ht.toIsSubgroup.toIsSubmonoid.mul_mem ihx ihy\n#align group.normal_closure_subset Group.normalClosure_subset\n\ntheorem normalClosure_subset_iff {s t : Set G} (ht : IsNormalSubgroup t) :\n    s ⊆ t ↔ normalClosure s ⊆ t :=\n  ⟨normalClosure_subset ht, Set.Subset.trans subset_normalClosure⟩\n#align group.normal_closure_subset_iff Group.normalClosure_subset_iff\n\ntheorem normalClosure_mono {s t : Set G} : s ⊆ t → normalClosure s ⊆ normalClosure t := fun h =>\n  normalClosure_subset normalClosure.is_normal (Set.Subset.trans h subset_normalClosure)\n#align group.normal_closure_mono Group.normalClosure_mono\n\nend Group\n\n/-- Create a bundled subgroup from a set `s` and `[IsSubgroup s]`. -/\n@[to_additive \"Create a bundled additive subgroup from a set `s` and `[IsAddSubgroup s]`.\"]\ndef Subgroup.of [Group G] {s : Set G} (h : IsSubgroup s) : Subgroup G\n    where\n  carrier := s\n  one_mem' := h.1.1\n  mul_mem' := h.1.2\n  inv_mem' := h.2\n#align subgroup.of Subgroup.of\n#align add_subgroup.of AddSubgroup.of\n\n@[to_additive]\ntheorem Subgroup.isSubgroup [Group G] (K : Subgroup G) : IsSubgroup (K : Set G) :=\n  { one_mem := K.one_mem'\n    mul_mem := K.mul_mem'\n    inv_mem := K.inv_mem' }\n#align subgroup.is_subgroup Subgroup.isSubgroup\n#align add_subgroup.is_add_subgroup AddSubgroup.isAddSubgroup\n\n-- this will never fire if it's an instance\n@[to_additive]\ntheorem Subgroup.of_normal [Group G] (s : Set G) (h : IsSubgroup s) (n : IsNormalSubgroup s) :\n    Subgroup.Normal (Subgroup.of h) :=\n  { conj_mem := n.normal }\n#align subgroup.of_normal Subgroup.of_normal\n#align add_subgroup.of_normal AddSubgroup.of_normal\n\"}"
"\n"
"{\"text\": \"/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-/\nimport Mathlib.Algebra.Star.Pi\nimport Mathlib.Algebra.Star.Prod\nimport Mathlib.Topology.Algebra.Constructions\nimport Mathlib.Topology.ContinuousFunction.Basic\n\n#align_import topology.algebra.star from \"leanprover-community/mathlib\"@\"4c19a16e4b705bf135cf9a80ac18fcc99c438514\"\n\n/-!\n# Continuity of `star`\n\nThis file defines the `ContinuousStar` typeclass, along with instances on `Pi`, `Prod`,\n`MulOpposite`, and `Units`.\n-/\n\nset_option autoImplicit true\n\nopen Filter Topology\n\n/-- Basic hypothesis to talk about a topological space with a continuous `star` operator. -/\nclass ContinuousStar (R : Type*) [TopologicalSpace R] [Star R] : Prop where\n  /-- The `star` operator is continuous. -/\n  continuous_star : Continuous (star : R → R)\n#align has_continuous_star ContinuousStar\n\nexport ContinuousStar (continuous_star)\n\nsection Continuity\n\nvariable [TopologicalSpace R] [Star R] [ContinuousStar R]\n\ntheorem continuousOn_star {s : Set R} : ContinuousOn star s :=\n  continuous_star.continuousOn\n#align continuous_on_star continuousOn_star\n\ntheorem continuousWithinAt_star {s : Set R} {x : R} : ContinuousWithinAt star s x :=\n  continuous_star.continuousWithinAt\n#align continuous_within_at_star continuousWithinAt_star\n\ntheorem continuousAt_star {x : R} : ContinuousAt star x :=\n  continuous_star.continuousAt\n#align continuous_at_star continuousAt_star\n\ntheorem tendsto_star (a : R) : Tendsto star (𝓝 a) (𝓝 (star a)) :=\n  continuousAt_star\n#align tendsto_star tendsto_star\n\ntheorem Filter.Tendsto.star {f : α → R} {l : Filter α} {y : R} (h : Tendsto f l (𝓝 y)) :\n    Tendsto (fun x => star (f x)) l (𝓝 (star y)) :=\n  (continuous_star.tendsto y).comp h\n#align filter.tendsto.star Filter.Tendsto.star\n\nvariable [TopologicalSpace α] {f : α → R} {s : Set α} {x : α}\n\n@[continuity]\ntheorem Continuous.star (hf : Continuous f) : Continuous fun x => star (f x) :=\n  continuous_star.comp hf\n#align continuous.star Continuous.star\n\ntheorem ContinuousAt.star (hf : ContinuousAt f x) : ContinuousAt (fun x => star (f x)) x :=\n  continuousAt_star.comp hf\n#align continuous_at.star ContinuousAt.star\n\ntheorem ContinuousOn.star (hf : ContinuousOn f s) : ContinuousOn (fun x => star (f x)) s :=\n  continuous_star.comp_continuousOn hf\n#align continuous_on.star ContinuousOn.star\n\ntheorem ContinuousWithinAt.star (hf : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (fun x => star (f x)) s x :=\n  Filter.Tendsto.star hf\n#align continuous_within_at.star ContinuousWithinAt.star\n\n/-- The star operation bundled as a continuous map. -/\n@[simps]\ndef starContinuousMap : C(R, R) :=\n  ⟨star, continuous_star⟩\n#align star_continuous_map starContinuousMap\n\nend Continuity\n\nsection Instances\n\ninstance [Star R] [Star S] [TopologicalSpace R] [TopologicalSpace S] [ContinuousStar R]\n    [ContinuousStar S] : ContinuousStar (R × S) :=\n  ⟨(continuous_star.comp continuous_fst).prod_mk (continuous_star.comp continuous_snd)⟩\n\ninstance {C : ι → Type*} [∀ i, TopologicalSpace (C i)] [∀ i, Star (C i)]\n    [∀ i, ContinuousStar (C i)] : ContinuousStar (∀ i, C i) where\n  continuous_star := continuous_pi fun i => Continuous.star (continuous_apply i)\n\ninstance [Star R] [TopologicalSpace R] [ContinuousStar R] : ContinuousStar Rᵐᵒᵖ :=\n  ⟨MulOpposite.continuous_op.comp <| MulOpposite.continuous_unop.star⟩\n\ninstance [Monoid R] [StarMul R] [TopologicalSpace R] [ContinuousStar R] :\n    ContinuousStar Rˣ :=\n  ⟨continuous_induced_rng.2 Units.continuous_embedProduct.star⟩\n\nend Instances\n\"}"
"\n"
