{"input":{"0":"\/","1":"\/-","2":"\/-\n","3":"\/-\nCopy","4":"\/-\nCopyright","5":"\/-\nCopyright (","6":"\/-\nCopyright (c","7":"\/-\nCopyright (c)","8":"\/-\nCopyright (c) ","9":"\/-\nCopyright (c) 2","10":"\/-\nCopyright (c) 20","11":"\/-\nCopyright (c) 202","12":"\/-\nCopyright (c) 2022","13":"\/-\nCopyright (c) 2022 Eric","14":"\/-\nCopyright (c) 2022 Eric Wies","15":"\/-\nCopyright (c) 2022 Eric Wieser","16":"\/-\nCopyright (c) 2022 Eric Wieser.","17":"\/-\nCopyright (c) 2022 Eric Wieser. All","18":"\/-\nCopyright (c) 2022 Eric Wieser. All rights","19":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved","20":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.","21":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\n","22":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nRe","23":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased","24":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under","25":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache","26":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache ","27":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2","28":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.","29":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0","30":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license","31":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as","32":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described","33":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in","34":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the","35":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file","36":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file L","37":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LIC","38":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICEN","39":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE","40":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.","41":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\n","42":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuth","43":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors","44":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors:","45":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric","46":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wies","47":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser","48":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n","49":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-","50":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/","51":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\n","52":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport","53":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Math","54":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib","55":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.","56":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.Group","57":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupThe","58":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory","59":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.","60":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.Qu","61":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.Quot","62":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.Quotient","63":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup","64":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n","65":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n","66":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#","67":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align","68":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_","69":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import","70":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra","71":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.","72":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char","73":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_","74":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero","75":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.","76":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quot","77":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient","78":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from","79":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"","80":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"lean","81":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanpro","82":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover","83":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-","84":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community","85":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/","86":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/math","87":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib","88":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"","89":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"","90":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d","91":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d9","92":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90","93":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e","94":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4","95":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e","96":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e1","97":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e18","98":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186","99":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f","100":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1","101":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d","102":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d1","103":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18","104":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e","105":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e3","106":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e37","107":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375","108":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375d","109":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd","110":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4","111":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e","112":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5","113":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b","114":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5","115":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f","116":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6","117":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f63","118":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f636","119":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364","120":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b","121":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b0","122":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01","123":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb","124":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3","125":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e","126":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e4","127":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46","128":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"","129":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n","130":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n","131":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-","132":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!","133":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n","134":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n#","135":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lem","136":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas","137":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about","138":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quot","139":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients","140":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in","141":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic","142":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero","143":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n","144":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-","145":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/","146":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n","147":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n","148":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\n","149":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable","150":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {","151":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R","152":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R :","153":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type","154":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*}","155":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [","156":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [Div","157":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [Division","158":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionR","159":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing","160":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R","161":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R]","162":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [","163":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [Char","164":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero","165":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R","166":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R]","167":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {","168":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p","169":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p :","170":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R","171":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}","172":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n","173":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\n","174":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace","175":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace Add","176":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSub","177":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup","178":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n","179":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n","180":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/","181":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/--","182":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `","183":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z","184":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022","185":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r","186":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r`","187":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is","188":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a","189":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple","190":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of","191":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `","192":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p","193":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p`","194":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` if","195":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff","196":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `","197":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r","198":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r`","199":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is","200":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `","201":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk","202":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/","203":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z","204":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z`","205":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above","206":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a","207":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple","208":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of","209":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `","210":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p","211":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`,","212":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where","213":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `","214":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0","215":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 ","216":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264","217":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k","218":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k <","219":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |","220":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z","221":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|","222":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`.","223":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -","224":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/","225":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\n","226":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem","227":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem z","228":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsm","229":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul","230":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_","231":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem","232":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_","233":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_z","234":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmulti","235":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples","236":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_","237":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff","238":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_","239":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists","240":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_","241":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub","242":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_","243":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div","244":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {","245":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r","246":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r :","247":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R","248":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R}","249":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {","250":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z","251":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z :","252":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : ","253":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124","254":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124}","255":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (","256":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (h","257":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz","258":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz :","259":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z","260":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z ","261":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260","262":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 ","263":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0","264":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0)","265":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :","266":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n","267":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n   ","268":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z","269":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022","270":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r","271":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r ","272":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208","273":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 Add","274":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSub","275":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup","276":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.","277":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.z","278":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmulti","279":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples","280":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p","281":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p ","282":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194","283":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n","284":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      ","285":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203","286":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k","287":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k :","288":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin","289":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z","290":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.","291":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.nat","292":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAb","293":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs","294":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs,","295":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r","296":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r -","297":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (","298":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k","299":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k :","300":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : ","301":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115","302":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115)","303":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022","304":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (","305":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p","306":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/","307":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z","308":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z :","309":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R","310":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R)","311":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) ","312":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208","313":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 Add","314":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSub","315":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup","316":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.","317":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.z","318":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmulti","319":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples","320":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p","321":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p :=","322":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by","323":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n","324":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n ","325":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  r","326":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw","327":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [","328":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [Add","329":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSub","330":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup","331":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.","332":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem","333":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_","334":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_z","335":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmulti","336":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples","337":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_","338":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff","339":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]","340":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n","341":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n ","342":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp","343":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_","344":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw","345":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [","346":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [Add","347":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSub","348":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup","349":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.","350":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem","351":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_","352":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_z","353":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmulti","354":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples","355":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_","356":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff","357":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff,","358":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div","359":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_","360":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq","361":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_","362":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul","363":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_","364":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv","365":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv,","366":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, ","367":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190","368":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 sm","369":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul","370":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_","371":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul","372":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_","373":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc","374":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc,","375":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq","376":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_","377":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub","378":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_","379":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff","380":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_","381":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add","382":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_","383":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq","384":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]","385":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n","386":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n ","387":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have","388":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have h","389":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz","390":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz'","391":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' :","392":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (","393":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z","394":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z :","395":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R","396":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R)","397":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) ","398":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260","399":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 ","400":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0","401":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 :=","402":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int","403":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.","404":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast","405":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_","406":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne","407":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_","408":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero","409":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.","410":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.m","411":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr","412":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr h","413":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz","414":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n","415":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n ","416":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv","417":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_","418":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_r","419":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs","420":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs =>","421":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp","422":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (","423":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config","424":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config :=","425":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := {","426":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { single","427":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass","428":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass :=","429":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true","430":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true })","431":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only","432":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [","433":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190","434":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (","435":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul","436":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_","437":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right","438":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_","439":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_inject","440":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective","441":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080","442":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 h","443":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz","444":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').","445":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq","446":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_","447":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff","448":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]","449":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n","450":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n ","451":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp","452":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_","453":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw","454":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [","455":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190","456":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 z","457":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsm","458":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul","459":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_","460":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq","461":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_","462":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul","463":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul,","464":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, sm","465":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul","466":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_","467":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add","468":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add,","469":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, ","470":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190","471":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul","472":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_","473":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_sm","474":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul","475":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_","476":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm","477":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm,","478":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, z","479":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsm","480":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul","481":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_","482":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq","483":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_","484":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul","485":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (","486":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z","487":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z :","488":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R","489":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)","490":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b","491":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9","492":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9,","493":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul","494":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_","495":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv","496":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_","497":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel","498":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel h","499":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz","500":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',","501":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n","502":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n   ","503":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul","504":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_","505":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one","506":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one,","507":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, ","508":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190","509":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 co","510":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe","511":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_","512":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat","513":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_","514":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_z","515":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsm","516":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul","517":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul,","518":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, sm","519":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul","520":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_","521":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_sm","522":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul","523":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul,","524":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, ","525":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190","526":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add","527":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_","528":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_sm","529":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul","530":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]","531":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n","532":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n ","533":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor","534":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n","535":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n ","536":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7","537":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 r","538":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro","539":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro ","540":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8","541":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k","542":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k,","543":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h","544":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9","545":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n","546":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n   ","547":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp","548":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_","549":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw","550":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [","551":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190","552":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h","553":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]","554":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n","555":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n   ","556":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    ref","557":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine","558":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine'","559":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' ","560":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8","561":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8","562":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(","563":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k","564":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k %","565":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z","566":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).","567":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).to","568":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toN","569":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat","570":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat,","571":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _","572":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9","573":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9,","574":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k","575":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/","576":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z","577":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z,","578":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _","579":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9","580":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n","581":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n   ","582":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7","583":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 r","584":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw","585":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [","586":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190","587":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int","588":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.","589":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.of","590":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofN","591":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat","592":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_","593":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt","594":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt,","595":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int","596":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.","597":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.to","598":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toN","599":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat","600":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_","601":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of","602":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_","603":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_n","604":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonn","605":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg","606":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (","607":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int","608":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.","609":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.em","610":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod","611":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_","612":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_n","613":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonn","614":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg","615":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _","616":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ h","617":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz","618":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]","619":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n","620":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n     ","621":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact","622":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (","623":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int","624":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.","625":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.em","626":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod","627":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_","628":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt","629":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _","630":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ h","631":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz","632":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).","633":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans","634":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_","635":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq","636":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (","637":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int","638":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.","639":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs","640":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_","641":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq","642":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_","643":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_nat","644":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAb","645":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs","646":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)","647":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n","648":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n   ","649":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    r","650":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw","651":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [","652":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin","653":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.","654":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val","655":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_","656":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk","657":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk,","658":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int","659":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.","660":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.to","661":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toN","662":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat","663":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_","664":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of","665":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_","666":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_n","667":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonn","668":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg","669":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (","670":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int","671":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.","672":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.em","673":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod","674":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_","675":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_n","676":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonn","677":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg","678":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _","679":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ h","680":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz","681":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]","682":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n","683":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n   ","684":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    n","685":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth","686":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_","687":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite","688":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite ","689":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3","690":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [","691":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190","692":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int","693":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.","694":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div","695":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_","696":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add","697":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_","698":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod","699":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k","700":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z","701":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]","702":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n","703":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n   ","704":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    r","705":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw","706":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [","707":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int","708":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.","709":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod","710":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_","711":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def","712":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def,","713":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, ","714":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190","715":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int","716":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.","717":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div","718":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_","719":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def","720":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def',","721":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int","722":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.","723":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.em","724":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod","725":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_","726":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def","727":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]","728":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n","729":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n   ","730":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp","731":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only","732":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [","733":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add","734":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_","735":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub","736":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_","737":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel","738":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_","739":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right","740":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right,","741":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, z","742":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsm","743":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul","744":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_","745":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq","746":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_","747":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul","748":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul,","749":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int","750":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.","751":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div","752":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_","753":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def","754":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']","755":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n","756":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n ","757":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7","758":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 r","759":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro","760":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro ","761":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8","762":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k","763":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k,","764":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n","765":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n,","766":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h","767":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9","768":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n","769":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n   ","770":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact","771":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact ","772":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8","773":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_,","774":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h","775":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9","776":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n","777":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#","778":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align","779":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add","780":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_","781":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_sub","782":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup","783":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.","784":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.z","785":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsm","786":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul","787":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_","788":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem","789":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_","790":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_z","791":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmulti","792":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples","793":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_","794":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff","795":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_","796":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists","797":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_","798":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub","799":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_","800":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div","801":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div Add","802":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSub","803":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup","804":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.","805":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.z","806":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsm","807":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul","808":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_","809":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem","810":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_","811":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_z","812":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmulti","813":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples","814":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_","815":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff","816":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_","817":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists","818":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_","819":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub","820":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_","821":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div","822":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n","823":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\n","824":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem","825":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem n","826":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsm","827":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul","828":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_","829":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem","830":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_","831":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_z","832":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmulti","833":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples","834":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_","835":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff","836":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_","837":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists","838":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_","839":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub","840":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_","841":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div","842":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {","843":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r","844":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r :","845":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R","846":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R}","847":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {","848":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n","849":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n :","850":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : ","851":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115","852":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115}","853":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (","854":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn","855":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn :","856":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n","857":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n ","858":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260","859":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 ","860":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0","861":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0)","862":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :","863":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n","864":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n   ","865":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n","866":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022","867":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r","868":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r ","869":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208","870":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 Add","871":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSub","872":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup","873":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.","874":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.z","875":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmulti","876":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples","877":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p","878":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p ","879":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194","880":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n","881":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      ","882":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203","883":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k","884":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k :","885":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin","886":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n","887":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n,","888":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r","889":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r -","890":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (","891":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k","892":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k :","893":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : ","894":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115","895":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115)","896":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022","897":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (","898":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p","899":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/","900":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n","901":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n :","902":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R","903":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R)","904":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) ","905":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208","906":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 Add","907":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSub","908":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup","909":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.","910":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.z","911":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmulti","912":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples","913":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p","914":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p :=","915":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by","916":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n","917":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n ","918":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  r","919":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw","920":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [","921":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190","922":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 co","923":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe","924":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_","925":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat","926":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_","927":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_z","928":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsm","929":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul","930":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r","931":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r,","932":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, z","933":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsm","934":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul","935":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_","936":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem","937":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_","938":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_z","939":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmulti","940":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples","941":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_","942":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff","943":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_","944":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists","945":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_","946":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub","947":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_","948":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div","949":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (","950":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int","951":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.","952":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.co","953":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe","954":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_","955":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat","956":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_","957":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne","958":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_","959":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero","960":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.","961":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.m","962":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr","963":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr h","964":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn","965":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),","966":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n","967":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n   ","968":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int","969":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.","970":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast","971":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_","972":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_of","973":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofN","974":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat","975":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]","976":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n","977":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n ","978":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  r","979":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl","980":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n","981":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#","982":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align","983":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add","984":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_","985":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_sub","986":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup","987":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.","988":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.ns","989":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul","990":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_","991":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem","992":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_","993":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_z","994":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmulti","995":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples","996":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_","997":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff","998":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_","999":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists","1000":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_","1001":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub","1002":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_","1003":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div","1004":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div Add","1005":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSub","1006":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup","1007":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.","1008":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.ns","1009":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul","1010":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_","1011":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem","1012":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_","1013":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_z","1014":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmulti","1015":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples","1016":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_","1017":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff","1018":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_","1019":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists","1020":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_","1021":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub","1022":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_","1023":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div","1024":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n","1025":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\n","1026":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend","1027":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend Add","1028":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSub","1029":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup","1030":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n","1031":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\n","1032":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace","1033":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace Qu","1034":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace Quot","1035":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace Quotient","1036":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAdd","1037":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup","1038":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n","1039":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\n","1040":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem","1041":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem z","1042":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmulti","1043":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples","1044":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_","1045":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_z","1046":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsm","1047":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul","1048":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_","1049":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq","1050":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_","1051":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_z","1052":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsm","1053":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul","1054":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_","1055":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff","1056":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {","1057":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8","1058":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 ","1059":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8","1060":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 :","1061":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R","1062":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R ","1063":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \ufffd","1064":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \ufffd\ufffd","1065":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8","1066":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 Add","1067":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSub","1068":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup","1069":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.","1070":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.z","1071":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmulti","1072":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples","1073":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p","1074":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p}","1075":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {","1076":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z","1077":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z :","1078":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : ","1079":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124","1080":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124}","1081":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (","1082":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (h","1083":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz","1084":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz :","1085":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z","1086":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z ","1087":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260","1088":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 ","1089":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0","1090":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0)","1091":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :","1092":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n","1093":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n   ","1094":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z","1095":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022","1096":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 ","1097":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8","1098":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 =","1099":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z","1100":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022","1101":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 ","1102":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8","1103":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 ","1104":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194","1105":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 ","1106":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203","1107":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k","1108":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k :","1109":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin","1110":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z","1111":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.","1112":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.nat","1113":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAb","1114":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs","1115":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs,","1116":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, ","1117":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8","1118":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 =","1119":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = ","1120":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8","1121":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 +","1122":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (","1123":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k","1124":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k :","1125":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : ","1126":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115","1127":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115)","1128":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022","1129":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (","1130":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p","1131":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/","1132":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z","1133":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z :","1134":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R","1135":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R)","1136":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) :=","1137":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by","1138":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n","1139":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n ","1140":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction","1141":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction ","1142":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8","1143":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using","1144":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Qu","1145":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quot","1146":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient","1147":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.","1148":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.indu","1149":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.induction","1150":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn","1151":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'","1152":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n","1153":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n ","1154":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction","1155":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction ","1156":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8","1157":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using","1158":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Qu","1159":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quot","1160":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient","1161":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.","1162":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.indu","1163":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.induction","1164":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn","1165":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'","1166":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n","1167":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n ","1168":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  --","1169":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Port","1170":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting","1171":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note","1172":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note:","1173":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Int","1174":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introdu","1175":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced","1176":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Z","1177":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp","1178":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation","1179":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to","1180":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to short","1181":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten","1182":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines","1183":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n","1184":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n ","1185":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let","1186":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Z","1187":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp","1188":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp :=","1189":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := Add","1190":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSub","1191":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup","1192":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.","1193":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.z","1194":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmulti","1195":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples","1196":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p","1197":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n","1198":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n ","1199":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have","1200":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have :","1201":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (","1202":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Qu","1203":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quot","1204":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient","1205":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.","1206":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk","1207":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk''","1208":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' :","1209":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R","1210":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192","1211":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R","1212":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R ","1213":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \ufffd","1214":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \ufffd\ufffd","1215":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8","1216":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Z","1217":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp","1218":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp)","1219":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) =","1220":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((","1221":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191","1222":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191)","1223":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) :","1224":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R","1225":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192","1226":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R","1227":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R ","1228":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \ufffd","1229":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \ufffd\ufffd","1230":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8","1231":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Z","1232":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp","1233":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp)","1234":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) :=","1235":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := r","1236":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl","1237":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n","1238":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n ","1239":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp","1240":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only","1241":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [","1242":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this","1243":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]","1244":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n","1245":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n ","1246":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp","1247":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_","1248":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw","1249":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [","1250":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190","1251":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 Qu","1252":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 Quot","1253":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 Quotient","1254":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAdd","1255":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup","1256":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.","1257":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk","1258":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_","1259":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_z","1260":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsm","1261":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul","1262":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul,","1263":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, ","1264":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190","1265":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 Qu","1266":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 Quot","1267":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 Quotient","1268":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAdd","1269":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup","1270":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.","1271":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk","1272":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_","1273":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add","1274":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,","1275":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n","1276":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n   ","1277":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    Qu","1278":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    Quot","1279":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    Quotient","1280":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAdd","1281":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup","1282":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.","1283":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq","1284":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_","1285":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff","1286":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_","1287":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub","1288":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_","1289":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem","1290":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem,","1291":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, ","1292":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190","1293":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 sm","1294":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul","1295":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_","1296":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub","1297":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub,","1298":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, ","1299":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190","1300":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub","1301":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_","1302":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub","1303":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]","1304":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n","1305":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n ","1306":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact","1307":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact Add","1308":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSub","1309":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup","1310":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.","1311":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.z","1312":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsm","1313":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul","1314":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_","1315":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem","1316":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_","1317":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_z","1318":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmulti","1319":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples","1320":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_","1321":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff","1322":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_","1323":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists","1324":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_","1325":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub","1326":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_","1327":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div","1328":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div h","1329":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz","1330":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n","1331":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#","1332":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align","1333":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quot","1334":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient","1335":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_","1336":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add","1337":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_","1338":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group","1339":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.","1340":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.z","1341":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmulti","1342":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples","1343":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_","1344":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_z","1345":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsm","1346":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul","1347":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_","1348":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq","1349":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_","1350":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_z","1351":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsm","1352":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul","1353":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_","1354":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff","1355":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff Qu","1356":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff Quot","1357":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff Quotient","1358":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAdd","1359":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup","1360":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.","1361":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.z","1362":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmulti","1363":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples","1364":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_","1365":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_z","1366":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsm","1367":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul","1368":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_","1369":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq","1370":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_","1371":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_z","1372":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsm","1373":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul","1374":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_","1375":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff","1376":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n","1377":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\n","1378":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem","1379":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem z","1380":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmulti","1381":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples","1382":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_","1383":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_ns","1384":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul","1385":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_","1386":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq","1387":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_","1388":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_ns","1389":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul","1390":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_","1391":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff","1392":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {","1393":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8","1394":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 ","1395":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8","1396":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 :","1397":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R","1398":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R ","1399":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \ufffd","1400":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \ufffd\ufffd","1401":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8","1402":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 Add","1403":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSub","1404":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup","1405":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.","1406":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.z","1407":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmulti","1408":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples","1409":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p","1410":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p}","1411":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {","1412":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n","1413":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n :","1414":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : ","1415":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115","1416":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115}","1417":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (","1418":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (h","1419":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz","1420":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz :","1421":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n","1422":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n ","1423":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260","1424":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 ","1425":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0","1426":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0)","1427":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :","1428":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n","1429":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n   ","1430":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n","1431":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022","1432":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 ","1433":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8","1434":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 =","1435":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n","1436":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022","1437":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 ","1438":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8","1439":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 ","1440":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194","1441":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 ","1442":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203","1443":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k","1444":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k :","1445":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin","1446":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n","1447":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n,","1448":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, ","1449":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8","1450":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 =","1451":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = ","1452":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8","1453":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 +","1454":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (","1455":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k","1456":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k :","1457":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : ","1458":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115","1459":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115)","1460":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022","1461":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (","1462":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p","1463":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/","1464":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n","1465":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n :","1466":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R","1467":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R)","1468":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) :=","1469":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by","1470":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n","1471":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n ","1472":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  r","1473":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw","1474":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [","1475":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190","1476":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 co","1477":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe","1478":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_","1479":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat","1480":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_","1481":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_z","1482":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsm","1483":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul","1484":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul ","1485":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8","1486":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8,","1487":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, ","1488":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190","1489":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 co","1490":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe","1491":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_","1492":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat","1493":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_","1494":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_z","1495":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsm","1496":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul","1497":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul ","1498":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8","1499":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,","1500":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n","1501":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n   ","1502":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    z","1503":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmulti","1504":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples","1505":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_","1506":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_z","1507":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsm","1508":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul","1509":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_","1510":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq","1511":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_","1512":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_z","1513":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsm","1514":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul","1515":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_","1516":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff","1517":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (","1518":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int","1519":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.","1520":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.co","1521":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe","1522":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_","1523":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat","1524":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_","1525":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne","1526":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_","1527":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero","1528":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.","1529":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.m","1530":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr","1531":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr h","1532":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz","1533":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz),","1534":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int","1535":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.","1536":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast","1537":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_","1538":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_of","1539":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofN","1540":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat","1541":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]","1542":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n","1543":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n ","1544":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  r","1545":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl","1546":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n","1547":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#","1548":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align","1549":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quot","1550":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient","1551":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_","1552":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add","1553":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_","1554":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group","1555":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.","1556":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.z","1557":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmulti","1558":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples","1559":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_","1560":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_ns","1561":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul","1562":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_","1563":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq","1564":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_","1565":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_ns","1566":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul","1567":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_","1568":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff","1569":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff Qu","1570":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff Quot","1571":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff Quotient","1572":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAdd","1573":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup","1574":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.","1575":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.z","1576":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmulti","1577":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples","1578":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_","1579":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_ns","1580":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul","1581":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_","1582":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq","1583":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_","1584":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_ns","1585":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_nsmul","1586":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_nsmul_","1587":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_nsmul_iff","1588":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_nsmul_iff\n","1589":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_nsmul_iff\n\n","1590":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_nsmul_iff\n\nend","1591":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_nsmul_iff\n\nend Qu","1592":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_nsmul_iff\n\nend Quot","1593":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_nsmul_iff\n\nend Quotient","1594":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_nsmul_iff\n\nend QuotientAdd","1595":"\/-\nCopyright (c) 2022 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n-\/\nimport Mathlib.GroupTheory.QuotientGroup\n\n#align_import algebra.char_zero.quotient from \"leanprover-community\/mathlib\"@\"d90e4e186f1d18e375dcd4e5b5f6364b01cb3e46\"\n\n\/-!\n# Lemmas about quotients in characteristic zero\n-\/\n\n\nvariable {R : Type*} [DivisionRing R] [CharZero R] {p : R}\n\nnamespace AddSubgroup\n\n\/-- `z \u2022 r` is a multiple of `p` iff `r` is `pk\/z` above a multiple of `p`, where `0 \u2264 k < |z|`. -\/\ntheorem zsmul_mem_zmultiples_iff_exists_sub_div {r : R} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin z.natAbs, r - (k : \u2115) \u2022 (p \/ z : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [AddSubgroup.mem_zmultiples_iff]\n  simp_rw [AddSubgroup.mem_zmultiples_iff, div_eq_mul_inv, \u2190 smul_mul_assoc, eq_sub_iff_add_eq]\n  have hz' : (z : R) \u2260 0 := Int.cast_ne_zero.mpr hz\n  conv_rhs => simp (config := { singlePass := true }) only [\u2190 (mul_right_injective\u2080 hz').eq_iff]\n  simp_rw [\u2190 zsmul_eq_mul, smul_add, \u2190 mul_smul_comm, zsmul_eq_mul (z : R)\u207b\u00b9, mul_inv_cancel hz',\n    mul_one, \u2190 coe_nat_zsmul, smul_smul, \u2190 add_smul]\n  constructor\n  \u00b7 rintro \u27e8k, h\u27e9\n    simp_rw [\u2190 h]\n    refine' \u27e8\u27e8(k % z).toNat, _\u27e9, k \/ z, _\u27e9\n    \u00b7 rw [\u2190 Int.ofNat_lt, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n      exact (Int.emod_lt _ hz).trans_eq (Int.abs_eq_natAbs _)\n    rw [Fin.val_mk, Int.toNat_of_nonneg (Int.emod_nonneg _ hz)]\n    nth_rewrite 3 [\u2190 Int.div_add_mod k z]\n    rw [Int.mod_def, \u2190 Int.div_def', Int.emod_def]\n    simp only [add_sub_cancel'_right, zsmul_eq_mul, Int.div_def']\n  \u00b7 rintro \u27e8k, n, h\u27e9\n    exact \u27e8_, h\u27e9\n#align add_subgroup.zsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div\n\ntheorem nsmul_mem_zmultiples_iff_exists_sub_div {r : R} {n : \u2115} (hn : n \u2260 0) :\n    n \u2022 r \u2208 AddSubgroup.zmultiples p \u2194\n      \u2203 k : Fin n, r - (k : \u2115) \u2022 (p \/ n : R) \u2208 AddSubgroup.zmultiples p := by\n  rw [\u2190 coe_nat_zsmul r, zsmul_mem_zmultiples_iff_exists_sub_div (Int.coe_nat_ne_zero.mpr hn),\n    Int.cast_ofNat]\n  rfl\n#align add_subgroup.nsmul_mem_zmultiples_iff_exists_sub_div AddSubgroup.nsmul_mem_zmultiples_iff_exists_sub_div\n\nend AddSubgroup\n\nnamespace QuotientAddGroup\n\ntheorem zmultiples_zsmul_eq_zsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {z : \u2124} (hz : z \u2260 0) :\n    z \u2022 \u03c8 = z \u2022 \u03b8 \u2194 \u2203 k : Fin z.natAbs, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ z : R) := by\n  induction \u03c8 using Quotient.inductionOn'\n  induction \u03b8 using Quotient.inductionOn'\n  -- Porting note: Introduced Zp notation to shorten lines\n  let Zp := AddSubgroup.zmultiples p\n  have : (Quotient.mk'' : R \u2192 R \u29f8 Zp) = ((\u2191) : R \u2192 R \u29f8 Zp) := rfl\n  simp only [this]\n  simp_rw [\u2190 QuotientAddGroup.mk_zsmul, \u2190 QuotientAddGroup.mk_add,\n    QuotientAddGroup.eq_iff_sub_mem, \u2190 smul_sub, \u2190 sub_sub]\n  exact AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div hz\n#align quotient_add_group.zmultiples_zsmul_eq_zsmul_iff QuotientAddGroup.zmultiples_zsmul_eq_zsmul_iff\n\ntheorem zmultiples_nsmul_eq_nsmul_iff {\u03c8 \u03b8 : R \u29f8 AddSubgroup.zmultiples p} {n : \u2115} (hz : n \u2260 0) :\n    n \u2022 \u03c8 = n \u2022 \u03b8 \u2194 \u2203 k : Fin n, \u03c8 = \u03b8 + (k : \u2115) \u2022 (p \/ n : R) := by\n  rw [\u2190 coe_nat_zsmul \u03c8, \u2190 coe_nat_zsmul \u03b8,\n    zmultiples_zsmul_eq_zsmul_iff (Int.coe_nat_ne_zero.mpr hz), Int.cast_ofNat]\n  rfl\n#align quotient_add_group.zmultiples_nsmul_eq_nsmul_iff QuotientAddGroup.zmultiples_nsmul_eq_nsmul_iff\n\nend QuotientAddGroup"},"target":{"0":"-","1":"<0x0A>","2":"Copy","3":"right","4":"\u2581(","5":"c","6":")","7":"\u2581","8":"2","9":"0","10":"2","11":"2","12":"\u2581Eric","13":"\u2581Wies","14":"er","15":".","16":"\u2581All","17":"\u2581rights","18":"\u2581reserved","19":".","20":"<0x0A>","21":"Re","22":"leased","23":"\u2581under","24":"\u2581Apache","25":"\u2581","26":"2","27":".","28":"0","29":"\u2581license","30":"\u2581as","31":"\u2581described","32":"\u2581in","33":"\u2581the","34":"\u2581file","35":"\u2581L","36":"IC","37":"EN","38":"SE","39":".","40":"<0x0A>","41":"Auth","42":"ors","43":":","44":"\u2581Eric","45":"\u2581Wies","46":"er","47":"<0x0A>","48":"-","49":"\/","50":"<0x0A>","51":"import","52":"\u2581Math","53":"lib","54":".","55":"Group","56":"The","57":"ory","58":".","59":"Qu","60":"ot","61":"ient","62":"Group","63":"<0x0A>","64":"<0x0A>","65":"#","66":"align","67":"_","68":"import","69":"\u2581algebra","70":".","71":"char","72":"_","73":"zero","74":".","75":"quot","76":"ient","77":"\u2581from","78":"\u2581\"","79":"lean","80":"pro","81":"ver","82":"-","83":"community","84":"\/","85":"math","86":"lib","87":"\"","88":"@\"","89":"d","90":"9","91":"0","92":"e","93":"4","94":"e","95":"1","96":"8","97":"6","98":"f","99":"1","100":"d","101":"1","102":"8","103":"e","104":"3","105":"7","106":"5","107":"d","108":"cd","109":"4","110":"e","111":"5","112":"b","113":"5","114":"f","115":"6","116":"3","117":"6","118":"4","119":"b","120":"0","121":"1","122":"cb","123":"3","124":"e","125":"4","126":"6","127":"\"","128":"<0x0A>","129":"<0x0A>","130":"\/-","131":"!","132":"<0x0A>","133":"#","134":"\u2581Lem","135":"mas","136":"\u2581about","137":"\u2581quot","138":"ients","139":"\u2581in","140":"\u2581characteristic","141":"\u2581zero","142":"<0x0A>","143":"-","144":"\/","145":"<0x0A>","146":"<0x0A>","147":"<0x0A>","148":"variable","149":"\u2581{","150":"R","151":"\u2581:","152":"\u2581Type","153":"*}","154":"\u2581[","155":"Div","156":"ision","157":"R","158":"ing","159":"\u2581R","160":"]","161":"\u2581[","162":"Char","163":"Zero","164":"\u2581R","165":"]","166":"\u2581{","167":"p","168":"\u2581:","169":"\u2581R","170":"}","171":"<0x0A>","172":"<0x0A>","173":"namespace","174":"\u2581Add","175":"Sub","176":"group","177":"<0x0A>","178":"<0x0A>","179":"\/","180":"--","181":"\u2581`","182":"z","183":"\u2581\u2022","184":"\u2581r","185":"`","186":"\u2581is","187":"\u2581a","188":"\u2581multiple","189":"\u2581of","190":"\u2581`","191":"p","192":"`","193":"\u2581if","194":"f","195":"\u2581`","196":"r","197":"`","198":"\u2581is","199":"\u2581`","200":"pk","201":"\/","202":"z","203":"`","204":"\u2581above","205":"\u2581a","206":"\u2581multiple","207":"\u2581of","208":"\u2581`","209":"p","210":"`,","211":"\u2581where","212":"\u2581`","213":"0","214":"\u2581","215":"\u2264","216":"\u2581k","217":"\u2581<","218":"\u2581|","219":"z","220":"|","221":"`.","222":"\u2581-","223":"\/","224":"<0x0A>","225":"theorem","226":"\u2581z","227":"sm","228":"ul","229":"_","230":"mem","231":"_","232":"z","233":"multi","234":"ples","235":"_","236":"iff","237":"_","238":"exists","239":"_","240":"sub","241":"_","242":"div","243":"\u2581{","244":"r","245":"\u2581:","246":"\u2581R","247":"}","248":"\u2581{","249":"z","250":"\u2581:","251":"\u2581","252":"\u2124","253":"}","254":"\u2581(","255":"h","256":"z","257":"\u2581:","258":"\u2581z","259":"\u2581","260":"\u2260","261":"\u2581","262":"0","263":")","264":"\u2581:","265":"<0x0A>","266":"\u2581\u2581\u2581","267":"\u2581z","268":"\u2581\u2022","269":"\u2581r","270":"\u2581","271":"\u2208","272":"\u2581Add","273":"Sub","274":"group","275":".","276":"z","277":"multi","278":"ples","279":"\u2581p","280":"\u2581","281":"\u2194","282":"<0x0A>","283":"\u2581\u2581\u2581\u2581\u2581\u2581","284":"\u2203","285":"\u2581k","286":"\u2581:","287":"\u2581Fin","288":"\u2581z","289":".","290":"nat","291":"Ab","292":"s","293":",","294":"\u2581r","295":"\u2581-","296":"\u2581(","297":"k","298":"\u2581:","299":"\u2581","300":"\u2115","301":")","302":"\u2581\u2022","303":"\u2581(","304":"p","305":"\u2581\/","306":"\u2581z","307":"\u2581:","308":"\u2581R","309":")","310":"\u2581","311":"\u2208","312":"\u2581Add","313":"Sub","314":"group","315":".","316":"z","317":"multi","318":"ples","319":"\u2581p","320":"\u2581:=","321":"\u2581by","322":"<0x0A>","323":"\u2581","324":"\u2581r","325":"w","326":"\u2581[","327":"Add","328":"Sub","329":"group","330":".","331":"mem","332":"_","333":"z","334":"multi","335":"ples","336":"_","337":"iff","338":"]","339":"<0x0A>","340":"\u2581","341":"\u2581simp","342":"_","343":"rw","344":"\u2581[","345":"Add","346":"Sub","347":"group","348":".","349":"mem","350":"_","351":"z","352":"multi","353":"ples","354":"_","355":"iff","356":",","357":"\u2581div","358":"_","359":"eq","360":"_","361":"mul","362":"_","363":"inv","364":",","365":"\u2581","366":"\u2190","367":"\u2581sm","368":"ul","369":"_","370":"mul","371":"_","372":"assoc","373":",","374":"\u2581eq","375":"_","376":"sub","377":"_","378":"iff","379":"_","380":"add","381":"_","382":"eq","383":"]","384":"<0x0A>","385":"\u2581","386":"\u2581have","387":"\u2581h","388":"z","389":"'","390":"\u2581:","391":"\u2581(","392":"z","393":"\u2581:","394":"\u2581R","395":")","396":"\u2581","397":"\u2260","398":"\u2581","399":"0","400":"\u2581:=","401":"\u2581Int","402":".","403":"cast","404":"_","405":"ne","406":"_","407":"zero","408":".","409":"m","410":"pr","411":"\u2581h","412":"z","413":"<0x0A>","414":"\u2581","415":"\u2581conv","416":"_","417":"r","418":"hs","419":"\u2581=>","420":"\u2581simp","421":"\u2581(","422":"config","423":"\u2581:=","424":"\u2581{","425":"\u2581single","426":"Pass","427":"\u2581:=","428":"\u2581true","429":"\u2581})","430":"\u2581only","431":"\u2581[","432":"\u2190","433":"\u2581(","434":"mul","435":"_","436":"right","437":"_","438":"inject","439":"ive","440":"\u2080","441":"\u2581h","442":"z","443":"').","444":"eq","445":"_","446":"iff","447":"]","448":"<0x0A>","449":"\u2581","450":"\u2581simp","451":"_","452":"rw","453":"\u2581[","454":"\u2190","455":"\u2581z","456":"sm","457":"ul","458":"_","459":"eq","460":"_","461":"mul","462":",","463":"\u2581sm","464":"ul","465":"_","466":"add","467":",","468":"\u2581","469":"\u2190","470":"\u2581mul","471":"_","472":"sm","473":"ul","474":"_","475":"comm","476":",","477":"\u2581z","478":"sm","479":"ul","480":"_","481":"eq","482":"_","483":"mul","484":"\u2581(","485":"z","486":"\u2581:","487":"\u2581R","488":")","489":"\u207b","490":"\u00b9","491":",","492":"\u2581mul","493":"_","494":"inv","495":"_","496":"cancel","497":"\u2581h","498":"z","499":"',","500":"<0x0A>","501":"\u2581\u2581\u2581","502":"\u2581mul","503":"_","504":"one","505":",","506":"\u2581","507":"\u2190","508":"\u2581co","509":"e","510":"_","511":"nat","512":"_","513":"z","514":"sm","515":"ul","516":",","517":"\u2581sm","518":"ul","519":"_","520":"sm","521":"ul","522":",","523":"\u2581","524":"\u2190","525":"\u2581add","526":"_","527":"sm","528":"ul","529":"]","530":"<0x0A>","531":"\u2581","532":"\u2581constructor","533":"<0x0A>","534":"\u2581","535":"\u2581\u00b7","536":"\u2581r","537":"intro","538":"\u2581","539":"\u27e8","540":"k","541":",","542":"\u2581h","543":"\u27e9","544":"<0x0A>","545":"\u2581\u2581\u2581","546":"\u2581simp","547":"_","548":"rw","549":"\u2581[","550":"\u2190","551":"\u2581h","552":"]","553":"<0x0A>","554":"\u2581\u2581\u2581","555":"\u2581ref","556":"ine","557":"'","558":"\u2581","559":"\u27e8","560":"\u27e8","561":"(","562":"k","563":"\u2581%","564":"\u2581z","565":").","566":"to","567":"N","568":"at","569":",","570":"\u2581_","571":"\u27e9","572":",","573":"\u2581k","574":"\u2581\/","575":"\u2581z","576":",","577":"\u2581_","578":"\u27e9","579":"<0x0A>","580":"\u2581\u2581\u2581","581":"\u2581\u00b7","582":"\u2581r","583":"w","584":"\u2581[","585":"\u2190","586":"\u2581Int","587":".","588":"of","589":"N","590":"at","591":"_","592":"lt","593":",","594":"\u2581Int","595":".","596":"to","597":"N","598":"at","599":"_","600":"of","601":"_","602":"n","603":"onn","604":"eg","605":"\u2581(","606":"Int","607":".","608":"em","609":"od","610":"_","611":"n","612":"onn","613":"eg","614":"\u2581_","615":"\u2581h","616":"z","617":")]","618":"<0x0A>","619":"\u2581\u2581\u2581\u2581\u2581","620":"\u2581exact","621":"\u2581(","622":"Int","623":".","624":"em","625":"od","626":"_","627":"lt","628":"\u2581_","629":"\u2581h","630":"z","631":").","632":"trans","633":"_","634":"eq","635":"\u2581(","636":"Int","637":".","638":"abs","639":"_","640":"eq","641":"_","642":"nat","643":"Ab","644":"s","645":"\u2581_)","646":"<0x0A>","647":"\u2581\u2581\u2581","648":"\u2581r","649":"w","650":"\u2581[","651":"Fin","652":".","653":"val","654":"_","655":"mk","656":",","657":"\u2581Int","658":".","659":"to","660":"N","661":"at","662":"_","663":"of","664":"_","665":"n","666":"onn","667":"eg","668":"\u2581(","669":"Int","670":".","671":"em","672":"od","673":"_","674":"n","675":"onn","676":"eg","677":"\u2581_","678":"\u2581h","679":"z","680":")]","681":"<0x0A>","682":"\u2581\u2581\u2581","683":"\u2581n","684":"th","685":"_","686":"rewrite","687":"\u2581","688":"3","689":"\u2581[","690":"\u2190","691":"\u2581Int","692":".","693":"div","694":"_","695":"add","696":"_","697":"mod","698":"\u2581k","699":"\u2581z","700":"]","701":"<0x0A>","702":"\u2581\u2581\u2581","703":"\u2581r","704":"w","705":"\u2581[","706":"Int","707":".","708":"mod","709":"_","710":"def","711":",","712":"\u2581","713":"\u2190","714":"\u2581Int","715":".","716":"div","717":"_","718":"def","719":"',","720":"\u2581Int","721":".","722":"em","723":"od","724":"_","725":"def","726":"]","727":"<0x0A>","728":"\u2581\u2581\u2581","729":"\u2581simp","730":"\u2581only","731":"\u2581[","732":"add","733":"_","734":"sub","735":"_","736":"cancel","737":"'_","738":"right","739":",","740":"\u2581z","741":"sm","742":"ul","743":"_","744":"eq","745":"_","746":"mul","747":",","748":"\u2581Int","749":".","750":"div","751":"_","752":"def","753":"']","754":"<0x0A>","755":"\u2581","756":"\u2581\u00b7","757":"\u2581r","758":"intro","759":"\u2581","760":"\u27e8","761":"k","762":",","763":"\u2581n","764":",","765":"\u2581h","766":"\u27e9","767":"<0x0A>","768":"\u2581\u2581\u2581","769":"\u2581exact","770":"\u2581","771":"\u27e8","772":"_,","773":"\u2581h","774":"\u27e9","775":"<0x0A>","776":"#","777":"align","778":"\u2581add","779":"_","780":"sub","781":"group","782":".","783":"z","784":"sm","785":"ul","786":"_","787":"mem","788":"_","789":"z","790":"multi","791":"ples","792":"_","793":"iff","794":"_","795":"exists","796":"_","797":"sub","798":"_","799":"div","800":"\u2581Add","801":"Sub","802":"group","803":".","804":"z","805":"sm","806":"ul","807":"_","808":"mem","809":"_","810":"z","811":"multi","812":"ples","813":"_","814":"iff","815":"_","816":"exists","817":"_","818":"sub","819":"_","820":"div","821":"<0x0A>","822":"<0x0A>","823":"theorem","824":"\u2581n","825":"sm","826":"ul","827":"_","828":"mem","829":"_","830":"z","831":"multi","832":"ples","833":"_","834":"iff","835":"_","836":"exists","837":"_","838":"sub","839":"_","840":"div","841":"\u2581{","842":"r","843":"\u2581:","844":"\u2581R","845":"}","846":"\u2581{","847":"n","848":"\u2581:","849":"\u2581","850":"\u2115","851":"}","852":"\u2581(","853":"hn","854":"\u2581:","855":"\u2581n","856":"\u2581","857":"\u2260","858":"\u2581","859":"0","860":")","861":"\u2581:","862":"<0x0A>","863":"\u2581\u2581\u2581","864":"\u2581n","865":"\u2581\u2022","866":"\u2581r","867":"\u2581","868":"\u2208","869":"\u2581Add","870":"Sub","871":"group","872":".","873":"z","874":"multi","875":"ples","876":"\u2581p","877":"\u2581","878":"\u2194","879":"<0x0A>","880":"\u2581\u2581\u2581\u2581\u2581\u2581","881":"\u2203","882":"\u2581k","883":"\u2581:","884":"\u2581Fin","885":"\u2581n","886":",","887":"\u2581r","888":"\u2581-","889":"\u2581(","890":"k","891":"\u2581:","892":"\u2581","893":"\u2115","894":")","895":"\u2581\u2022","896":"\u2581(","897":"p","898":"\u2581\/","899":"\u2581n","900":"\u2581:","901":"\u2581R","902":")","903":"\u2581","904":"\u2208","905":"\u2581Add","906":"Sub","907":"group","908":".","909":"z","910":"multi","911":"ples","912":"\u2581p","913":"\u2581:=","914":"\u2581by","915":"<0x0A>","916":"\u2581","917":"\u2581r","918":"w","919":"\u2581[","920":"\u2190","921":"\u2581co","922":"e","923":"_","924":"nat","925":"_","926":"z","927":"sm","928":"ul","929":"\u2581r","930":",","931":"\u2581z","932":"sm","933":"ul","934":"_","935":"mem","936":"_","937":"z","938":"multi","939":"ples","940":"_","941":"iff","942":"_","943":"exists","944":"_","945":"sub","946":"_","947":"div","948":"\u2581(","949":"Int","950":".","951":"co","952":"e","953":"_","954":"nat","955":"_","956":"ne","957":"_","958":"zero","959":".","960":"m","961":"pr","962":"\u2581h","963":"n","964":"),","965":"<0x0A>","966":"\u2581\u2581\u2581","967":"\u2581Int","968":".","969":"cast","970":"_","971":"of","972":"N","973":"at","974":"]","975":"<0x0A>","976":"\u2581","977":"\u2581r","978":"fl","979":"<0x0A>","980":"#","981":"align","982":"\u2581add","983":"_","984":"sub","985":"group","986":".","987":"ns","988":"mul","989":"_","990":"mem","991":"_","992":"z","993":"multi","994":"ples","995":"_","996":"iff","997":"_","998":"exists","999":"_","1000":"sub","1001":"_","1002":"div","1003":"\u2581Add","1004":"Sub","1005":"group","1006":".","1007":"ns","1008":"mul","1009":"_","1010":"mem","1011":"_","1012":"z","1013":"multi","1014":"ples","1015":"_","1016":"iff","1017":"_","1018":"exists","1019":"_","1020":"sub","1021":"_","1022":"div","1023":"<0x0A>","1024":"<0x0A>","1025":"end","1026":"\u2581Add","1027":"Sub","1028":"group","1029":"<0x0A>","1030":"<0x0A>","1031":"namespace","1032":"\u2581Qu","1033":"ot","1034":"ient","1035":"Add","1036":"Group","1037":"<0x0A>","1038":"<0x0A>","1039":"theorem","1040":"\u2581z","1041":"multi","1042":"ples","1043":"_","1044":"z","1045":"sm","1046":"ul","1047":"_","1048":"eq","1049":"_","1050":"z","1051":"sm","1052":"ul","1053":"_","1054":"iff","1055":"\u2581{","1056":"\u03c8","1057":"\u2581","1058":"\u03b8","1059":"\u2581:","1060":"\u2581R","1061":"\u2581","1062":"<0xE2>","1063":"<0xA7>","1064":"<0xB8>","1065":"\u2581Add","1066":"Sub","1067":"group","1068":".","1069":"z","1070":"multi","1071":"ples","1072":"\u2581p","1073":"}","1074":"\u2581{","1075":"z","1076":"\u2581:","1077":"\u2581","1078":"\u2124","1079":"}","1080":"\u2581(","1081":"h","1082":"z","1083":"\u2581:","1084":"\u2581z","1085":"\u2581","1086":"\u2260","1087":"\u2581","1088":"0","1089":")","1090":"\u2581:","1091":"<0x0A>","1092":"\u2581\u2581\u2581","1093":"\u2581z","1094":"\u2581\u2022","1095":"\u2581","1096":"\u03c8","1097":"\u2581=","1098":"\u2581z","1099":"\u2581\u2022","1100":"\u2581","1101":"\u03b8","1102":"\u2581","1103":"\u2194","1104":"\u2581","1105":"\u2203","1106":"\u2581k","1107":"\u2581:","1108":"\u2581Fin","1109":"\u2581z","1110":".","1111":"nat","1112":"Ab","1113":"s","1114":",","1115":"\u2581","1116":"\u03c8","1117":"\u2581=","1118":"\u2581","1119":"\u03b8","1120":"\u2581+","1121":"\u2581(","1122":"k","1123":"\u2581:","1124":"\u2581","1125":"\u2115","1126":")","1127":"\u2581\u2022","1128":"\u2581(","1129":"p","1130":"\u2581\/","1131":"\u2581z","1132":"\u2581:","1133":"\u2581R","1134":")","1135":"\u2581:=","1136":"\u2581by","1137":"<0x0A>","1138":"\u2581","1139":"\u2581induction","1140":"\u2581","1141":"\u03c8","1142":"\u2581using","1143":"\u2581Qu","1144":"ot","1145":"ient","1146":".","1147":"indu","1148":"ction","1149":"On","1150":"'","1151":"<0x0A>","1152":"\u2581","1153":"\u2581induction","1154":"\u2581","1155":"\u03b8","1156":"\u2581using","1157":"\u2581Qu","1158":"ot","1159":"ient","1160":".","1161":"indu","1162":"ction","1163":"On","1164":"'","1165":"<0x0A>","1166":"\u2581","1167":"\u2581--","1168":"\u2581Port","1169":"ing","1170":"\u2581note","1171":":","1172":"\u2581Int","1173":"rodu","1174":"ced","1175":"\u2581Z","1176":"p","1177":"\u2581notation","1178":"\u2581to","1179":"\u2581short","1180":"en","1181":"\u2581lines","1182":"<0x0A>","1183":"\u2581","1184":"\u2581let","1185":"\u2581Z","1186":"p","1187":"\u2581:=","1188":"\u2581Add","1189":"Sub","1190":"group","1191":".","1192":"z","1193":"multi","1194":"ples","1195":"\u2581p","1196":"<0x0A>","1197":"\u2581","1198":"\u2581have","1199":"\u2581:","1200":"\u2581(","1201":"Qu","1202":"ot","1203":"ient","1204":".","1205":"mk","1206":"''","1207":"\u2581:","1208":"\u2581R","1209":"\u2581\u2192","1210":"\u2581R","1211":"\u2581","1212":"<0xE2>","1213":"<0xA7>","1214":"<0xB8>","1215":"\u2581Z","1216":"p","1217":")","1218":"\u2581=","1219":"\u2581((","1220":"\u2191","1221":")","1222":"\u2581:","1223":"\u2581R","1224":"\u2581\u2192","1225":"\u2581R","1226":"\u2581","1227":"<0xE2>","1228":"<0xA7>","1229":"<0xB8>","1230":"\u2581Z","1231":"p","1232":")","1233":"\u2581:=","1234":"\u2581r","1235":"fl","1236":"<0x0A>","1237":"\u2581","1238":"\u2581simp","1239":"\u2581only","1240":"\u2581[","1241":"this","1242":"]","1243":"<0x0A>","1244":"\u2581","1245":"\u2581simp","1246":"_","1247":"rw","1248":"\u2581[","1249":"\u2190","1250":"\u2581Qu","1251":"ot","1252":"ient","1253":"Add","1254":"Group","1255":".","1256":"mk","1257":"_","1258":"z","1259":"sm","1260":"ul","1261":",","1262":"\u2581","1263":"\u2190","1264":"\u2581Qu","1265":"ot","1266":"ient","1267":"Add","1268":"Group","1269":".","1270":"mk","1271":"_","1272":"add","1273":",","1274":"<0x0A>","1275":"\u2581\u2581\u2581","1276":"\u2581Qu","1277":"ot","1278":"ient","1279":"Add","1280":"Group","1281":".","1282":"eq","1283":"_","1284":"iff","1285":"_","1286":"sub","1287":"_","1288":"mem","1289":",","1290":"\u2581","1291":"\u2190","1292":"\u2581sm","1293":"ul","1294":"_","1295":"sub","1296":",","1297":"\u2581","1298":"\u2190","1299":"\u2581sub","1300":"_","1301":"sub","1302":"]","1303":"<0x0A>","1304":"\u2581","1305":"\u2581exact","1306":"\u2581Add","1307":"Sub","1308":"group","1309":".","1310":"z","1311":"sm","1312":"ul","1313":"_","1314":"mem","1315":"_","1316":"z","1317":"multi","1318":"ples","1319":"_","1320":"iff","1321":"_","1322":"exists","1323":"_","1324":"sub","1325":"_","1326":"div","1327":"\u2581h","1328":"z","1329":"<0x0A>","1330":"#","1331":"align","1332":"\u2581quot","1333":"ient","1334":"_","1335":"add","1336":"_","1337":"group","1338":".","1339":"z","1340":"multi","1341":"ples","1342":"_","1343":"z","1344":"sm","1345":"ul","1346":"_","1347":"eq","1348":"_","1349":"z","1350":"sm","1351":"ul","1352":"_","1353":"iff","1354":"\u2581Qu","1355":"ot","1356":"ient","1357":"Add","1358":"Group","1359":".","1360":"z","1361":"multi","1362":"ples","1363":"_","1364":"z","1365":"sm","1366":"ul","1367":"_","1368":"eq","1369":"_","1370":"z","1371":"sm","1372":"ul","1373":"_","1374":"iff","1375":"<0x0A>","1376":"<0x0A>","1377":"theorem","1378":"\u2581z","1379":"multi","1380":"ples","1381":"_","1382":"ns","1383":"mul","1384":"_","1385":"eq","1386":"_","1387":"ns","1388":"mul","1389":"_","1390":"iff","1391":"\u2581{","1392":"\u03c8","1393":"\u2581","1394":"\u03b8","1395":"\u2581:","1396":"\u2581R","1397":"\u2581","1398":"<0xE2>","1399":"<0xA7>","1400":"<0xB8>","1401":"\u2581Add","1402":"Sub","1403":"group","1404":".","1405":"z","1406":"multi","1407":"ples","1408":"\u2581p","1409":"}","1410":"\u2581{","1411":"n","1412":"\u2581:","1413":"\u2581","1414":"\u2115","1415":"}","1416":"\u2581(","1417":"h","1418":"z","1419":"\u2581:","1420":"\u2581n","1421":"\u2581","1422":"\u2260","1423":"\u2581","1424":"0","1425":")","1426":"\u2581:","1427":"<0x0A>","1428":"\u2581\u2581\u2581","1429":"\u2581n","1430":"\u2581\u2022","1431":"\u2581","1432":"\u03c8","1433":"\u2581=","1434":"\u2581n","1435":"\u2581\u2022","1436":"\u2581","1437":"\u03b8","1438":"\u2581","1439":"\u2194","1440":"\u2581","1441":"\u2203","1442":"\u2581k","1443":"\u2581:","1444":"\u2581Fin","1445":"\u2581n","1446":",","1447":"\u2581","1448":"\u03c8","1449":"\u2581=","1450":"\u2581","1451":"\u03b8","1452":"\u2581+","1453":"\u2581(","1454":"k","1455":"\u2581:","1456":"\u2581","1457":"\u2115","1458":")","1459":"\u2581\u2022","1460":"\u2581(","1461":"p","1462":"\u2581\/","1463":"\u2581n","1464":"\u2581:","1465":"\u2581R","1466":")","1467":"\u2581:=","1468":"\u2581by","1469":"<0x0A>","1470":"\u2581","1471":"\u2581r","1472":"w","1473":"\u2581[","1474":"\u2190","1475":"\u2581co","1476":"e","1477":"_","1478":"nat","1479":"_","1480":"z","1481":"sm","1482":"ul","1483":"\u2581","1484":"\u03c8","1485":",","1486":"\u2581","1487":"\u2190","1488":"\u2581co","1489":"e","1490":"_","1491":"nat","1492":"_","1493":"z","1494":"sm","1495":"ul","1496":"\u2581","1497":"\u03b8","1498":",","1499":"<0x0A>","1500":"\u2581\u2581\u2581","1501":"\u2581z","1502":"multi","1503":"ples","1504":"_","1505":"z","1506":"sm","1507":"ul","1508":"_","1509":"eq","1510":"_","1511":"z","1512":"sm","1513":"ul","1514":"_","1515":"iff","1516":"\u2581(","1517":"Int","1518":".","1519":"co","1520":"e","1521":"_","1522":"nat","1523":"_","1524":"ne","1525":"_","1526":"zero","1527":".","1528":"m","1529":"pr","1530":"\u2581h","1531":"z","1532":"),","1533":"\u2581Int","1534":".","1535":"cast","1536":"_","1537":"of","1538":"N","1539":"at","1540":"]","1541":"<0x0A>","1542":"\u2581","1543":"\u2581r","1544":"fl","1545":"<0x0A>","1546":"#","1547":"align","1548":"\u2581quot","1549":"ient","1550":"_","1551":"add","1552":"_","1553":"group","1554":".","1555":"z","1556":"multi","1557":"ples","1558":"_","1559":"ns","1560":"mul","1561":"_","1562":"eq","1563":"_","1564":"ns","1565":"mul","1566":"_","1567":"iff","1568":"\u2581Qu","1569":"ot","1570":"ient","1571":"Add","1572":"Group","1573":".","1574":"z","1575":"multi","1576":"ples","1577":"_","1578":"ns","1579":"mul","1580":"_","1581":"eq","1582":"_","1583":"ns","1584":"mul","1585":"_","1586":"iff","1587":"<0x0A>","1588":"<0x0A>","1589":"end","1590":"\u2581Qu","1591":"ot","1592":"ient","1593":"Add","1594":"Group","1595":"<0x0A>"}}