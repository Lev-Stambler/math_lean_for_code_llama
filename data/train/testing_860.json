{"input":{"0":"\/","1":"\/-","2":"\/-\n","3":"\/-\nCopy","4":"\/-\nCopyright","5":"\/-\nCopyright (","6":"\/-\nCopyright (c","7":"\/-\nCopyright (c)","8":"\/-\nCopyright (c) ","9":"\/-\nCopyright (c) 2","10":"\/-\nCopyright (c) 20","11":"\/-\nCopyright (c) 202","12":"\/-\nCopyright (c) 2022","13":"\/-\nCopyright (c) 2022 Y","14":"\/-\nCopyright (c) 2022 Yury","15":"\/-\nCopyright (c) 2022 Yury K","16":"\/-\nCopyright (c) 2022 Yury Kud","17":"\/-\nCopyright (c) 2022 Yury Kudry","18":"\/-\nCopyright (c) 2022 Yury Kudryash","19":"\/-\nCopyright (c) 2022 Yury Kudryashov","20":"\/-\nCopyright (c) 2022 Yury Kudryashov.","21":"\/-\nCopyright (c) 2022 Yury Kudryashov. All","22":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights","23":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved","24":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.","25":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\n","26":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nRe","27":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased","28":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under","29":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache","30":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache ","31":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2","32":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.","33":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0","34":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license","35":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as","36":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described","37":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in","38":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the","39":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file","40":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file L","41":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LIC","42":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICEN","43":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE","44":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.","45":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\n","46":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuth","47":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors","48":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors:","49":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Y","50":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury","51":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury K","52":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kud","53":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudry","54":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryash","55":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov","56":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n","57":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-","58":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/","59":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\n","60":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport","61":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Math","62":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib","63":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.","64":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Al","65":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra","66":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.","67":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.Free","68":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeM","69":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMono","70":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid","71":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.","72":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic","73":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\n","74":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport","75":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Math","76":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib","77":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.","78":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data","79":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.","80":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List","81":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.","82":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count","83":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n","84":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n","85":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#","86":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align","87":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_","88":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import","89":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra","90":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.","91":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free","92":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_","93":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_m","94":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_mono","95":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid","96":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.","97":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count","98":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from","99":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"","100":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"lean","101":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanpro","102":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover","103":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-","104":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community","105":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/","106":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/math","107":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib","108":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"","109":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"","110":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a","111":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2","112":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d","113":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2","114":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e","115":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e1","116":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18","117":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e189","118":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e1890","119":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906","120":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e","121":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2","122":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b","123":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b6","124":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62","125":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b626","126":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b6262","127":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627","128":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b626276","129":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b6262764","130":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646","131":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b","132":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5","133":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d","134":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5","135":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be","136":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be8","137":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be85","138":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856","139":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e","140":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6","141":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a","142":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a6","143":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a64","144":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642","145":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a6420","146":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a64206","147":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062","148":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f","149":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"","150":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n","151":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n","152":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-","153":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!","154":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n","155":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n#","156":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `","157":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List","158":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.","159":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count","160":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count`","161":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as","162":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a","163":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bund","164":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled","165":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled hom","166":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism","167":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n","168":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\n","169":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn","170":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this","171":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file","172":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we","173":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define","174":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `","175":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `Free","176":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeM","177":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMono","178":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid","179":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.","180":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.count","181":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP","182":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`,","183":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `","184":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `Free","185":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeM","186":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMono","187":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid","188":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.","189":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count","190":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`,","191":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `","192":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `Free","193":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAdd","194":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddM","195":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMono","196":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid","197":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.","198":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.count","199":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP","200":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`,","201":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and","202":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n","203":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`","204":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`Free","205":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAdd","206":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddM","207":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMono","208":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid","209":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.","210":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count","211":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`.","212":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These","213":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are","214":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `","215":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List","216":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.","217":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.count","218":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP","219":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP`","220":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and","221":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `","222":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List","223":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.","224":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count","225":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count`","226":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bund","227":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled","228":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as","229":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multip","230":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplic","231":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative","232":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and","233":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\n","234":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadd","235":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive","236":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive hom","237":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorph","238":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms","239":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from","240":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `","241":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `Free","242":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeM","243":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMono","244":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid","245":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid`","246":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and","247":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `","248":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `Free","249":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAdd","250":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddM","251":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMono","252":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid","253":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.","254":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n","255":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\n","256":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe","257":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do","258":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not","259":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use","260":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `","261":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to","262":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_","263":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_add","264":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive","265":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive`","266":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because","267":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it","268":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can","269":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can'","270":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't","271":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map","272":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `","273":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Mult","274":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multip","275":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplic","276":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative","277":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative ","278":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115","279":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115`","280":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to","281":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `","282":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115","283":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.","284":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n","285":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-","286":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/","287":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n","288":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\n","289":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable","290":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {","291":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1","292":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 :","293":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type","294":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*}","295":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (","296":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p","297":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p :","298":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1","299":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192","300":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop","301":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop)","302":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [","303":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [Dec","304":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [Decid","305":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [Decidable","306":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred","307":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p","308":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]","309":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n","310":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\n","311":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace","312":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace Free","313":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAdd","314":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddM","315":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMono","316":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid","317":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n","318":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n","319":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/","320":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/--","321":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `","322":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List","323":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.","324":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.count","325":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP","326":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP`","327":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as","328":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a","329":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bund","330":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled","331":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled add","332":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive","333":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive mon","334":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid","335":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid hom","336":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism","337":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism.","338":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -","339":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/","340":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\n","341":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef","342":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef count","343":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP","344":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP :","345":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : Free","346":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAdd","347":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddM","348":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMono","349":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid","350":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1","351":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192","352":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+","353":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ ","354":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115","355":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where","356":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n","357":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n ","358":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  to","359":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun","360":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun :=","361":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List","362":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.","363":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.count","364":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP","365":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p","366":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n","367":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n ","368":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map","369":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_","370":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero","371":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero'","372":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' :=","373":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List","374":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.","375":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.count","376":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP","377":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_","378":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil","379":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _","380":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n","381":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n ","382":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map","383":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_","384":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add","385":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add'","386":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' :=","387":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List","388":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.","389":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.count","390":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP","391":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_","392":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append","393":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _","394":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n","395":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#","396":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align","397":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free","398":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_","399":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add","400":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_","401":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_m","402":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_mono","403":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid","404":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.","405":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.count","406":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp","407":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp Free","408":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAdd","409":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddM","410":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMono","411":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid","412":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.","413":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.count","414":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP","415":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n","416":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\n","417":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem","418":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem count","419":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP","420":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_","421":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of","422":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (","423":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x","424":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x :","425":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1","426":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1)","427":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) :","428":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : count","429":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP","430":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p","431":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (","432":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of","433":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x","434":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x)","435":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) =","436":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if","437":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p","438":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x","439":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x =","440":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true","441":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then","442":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then ","443":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1","444":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else","445":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else ","446":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0","447":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 :=","448":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by","449":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n","450":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n ","451":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp","452":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [","453":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [count","454":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP","455":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP,","456":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List","457":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.","458":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.count","459":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP","460":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP,","461":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List","462":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.","463":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.count","464":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP","465":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.","466":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go","467":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]","468":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n","469":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#","470":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align","471":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free","472":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_","473":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add","474":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_","475":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_m","476":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_mono","477":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid","478":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.","479":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.count","480":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp","481":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_","482":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of","483":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of Free","484":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAdd","485":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddM","486":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMono","487":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid","488":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.","489":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.count","490":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP","491":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_","492":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of","493":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n","494":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\n","495":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem","496":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem count","497":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP","498":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_","499":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply","500":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (","501":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l","502":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l :","503":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : Free","504":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAdd","505":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddM","506":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMono","507":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid","508":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1","509":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1)","510":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) :","511":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : count","512":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP","513":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p","514":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l","515":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l =","516":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List","517":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.","518":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.count","519":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP","520":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p","521":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l","522":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l :=","523":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := r","524":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl","525":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n","526":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#","527":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align","528":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free","529":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_","530":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add","531":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_","532":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_m","533":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_mono","534":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid","535":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.","536":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.count","537":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp","538":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_","539":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply","540":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply Free","541":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAdd","542":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddM","543":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMono","544":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid","545":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.","546":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.count","547":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP","548":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_","549":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply","550":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n","551":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n","552":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/","553":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/--","554":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `","555":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List","556":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.","557":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count","558":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count`","559":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as","560":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a","561":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bund","562":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled","563":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled add","564":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive","565":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive mon","566":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid","567":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid hom","568":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism","569":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism.","570":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -","571":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/","572":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n","573":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n--","574":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Port","575":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting","576":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note","577":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note:","578":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was","579":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (","580":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x","581":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x =","582":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7","583":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)","584":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\n","585":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef","586":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count","587":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [","588":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [Dec","589":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [Decid","590":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [Decidable","591":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq","592":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1","593":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1]","594":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (","595":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x","596":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x :","597":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1","598":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1)","599":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) :","600":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : Free","601":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAdd","602":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddM","603":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMono","604":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid","605":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1","606":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192","607":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+","608":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ ","609":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115","610":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 :=","611":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := count","612":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP","613":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (","614":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7","615":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 =","616":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x","617":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)","618":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n","619":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#","620":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align","621":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free","622":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_","623":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add","624":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_","625":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_m","626":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_mono","627":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid","628":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.","629":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count","630":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count Free","631":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAdd","632":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddM","633":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMono","634":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid","635":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.","636":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count","637":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n","638":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\n","639":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem","640":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count","641":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_","642":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of","643":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [","644":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [Dec","645":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [Decid","646":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [Decidable","647":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq","648":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1","649":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1]","650":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (","651":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x","652":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y","653":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y :","654":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1","655":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1)","656":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :","657":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count","658":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x","659":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (","660":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of","661":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y","662":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y)","663":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) =","664":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (","665":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi","666":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.","667":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single","668":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x","669":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x ","670":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1","671":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 :","672":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1","673":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192","674":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 ","675":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115","676":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115)","677":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y","678":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y :=","679":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by","680":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n","681":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n ","682":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp","683":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [","684":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi","685":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.","686":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single","687":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single,","688":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function","689":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.","690":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update","691":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update,","692":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count","693":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count,","694":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, count","695":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP","696":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP,","697":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List","698":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.","699":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.count","700":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP","701":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP,","702":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List","703":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.","704":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.count","705":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP","706":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.","707":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go","708":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,","709":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n","710":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n   ","711":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool","712":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.","713":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.be","714":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq","715":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_","716":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq","717":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_","718":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_de","719":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide","720":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_","721":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq","722":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]","723":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n","724":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#","725":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align","726":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free","727":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_","728":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add","729":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_","730":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_m","731":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_mono","732":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid","733":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.","734":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count","735":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_","736":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of","737":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of Free","738":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAdd","739":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddM","740":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMono","741":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid","742":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.","743":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count","744":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_","745":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of","746":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n","747":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\n","748":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem","749":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count","750":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_","751":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply","752":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [","753":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [Dec","754":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [Decid","755":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [Decidable","756":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq","757":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1","758":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1]","759":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (","760":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x","761":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x :","762":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1","763":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1)","764":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (","765":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l","766":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l :","767":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : Free","768":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAdd","769":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddM","770":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMono","771":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid","772":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1","773":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1)","774":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :","775":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count","776":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x","777":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l","778":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l =","779":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List","780":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.","781":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count","782":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x","783":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l","784":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=","785":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n","786":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n ","787":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  r","788":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl","789":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n","790":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#","791":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align","792":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free","793":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_","794":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add","795":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_","796":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_m","797":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_mono","798":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid","799":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.","800":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count","801":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_","802":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply","803":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply Free","804":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAdd","805":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddM","806":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMono","807":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid","808":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.","809":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count","810":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_","811":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply","812":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n","813":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\n","814":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend","815":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend Free","816":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAdd","817":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddM","818":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMono","819":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid","820":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n","821":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\n","822":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace","823":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace Free","824":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeM","825":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMono","826":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid","827":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n","828":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n","829":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/","830":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/--","831":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `","832":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List","833":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.","834":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.count","835":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP","836":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP`","837":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as","838":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a","839":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bund","840":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled","841":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multip","842":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplic","843":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative","844":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative mon","845":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid","846":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid hom","847":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism","848":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism.","849":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -","850":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/","851":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\n","852":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef","853":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef count","854":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP","855":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP :","856":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : Free","857":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeM","858":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMono","859":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid","860":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1","861":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192","862":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192*","863":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Mult","864":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multip","865":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplic","866":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative","867":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative ","868":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115","869":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=","870":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n","871":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n   ","872":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    Add","873":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddM","874":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMono","875":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoid","876":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom","877":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.","878":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.to","879":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMult","880":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultip","881":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplic","882":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative","883":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (","884":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (Free","885":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAdd","886":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddM","887":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMono","888":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid","889":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.","890":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.count","891":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP","892":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p","893":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)","894":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n","895":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#","896":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align","897":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free","898":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_","899":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_m","900":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_mono","901":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid","902":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.","903":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.count","904":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp","905":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp Free","906":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeM","907":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMono","908":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid","909":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.","910":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.count","911":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP","912":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n","913":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\n","914":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem","915":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem count","916":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP","917":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_","918":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of","919":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of'","920":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (","921":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x","922":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x :","923":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1","924":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1)","925":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :","926":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n","927":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n   ","928":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    count","929":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP","930":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p","931":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (","932":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of","933":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x","934":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x)","935":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) =","936":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if","937":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p","938":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x","939":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then","940":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Mult","941":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multip","942":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplic","943":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative","944":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.","945":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.of","946":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd","947":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd ","948":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1","949":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else","950":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Mult","951":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multip","952":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplic","953":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative","954":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.","955":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.of","956":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd","957":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd ","958":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0","959":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 :=","960":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by","961":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n","962":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n   ","963":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw","964":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [","965":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [Free","966":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAdd","967":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddM","968":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMono","969":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid","970":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.","971":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.count","972":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP","973":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_","974":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of","975":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]","976":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n","977":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n   ","978":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp","979":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only","980":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [","981":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq","982":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_","983":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff","984":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_","985":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff","986":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff,","987":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, if","988":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff","989":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_","990":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true","991":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true,","992":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, of","993":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd","994":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_","995":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero","996":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero];","997":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; r","998":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl","999":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n","1000":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#","1001":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align","1002":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free","1003":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_","1004":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_m","1005":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_mono","1006":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid","1007":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.","1008":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.count","1009":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp","1010":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_","1011":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of","1012":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of'","1013":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' Free","1014":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeM","1015":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMono","1016":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid","1017":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.","1018":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.count","1019":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP","1020":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_","1021":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of","1022":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'","1023":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n","1024":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\n","1025":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem","1026":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem count","1027":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP","1028":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_","1029":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of","1030":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (","1031":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x","1032":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x :","1033":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1","1034":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1)","1035":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) :","1036":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : count","1037":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP","1038":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p","1039":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (","1040":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of","1041":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x","1042":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x)","1043":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) =","1044":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if","1045":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p","1046":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x","1047":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then","1048":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Mult","1049":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multip","1050":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplic","1051":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative","1052":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.","1053":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.of","1054":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd","1055":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd ","1056":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1","1057":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else","1058":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else ","1059":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1","1060":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 :=","1061":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by","1062":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n","1063":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n ","1064":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  r","1065":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw","1066":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [","1067":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [count","1068":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP","1069":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_","1070":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of","1071":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of',","1072":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', of","1073":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd","1074":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_","1075":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero","1076":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]","1077":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n","1078":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#","1079":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align","1080":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free","1081":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_","1082":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_m","1083":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_mono","1084":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid","1085":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.","1086":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.count","1087":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp","1088":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_","1089":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of","1090":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of Free","1091":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeM","1092":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMono","1093":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid","1094":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.","1095":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.count","1096":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP","1097":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_","1098":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of","1099":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n","1100":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n","1101":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n--","1102":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `","1103":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `r","1104":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl","1105":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl`","1106":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is","1107":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not","1108":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not trans","1109":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive","1110":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\n","1111":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem","1112":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem count","1113":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP","1114":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_","1115":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply","1116":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (","1117":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l","1118":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l :","1119":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : Free","1120":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAdd","1121":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddM","1122":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMono","1123":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid","1124":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1","1125":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1)","1126":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) :","1127":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : count","1128":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP","1129":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p","1130":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l","1131":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l =","1132":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Mult","1133":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multip","1134":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplic","1135":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative","1136":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.","1137":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.of","1138":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd","1139":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (","1140":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List","1141":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.","1142":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.count","1143":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP","1144":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p","1145":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l","1146":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l)","1147":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=","1148":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n","1149":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n ","1150":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  r","1151":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl","1152":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n","1153":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#","1154":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align","1155":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free","1156":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_","1157":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_m","1158":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_mono","1159":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid","1160":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.","1161":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.count","1162":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp","1163":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_","1164":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply","1165":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply Free","1166":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeM","1167":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMono","1168":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid","1169":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.","1170":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.count","1171":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP","1172":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_","1173":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply","1174":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n","1175":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n","1176":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/","1177":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/--","1178":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `","1179":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List","1180":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.","1181":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count","1182":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count`","1183":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as","1184":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a","1185":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bund","1186":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled","1187":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled add","1188":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive","1189":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive mon","1190":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid","1191":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid hom","1192":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism","1193":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism.","1194":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -","1195":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/","1196":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n","1197":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef","1198":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count","1199":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [","1200":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [Dec","1201":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [Decid","1202":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [Decidable","1203":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq","1204":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1","1205":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1]","1206":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (","1207":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x","1208":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x :","1209":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1","1210":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1)","1211":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) :","1212":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : Free","1213":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeM","1214":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMono","1215":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid","1216":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1","1217":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192","1218":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192*","1219":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Mult","1220":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multip","1221":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplic","1222":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative","1223":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative ","1224":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115","1225":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=","1226":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := count","1227":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP","1228":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (","1229":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7","1230":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 =","1231":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x","1232":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)","1233":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n","1234":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#","1235":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align","1236":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free","1237":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_","1238":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_m","1239":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_mono","1240":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid","1241":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.","1242":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count","1243":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count Free","1244":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeM","1245":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMono","1246":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid","1247":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.","1248":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count","1249":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n","1250":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\n","1251":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem","1252":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count","1253":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_","1254":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply","1255":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [","1256":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [Dec","1257":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [Decid","1258":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [Decidable","1259":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq","1260":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1","1261":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1]","1262":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (","1263":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x","1264":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x :","1265":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1","1266":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1)","1267":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (","1268":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l","1269":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l :","1270":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : Free","1271":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAdd","1272":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddM","1273":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMono","1274":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid","1275":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1","1276":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1)","1277":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :","1278":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n","1279":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n   ","1280":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count","1281":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x","1282":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l","1283":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l =","1284":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Mult","1285":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multip","1286":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplic","1287":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative","1288":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.","1289":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.of","1290":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd","1291":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (","1292":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List","1293":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.","1294":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count","1295":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x","1296":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l","1297":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l)","1298":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) :=","1299":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := r","1300":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl","1301":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n","1302":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#","1303":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align","1304":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free","1305":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_","1306":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_m","1307":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_mono","1308":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid","1309":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.","1310":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count","1311":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_","1312":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply","1313":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply Free","1314":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeM","1315":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMono","1316":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid","1317":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.","1318":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count","1319":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_","1320":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply","1321":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n","1322":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\n","1323":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem","1324":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count","1325":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_","1326":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of","1327":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [","1328":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [Dec","1329":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [Decid","1330":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [Decidable","1331":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq","1332":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1","1333":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1]","1334":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (","1335":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x","1336":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y","1337":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y :","1338":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1","1339":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1)","1340":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :","1341":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n","1342":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n   ","1343":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count","1344":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x","1345":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (","1346":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of","1347":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y","1348":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y)","1349":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) =","1350":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @","1351":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi","1352":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.","1353":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mul","1354":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle","1355":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1","1356":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (","1357":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun","1358":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _","1359":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ =>","1360":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Mult","1361":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multip","1362":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplic","1363":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative","1364":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative ","1365":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115","1366":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115)","1367":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _","1368":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _","1369":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x","1370":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (","1371":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Mult","1372":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multip","1373":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplic","1374":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative","1375":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.","1376":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.of","1377":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd","1378":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd ","1379":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1","1380":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1)","1381":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y","1382":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=","1383":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n","1384":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n ","1385":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by","1386":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp","1387":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [","1388":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count","1389":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count,","1390":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, count","1391":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP","1392":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_","1393":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of","1394":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of,","1395":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi","1396":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.","1397":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mul","1398":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle","1399":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_","1400":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply","1401":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply,","1402":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq","1403":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_","1404":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm","1405":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm,","1406":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool","1407":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.","1408":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.be","1409":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq","1410":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_","1411":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq","1412":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_","1413":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_de","1414":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide","1415":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_","1416":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq","1417":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]","1418":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n","1419":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#","1420":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align","1421":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free","1422":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_","1423":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_m","1424":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_mono","1425":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid","1426":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.","1427":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count","1428":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_","1429":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of","1430":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of Free","1431":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeM","1432":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMono","1433":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMonoid","1434":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMonoid.","1435":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMonoid.count","1436":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMonoid.count_","1437":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMonoid.count_of","1438":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMonoid.count_of\n","1439":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMonoid.count_of\n\n","1440":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMonoid.count_of\n\nend","1441":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMonoid.count_of\n\nend Free","1442":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMonoid.count_of\n\nend FreeM","1443":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMonoid.count_of\n\nend FreeMono","1444":"\/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-\/\nimport Mathlib.Algebra.FreeMonoid.Basic\nimport Mathlib.Data.List.Count\n\n#align_import algebra.free_monoid.count from \"leanprover-community\/mathlib\"@\"a2d2e18906e2b62627646b5d5be856e6a642062f\"\n\n\/-!\n# `List.count` as a bundled homomorphism\n\nIn this file we define `FreeMonoid.countP`, `FreeMonoid.count`, `FreeAddMonoid.countP`, and\n`FreeAddMonoid.count`. These are `List.countP` and `List.count` bundled as multiplicative and\nadditive homomorphisms from `FreeMonoid` and `FreeAddMonoid`.\n\nWe do not use `to_additive` because it can't map `Multiplicative \u2115` to `\u2115`.\n-\/\n\nvariable {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\nnamespace FreeAddMonoid\n\n\/-- `List.countP` as a bundled additive monoid homomorphism. -\/\ndef countP : FreeAddMonoid \u03b1 \u2192+ \u2115 where\n  toFun := List.countP p\n  map_zero' := List.countP_nil _\n  map_add' := List.countP_append _\n#align free_add_monoid.countp FreeAddMonoid.countP\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x = true then 1 else 0 := by\n  simp [countP, List.countP, List.countP.go]\n#align free_add_monoid.countp_of FreeAddMonoid.countP_of\n\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = List.countP p l := rfl\n#align free_add_monoid.countp_apply FreeAddMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\n-- Porting note: was (x = \u00b7)\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeAddMonoid \u03b1 \u2192+ \u2115 := countP (\u00b7 = x)\n#align free_add_monoid.count FreeAddMonoid.count\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) : count x (of y) = (Pi.single x 1 : \u03b1 \u2192 \u2115) y := by\n  simp [Pi.single, Function.update, count, countP, List.countP, List.countP.go,\n    Bool.beq_eq_decide_eq]\n#align free_add_monoid.count_of FreeAddMonoid.count_of\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) : count x l = List.count x l :=\n  rfl\n#align free_add_monoid.count_apply FreeAddMonoid.count_apply\n\nend FreeAddMonoid\n\nnamespace FreeMonoid\n\n\/-- `List.countP` as a bundled multiplicative monoid homomorphism. -\/\ndef countP : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 :=\n    AddMonoidHom.toMultiplicative (FreeAddMonoid.countP p)\n#align free_monoid.countp FreeMonoid.countP\n\ntheorem countP_of' (x : \u03b1) :\n    countP p (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0 := by\n    erw [FreeAddMonoid.countP_of]\n    simp only [eq_iff_iff, iff_true, ofAdd_zero]; rfl\n#align free_monoid.countp_of' FreeMonoid.countP_of'\n\ntheorem countP_of (x : \u03b1) : countP p (of x) = if p x then Multiplicative.ofAdd 1 else 1 := by\n  rw [countP_of', ofAdd_zero]\n#align free_monoid.countp_of FreeMonoid.countP_of\n\n-- `rfl` is not transitive\ntheorem countP_apply (l : FreeAddMonoid \u03b1) : countP p l = Multiplicative.ofAdd (List.countP p l) :=\n  rfl\n#align free_monoid.countp_apply FreeMonoid.countP_apply\n\n\/-- `List.count` as a bundled additive monoid homomorphism. -\/\ndef count [DecidableEq \u03b1] (x : \u03b1) : FreeMonoid \u03b1 \u2192* Multiplicative \u2115 := countP (\u00b7 = x)\n#align free_monoid.count FreeMonoid.count\n\ntheorem count_apply [DecidableEq \u03b1] (x : \u03b1) (l : FreeAddMonoid \u03b1) :\n    count x l = Multiplicative.ofAdd (List.count x l) := rfl\n#align free_monoid.count_apply FreeMonoid.count_apply\n\ntheorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = @Pi.mulSingle \u03b1 (fun _ => Multiplicative \u2115) _ _ x (Multiplicative.ofAdd 1) y :=\n  by simp [count, countP_of, Pi.mulSingle_apply, eq_comm, Bool.beq_eq_decide_eq]\n#align free_monoid.count_of FreeMonoid.count_of\n\nend FreeMonoid"},"target":{"0":"-","1":"<0x0A>","2":"Copy","3":"right","4":"\u2581(","5":"c","6":")","7":"\u2581","8":"2","9":"0","10":"2","11":"2","12":"\u2581Y","13":"ury","14":"\u2581K","15":"ud","16":"ry","17":"ash","18":"ov","19":".","20":"\u2581All","21":"\u2581rights","22":"\u2581reserved","23":".","24":"<0x0A>","25":"Re","26":"leased","27":"\u2581under","28":"\u2581Apache","29":"\u2581","30":"2","31":".","32":"0","33":"\u2581license","34":"\u2581as","35":"\u2581described","36":"\u2581in","37":"\u2581the","38":"\u2581file","39":"\u2581L","40":"IC","41":"EN","42":"SE","43":".","44":"<0x0A>","45":"Auth","46":"ors","47":":","48":"\u2581Y","49":"ury","50":"\u2581K","51":"ud","52":"ry","53":"ash","54":"ov","55":"<0x0A>","56":"-","57":"\/","58":"<0x0A>","59":"import","60":"\u2581Math","61":"lib","62":".","63":"Al","64":"gebra","65":".","66":"Free","67":"M","68":"ono","69":"id","70":".","71":"Basic","72":"<0x0A>","73":"import","74":"\u2581Math","75":"lib","76":".","77":"Data","78":".","79":"List","80":".","81":"Count","82":"<0x0A>","83":"<0x0A>","84":"#","85":"align","86":"_","87":"import","88":"\u2581algebra","89":".","90":"free","91":"_","92":"m","93":"ono","94":"id","95":".","96":"count","97":"\u2581from","98":"\u2581\"","99":"lean","100":"pro","101":"ver","102":"-","103":"community","104":"\/","105":"math","106":"lib","107":"\"","108":"@\"","109":"a","110":"2","111":"d","112":"2","113":"e","114":"1","115":"8","116":"9","117":"0","118":"6","119":"e","120":"2","121":"b","122":"6","123":"2","124":"6","125":"2","126":"7","127":"6","128":"4","129":"6","130":"b","131":"5","132":"d","133":"5","134":"be","135":"8","136":"5","137":"6","138":"e","139":"6","140":"a","141":"6","142":"4","143":"2","144":"0","145":"6","146":"2","147":"f","148":"\"","149":"<0x0A>","150":"<0x0A>","151":"\/-","152":"!","153":"<0x0A>","154":"#","155":"\u2581`","156":"List","157":".","158":"count","159":"`","160":"\u2581as","161":"\u2581a","162":"\u2581bund","163":"led","164":"\u2581hom","165":"omorphism","166":"<0x0A>","167":"<0x0A>","168":"In","169":"\u2581this","170":"\u2581file","171":"\u2581we","172":"\u2581define","173":"\u2581`","174":"Free","175":"M","176":"ono","177":"id","178":".","179":"count","180":"P","181":"`,","182":"\u2581`","183":"Free","184":"M","185":"ono","186":"id","187":".","188":"count","189":"`,","190":"\u2581`","191":"Free","192":"Add","193":"M","194":"ono","195":"id","196":".","197":"count","198":"P","199":"`,","200":"\u2581and","201":"<0x0A>","202":"`","203":"Free","204":"Add","205":"M","206":"ono","207":"id","208":".","209":"count","210":"`.","211":"\u2581These","212":"\u2581are","213":"\u2581`","214":"List","215":".","216":"count","217":"P","218":"`","219":"\u2581and","220":"\u2581`","221":"List","222":".","223":"count","224":"`","225":"\u2581bund","226":"led","227":"\u2581as","228":"\u2581multip","229":"lic","230":"ative","231":"\u2581and","232":"<0x0A>","233":"add","234":"itive","235":"\u2581hom","236":"omorph","237":"isms","238":"\u2581from","239":"\u2581`","240":"Free","241":"M","242":"ono","243":"id","244":"`","245":"\u2581and","246":"\u2581`","247":"Free","248":"Add","249":"M","250":"ono","251":"id","252":"`.","253":"<0x0A>","254":"<0x0A>","255":"We","256":"\u2581do","257":"\u2581not","258":"\u2581use","259":"\u2581`","260":"to","261":"_","262":"add","263":"itive","264":"`","265":"\u2581because","266":"\u2581it","267":"\u2581can","268":"'","269":"t","270":"\u2581map","271":"\u2581`","272":"Mult","273":"ip","274":"lic","275":"ative","276":"\u2581","277":"\u2115","278":"`","279":"\u2581to","280":"\u2581`","281":"\u2115","282":"`.","283":"<0x0A>","284":"-","285":"\/","286":"<0x0A>","287":"<0x0A>","288":"variable","289":"\u2581{","290":"\u03b1","291":"\u2581:","292":"\u2581Type","293":"*}","294":"\u2581(","295":"p","296":"\u2581:","297":"\u2581\u03b1","298":"\u2581\u2192","299":"\u2581Prop","300":")","301":"\u2581[","302":"Dec","303":"id","304":"able","305":"Pred","306":"\u2581p","307":"]","308":"<0x0A>","309":"<0x0A>","310":"namespace","311":"\u2581Free","312":"Add","313":"M","314":"ono","315":"id","316":"<0x0A>","317":"<0x0A>","318":"\/","319":"--","320":"\u2581`","321":"List","322":".","323":"count","324":"P","325":"`","326":"\u2581as","327":"\u2581a","328":"\u2581bund","329":"led","330":"\u2581add","331":"itive","332":"\u2581mon","333":"oid","334":"\u2581hom","335":"omorphism","336":".","337":"\u2581-","338":"\/","339":"<0x0A>","340":"def","341":"\u2581count","342":"P","343":"\u2581:","344":"\u2581Free","345":"Add","346":"M","347":"ono","348":"id","349":"\u2581\u03b1","350":"\u2581\u2192","351":"+","352":"\u2581","353":"\u2115","354":"\u2581where","355":"<0x0A>","356":"\u2581","357":"\u2581to","358":"Fun","359":"\u2581:=","360":"\u2581List","361":".","362":"count","363":"P","364":"\u2581p","365":"<0x0A>","366":"\u2581","367":"\u2581map","368":"_","369":"zero","370":"'","371":"\u2581:=","372":"\u2581List","373":".","374":"count","375":"P","376":"_","377":"nil","378":"\u2581_","379":"<0x0A>","380":"\u2581","381":"\u2581map","382":"_","383":"add","384":"'","385":"\u2581:=","386":"\u2581List","387":".","388":"count","389":"P","390":"_","391":"append","392":"\u2581_","393":"<0x0A>","394":"#","395":"align","396":"\u2581free","397":"_","398":"add","399":"_","400":"m","401":"ono","402":"id","403":".","404":"count","405":"p","406":"\u2581Free","407":"Add","408":"M","409":"ono","410":"id","411":".","412":"count","413":"P","414":"<0x0A>","415":"<0x0A>","416":"theorem","417":"\u2581count","418":"P","419":"_","420":"of","421":"\u2581(","422":"x","423":"\u2581:","424":"\u2581\u03b1","425":")","426":"\u2581:","427":"\u2581count","428":"P","429":"\u2581p","430":"\u2581(","431":"of","432":"\u2581x","433":")","434":"\u2581=","435":"\u2581if","436":"\u2581p","437":"\u2581x","438":"\u2581=","439":"\u2581true","440":"\u2581then","441":"\u2581","442":"1","443":"\u2581else","444":"\u2581","445":"0","446":"\u2581:=","447":"\u2581by","448":"<0x0A>","449":"\u2581","450":"\u2581simp","451":"\u2581[","452":"count","453":"P","454":",","455":"\u2581List","456":".","457":"count","458":"P","459":",","460":"\u2581List","461":".","462":"count","463":"P","464":".","465":"go","466":"]","467":"<0x0A>","468":"#","469":"align","470":"\u2581free","471":"_","472":"add","473":"_","474":"m","475":"ono","476":"id","477":".","478":"count","479":"p","480":"_","481":"of","482":"\u2581Free","483":"Add","484":"M","485":"ono","486":"id","487":".","488":"count","489":"P","490":"_","491":"of","492":"<0x0A>","493":"<0x0A>","494":"theorem","495":"\u2581count","496":"P","497":"_","498":"apply","499":"\u2581(","500":"l","501":"\u2581:","502":"\u2581Free","503":"Add","504":"M","505":"ono","506":"id","507":"\u2581\u03b1","508":")","509":"\u2581:","510":"\u2581count","511":"P","512":"\u2581p","513":"\u2581l","514":"\u2581=","515":"\u2581List","516":".","517":"count","518":"P","519":"\u2581p","520":"\u2581l","521":"\u2581:=","522":"\u2581r","523":"fl","524":"<0x0A>","525":"#","526":"align","527":"\u2581free","528":"_","529":"add","530":"_","531":"m","532":"ono","533":"id","534":".","535":"count","536":"p","537":"_","538":"apply","539":"\u2581Free","540":"Add","541":"M","542":"ono","543":"id","544":".","545":"count","546":"P","547":"_","548":"apply","549":"<0x0A>","550":"<0x0A>","551":"\/","552":"--","553":"\u2581`","554":"List","555":".","556":"count","557":"`","558":"\u2581as","559":"\u2581a","560":"\u2581bund","561":"led","562":"\u2581add","563":"itive","564":"\u2581mon","565":"oid","566":"\u2581hom","567":"omorphism","568":".","569":"\u2581-","570":"\/","571":"<0x0A>","572":"--","573":"\u2581Port","574":"ing","575":"\u2581note","576":":","577":"\u2581was","578":"\u2581(","579":"x","580":"\u2581=","581":"\u2581\u00b7","582":")","583":"<0x0A>","584":"def","585":"\u2581count","586":"\u2581[","587":"Dec","588":"id","589":"able","590":"Eq","591":"\u2581\u03b1","592":"]","593":"\u2581(","594":"x","595":"\u2581:","596":"\u2581\u03b1","597":")","598":"\u2581:","599":"\u2581Free","600":"Add","601":"M","602":"ono","603":"id","604":"\u2581\u03b1","605":"\u2581\u2192","606":"+","607":"\u2581","608":"\u2115","609":"\u2581:=","610":"\u2581count","611":"P","612":"\u2581(","613":"\u00b7","614":"\u2581=","615":"\u2581x","616":")","617":"<0x0A>","618":"#","619":"align","620":"\u2581free","621":"_","622":"add","623":"_","624":"m","625":"ono","626":"id","627":".","628":"count","629":"\u2581Free","630":"Add","631":"M","632":"ono","633":"id","634":".","635":"count","636":"<0x0A>","637":"<0x0A>","638":"theorem","639":"\u2581count","640":"_","641":"of","642":"\u2581[","643":"Dec","644":"id","645":"able","646":"Eq","647":"\u2581\u03b1","648":"]","649":"\u2581(","650":"x","651":"\u2581y","652":"\u2581:","653":"\u2581\u03b1","654":")","655":"\u2581:","656":"\u2581count","657":"\u2581x","658":"\u2581(","659":"of","660":"\u2581y","661":")","662":"\u2581=","663":"\u2581(","664":"Pi","665":".","666":"single","667":"\u2581x","668":"\u2581","669":"1","670":"\u2581:","671":"\u2581\u03b1","672":"\u2581\u2192","673":"\u2581","674":"\u2115","675":")","676":"\u2581y","677":"\u2581:=","678":"\u2581by","679":"<0x0A>","680":"\u2581","681":"\u2581simp","682":"\u2581[","683":"Pi","684":".","685":"single","686":",","687":"\u2581Function","688":".","689":"update","690":",","691":"\u2581count","692":",","693":"\u2581count","694":"P","695":",","696":"\u2581List","697":".","698":"count","699":"P","700":",","701":"\u2581List","702":".","703":"count","704":"P","705":".","706":"go","707":",","708":"<0x0A>","709":"\u2581\u2581\u2581","710":"\u2581Bool","711":".","712":"be","713":"q","714":"_","715":"eq","716":"_","717":"de","718":"cide","719":"_","720":"eq","721":"]","722":"<0x0A>","723":"#","724":"align","725":"\u2581free","726":"_","727":"add","728":"_","729":"m","730":"ono","731":"id","732":".","733":"count","734":"_","735":"of","736":"\u2581Free","737":"Add","738":"M","739":"ono","740":"id","741":".","742":"count","743":"_","744":"of","745":"<0x0A>","746":"<0x0A>","747":"theorem","748":"\u2581count","749":"_","750":"apply","751":"\u2581[","752":"Dec","753":"id","754":"able","755":"Eq","756":"\u2581\u03b1","757":"]","758":"\u2581(","759":"x","760":"\u2581:","761":"\u2581\u03b1","762":")","763":"\u2581(","764":"l","765":"\u2581:","766":"\u2581Free","767":"Add","768":"M","769":"ono","770":"id","771":"\u2581\u03b1","772":")","773":"\u2581:","774":"\u2581count","775":"\u2581x","776":"\u2581l","777":"\u2581=","778":"\u2581List","779":".","780":"count","781":"\u2581x","782":"\u2581l","783":"\u2581:=","784":"<0x0A>","785":"\u2581","786":"\u2581r","787":"fl","788":"<0x0A>","789":"#","790":"align","791":"\u2581free","792":"_","793":"add","794":"_","795":"m","796":"ono","797":"id","798":".","799":"count","800":"_","801":"apply","802":"\u2581Free","803":"Add","804":"M","805":"ono","806":"id","807":".","808":"count","809":"_","810":"apply","811":"<0x0A>","812":"<0x0A>","813":"end","814":"\u2581Free","815":"Add","816":"M","817":"ono","818":"id","819":"<0x0A>","820":"<0x0A>","821":"namespace","822":"\u2581Free","823":"M","824":"ono","825":"id","826":"<0x0A>","827":"<0x0A>","828":"\/","829":"--","830":"\u2581`","831":"List","832":".","833":"count","834":"P","835":"`","836":"\u2581as","837":"\u2581a","838":"\u2581bund","839":"led","840":"\u2581multip","841":"lic","842":"ative","843":"\u2581mon","844":"oid","845":"\u2581hom","846":"omorphism","847":".","848":"\u2581-","849":"\/","850":"<0x0A>","851":"def","852":"\u2581count","853":"P","854":"\u2581:","855":"\u2581Free","856":"M","857":"ono","858":"id","859":"\u2581\u03b1","860":"\u2581\u2192","861":"*","862":"\u2581Mult","863":"ip","864":"lic","865":"ative","866":"\u2581","867":"\u2115","868":"\u2581:=","869":"<0x0A>","870":"\u2581\u2581\u2581","871":"\u2581Add","872":"M","873":"ono","874":"id","875":"Hom","876":".","877":"to","878":"Mult","879":"ip","880":"lic","881":"ative","882":"\u2581(","883":"Free","884":"Add","885":"M","886":"ono","887":"id","888":".","889":"count","890":"P","891":"\u2581p","892":")","893":"<0x0A>","894":"#","895":"align","896":"\u2581free","897":"_","898":"m","899":"ono","900":"id","901":".","902":"count","903":"p","904":"\u2581Free","905":"M","906":"ono","907":"id","908":".","909":"count","910":"P","911":"<0x0A>","912":"<0x0A>","913":"theorem","914":"\u2581count","915":"P","916":"_","917":"of","918":"'","919":"\u2581(","920":"x","921":"\u2581:","922":"\u2581\u03b1","923":")","924":"\u2581:","925":"<0x0A>","926":"\u2581\u2581\u2581","927":"\u2581count","928":"P","929":"\u2581p","930":"\u2581(","931":"of","932":"\u2581x","933":")","934":"\u2581=","935":"\u2581if","936":"\u2581p","937":"\u2581x","938":"\u2581then","939":"\u2581Mult","940":"ip","941":"lic","942":"ative","943":".","944":"of","945":"Add","946":"\u2581","947":"1","948":"\u2581else","949":"\u2581Mult","950":"ip","951":"lic","952":"ative","953":".","954":"of","955":"Add","956":"\u2581","957":"0","958":"\u2581:=","959":"\u2581by","960":"<0x0A>","961":"\u2581\u2581\u2581","962":"\u2581erw","963":"\u2581[","964":"Free","965":"Add","966":"M","967":"ono","968":"id","969":".","970":"count","971":"P","972":"_","973":"of","974":"]","975":"<0x0A>","976":"\u2581\u2581\u2581","977":"\u2581simp","978":"\u2581only","979":"\u2581[","980":"eq","981":"_","982":"iff","983":"_","984":"iff","985":",","986":"\u2581if","987":"f","988":"_","989":"true","990":",","991":"\u2581of","992":"Add","993":"_","994":"zero","995":"];","996":"\u2581r","997":"fl","998":"<0x0A>","999":"#","1000":"align","1001":"\u2581free","1002":"_","1003":"m","1004":"ono","1005":"id","1006":".","1007":"count","1008":"p","1009":"_","1010":"of","1011":"'","1012":"\u2581Free","1013":"M","1014":"ono","1015":"id","1016":".","1017":"count","1018":"P","1019":"_","1020":"of","1021":"'","1022":"<0x0A>","1023":"<0x0A>","1024":"theorem","1025":"\u2581count","1026":"P","1027":"_","1028":"of","1029":"\u2581(","1030":"x","1031":"\u2581:","1032":"\u2581\u03b1","1033":")","1034":"\u2581:","1035":"\u2581count","1036":"P","1037":"\u2581p","1038":"\u2581(","1039":"of","1040":"\u2581x","1041":")","1042":"\u2581=","1043":"\u2581if","1044":"\u2581p","1045":"\u2581x","1046":"\u2581then","1047":"\u2581Mult","1048":"ip","1049":"lic","1050":"ative","1051":".","1052":"of","1053":"Add","1054":"\u2581","1055":"1","1056":"\u2581else","1057":"\u2581","1058":"1","1059":"\u2581:=","1060":"\u2581by","1061":"<0x0A>","1062":"\u2581","1063":"\u2581r","1064":"w","1065":"\u2581[","1066":"count","1067":"P","1068":"_","1069":"of","1070":"',","1071":"\u2581of","1072":"Add","1073":"_","1074":"zero","1075":"]","1076":"<0x0A>","1077":"#","1078":"align","1079":"\u2581free","1080":"_","1081":"m","1082":"ono","1083":"id","1084":".","1085":"count","1086":"p","1087":"_","1088":"of","1089":"\u2581Free","1090":"M","1091":"ono","1092":"id","1093":".","1094":"count","1095":"P","1096":"_","1097":"of","1098":"<0x0A>","1099":"<0x0A>","1100":"--","1101":"\u2581`","1102":"r","1103":"fl","1104":"`","1105":"\u2581is","1106":"\u2581not","1107":"\u2581trans","1108":"itive","1109":"<0x0A>","1110":"theorem","1111":"\u2581count","1112":"P","1113":"_","1114":"apply","1115":"\u2581(","1116":"l","1117":"\u2581:","1118":"\u2581Free","1119":"Add","1120":"M","1121":"ono","1122":"id","1123":"\u2581\u03b1","1124":")","1125":"\u2581:","1126":"\u2581count","1127":"P","1128":"\u2581p","1129":"\u2581l","1130":"\u2581=","1131":"\u2581Mult","1132":"ip","1133":"lic","1134":"ative","1135":".","1136":"of","1137":"Add","1138":"\u2581(","1139":"List","1140":".","1141":"count","1142":"P","1143":"\u2581p","1144":"\u2581l","1145":")","1146":"\u2581:=","1147":"<0x0A>","1148":"\u2581","1149":"\u2581r","1150":"fl","1151":"<0x0A>","1152":"#","1153":"align","1154":"\u2581free","1155":"_","1156":"m","1157":"ono","1158":"id","1159":".","1160":"count","1161":"p","1162":"_","1163":"apply","1164":"\u2581Free","1165":"M","1166":"ono","1167":"id","1168":".","1169":"count","1170":"P","1171":"_","1172":"apply","1173":"<0x0A>","1174":"<0x0A>","1175":"\/","1176":"--","1177":"\u2581`","1178":"List","1179":".","1180":"count","1181":"`","1182":"\u2581as","1183":"\u2581a","1184":"\u2581bund","1185":"led","1186":"\u2581add","1187":"itive","1188":"\u2581mon","1189":"oid","1190":"\u2581hom","1191":"omorphism","1192":".","1193":"\u2581-","1194":"\/","1195":"<0x0A>","1196":"def","1197":"\u2581count","1198":"\u2581[","1199":"Dec","1200":"id","1201":"able","1202":"Eq","1203":"\u2581\u03b1","1204":"]","1205":"\u2581(","1206":"x","1207":"\u2581:","1208":"\u2581\u03b1","1209":")","1210":"\u2581:","1211":"\u2581Free","1212":"M","1213":"ono","1214":"id","1215":"\u2581\u03b1","1216":"\u2581\u2192","1217":"*","1218":"\u2581Mult","1219":"ip","1220":"lic","1221":"ative","1222":"\u2581","1223":"\u2115","1224":"\u2581:=","1225":"\u2581count","1226":"P","1227":"\u2581(","1228":"\u00b7","1229":"\u2581=","1230":"\u2581x","1231":")","1232":"<0x0A>","1233":"#","1234":"align","1235":"\u2581free","1236":"_","1237":"m","1238":"ono","1239":"id","1240":".","1241":"count","1242":"\u2581Free","1243":"M","1244":"ono","1245":"id","1246":".","1247":"count","1248":"<0x0A>","1249":"<0x0A>","1250":"theorem","1251":"\u2581count","1252":"_","1253":"apply","1254":"\u2581[","1255":"Dec","1256":"id","1257":"able","1258":"Eq","1259":"\u2581\u03b1","1260":"]","1261":"\u2581(","1262":"x","1263":"\u2581:","1264":"\u2581\u03b1","1265":")","1266":"\u2581(","1267":"l","1268":"\u2581:","1269":"\u2581Free","1270":"Add","1271":"M","1272":"ono","1273":"id","1274":"\u2581\u03b1","1275":")","1276":"\u2581:","1277":"<0x0A>","1278":"\u2581\u2581\u2581","1279":"\u2581count","1280":"\u2581x","1281":"\u2581l","1282":"\u2581=","1283":"\u2581Mult","1284":"ip","1285":"lic","1286":"ative","1287":".","1288":"of","1289":"Add","1290":"\u2581(","1291":"List","1292":".","1293":"count","1294":"\u2581x","1295":"\u2581l","1296":")","1297":"\u2581:=","1298":"\u2581r","1299":"fl","1300":"<0x0A>","1301":"#","1302":"align","1303":"\u2581free","1304":"_","1305":"m","1306":"ono","1307":"id","1308":".","1309":"count","1310":"_","1311":"apply","1312":"\u2581Free","1313":"M","1314":"ono","1315":"id","1316":".","1317":"count","1318":"_","1319":"apply","1320":"<0x0A>","1321":"<0x0A>","1322":"theorem","1323":"\u2581count","1324":"_","1325":"of","1326":"\u2581[","1327":"Dec","1328":"id","1329":"able","1330":"Eq","1331":"\u2581\u03b1","1332":"]","1333":"\u2581(","1334":"x","1335":"\u2581y","1336":"\u2581:","1337":"\u2581\u03b1","1338":")","1339":"\u2581:","1340":"<0x0A>","1341":"\u2581\u2581\u2581","1342":"\u2581count","1343":"\u2581x","1344":"\u2581(","1345":"of","1346":"\u2581y","1347":")","1348":"\u2581=","1349":"\u2581@","1350":"Pi","1351":".","1352":"mul","1353":"Single","1354":"\u2581\u03b1","1355":"\u2581(","1356":"fun","1357":"\u2581_","1358":"\u2581=>","1359":"\u2581Mult","1360":"ip","1361":"lic","1362":"ative","1363":"\u2581","1364":"\u2115","1365":")","1366":"\u2581_","1367":"\u2581_","1368":"\u2581x","1369":"\u2581(","1370":"Mult","1371":"ip","1372":"lic","1373":"ative","1374":".","1375":"of","1376":"Add","1377":"\u2581","1378":"1","1379":")","1380":"\u2581y","1381":"\u2581:=","1382":"<0x0A>","1383":"\u2581","1384":"\u2581by","1385":"\u2581simp","1386":"\u2581[","1387":"count","1388":",","1389":"\u2581count","1390":"P","1391":"_","1392":"of","1393":",","1394":"\u2581Pi","1395":".","1396":"mul","1397":"Single","1398":"_","1399":"apply","1400":",","1401":"\u2581eq","1402":"_","1403":"comm","1404":",","1405":"\u2581Bool","1406":".","1407":"be","1408":"q","1409":"_","1410":"eq","1411":"_","1412":"de","1413":"cide","1414":"_","1415":"eq","1416":"]","1417":"<0x0A>","1418":"#","1419":"align","1420":"\u2581free","1421":"_","1422":"m","1423":"ono","1424":"id","1425":".","1426":"count","1427":"_","1428":"of","1429":"\u2581Free","1430":"M","1431":"ono","1432":"id","1433":".","1434":"count","1435":"_","1436":"of","1437":"<0x0A>","1438":"<0x0A>","1439":"end","1440":"\u2581Free","1441":"M","1442":"ono","1443":"id","1444":"<0x0A>"}}